import std/xmltree
import std/strformat
import std/strutils
import std/sequtils
import std/tables
import std/logging
import std/options
import std/os

import ./utils
import ./nodedefs
import ./liblogger
import ./extraction
import ./rendering
import ./libfiles
import ./structuredstring


let logger = newMyLogger(open("log", fmWrite), fmtStr="[$time] - $levelname ".fmt)
addHandler(logger)

const libRoot = "src/vulkan"

let
  xml = getVulkanXML()
  resources = xml.extractResources

const warningText = """
# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.
"""


proc genBaseTypes*() =
  let file = open("src/vulkan/basetypes/typedefs.nim", fmWrite)
  defer: close file
  file.write warningText
  file.write "type\n"
  for key, val in resources.basetypes:
    case val.kind
    of nkbExternal: discard
    of nkbNormal:
      file.write "  "
      file.write val.render
      file.write "\n"

  file.write "\n"

  var consts = sstring(kind: skBlock, title: "const")
  consts.add "# == Constants == #"
  for key, val in resources.consts      : consts.add %val.render()
  consts.add "# == Aliases == #"
  for key, val in resources.constAliases: consts.add val.render()
  file.write $consts

proc genHandles* =
  let file = open("src/vulkan/handles/handle_concretes.nim", fmWrite)
  defer: close file
  file.write warningText

  file.write "from ../enums import ObjectType\n"
  file.write "import handle_operations\n"

  var handles = sstring(kind: skBlock, title: "type")
  for key, val in resources.handles: handles.add %val.render(resources.vendorTags)

  file.write $handles

proc genEnums*() =
  var res = sstring(kind: skBlock, title: "type")
  var rendered: seq[string]
  let file = "src/vulkan/enums/enumdefs.nim".open(fmWrite)
  defer: close file
  file.write warningText

  file.write "import tools\n"
  file.write "import ../basetypes\n"

  var enumAliases = newTable[string, NodeEnumAliases]()
  for feature in concat(xml.findAll("feature"), xml.findAll("extension")):
    var featureStr = sstring(kind: skBlock)
    for requiresXml in feature.findAll("require"):
      var requires = requiresXml.extractNodeRequire
      var reqStr = sstring(kind: skBlock)
      for req in requires.targets:
        if req.name in rendered: continue
        case req.kind

        of nkrType:
          if resources.enums.haskey(req.name):
            reqStr.add render( resources.enums[req.name], resources.vendorTags )
          elif resources.bitmasks.hasKey(req.name):
            reqStr.add render( resources.bitmasks[req.name] )
          if resources.enumAliases.hasKey(req.name):
            enumAliases[req.name] = resources.enumAliases[req.name]
          rendered.add req.name

        of nkrEnumExtendAlias:
          if enumAliases.hasKey(req.extends):
            enumAliases[req.extends].aliases.add NodeEnumAlias(
              name: req.name,
              alias: req.enumAlias,
            )
          else:
            enumAliases[req.extends] = NodeEnumAliases(
              name: req.extends,
              aliases: @[NodeEnumAlias(
                name: req.name,
                alias: req.enumAlias,
              )]
            )

        else: discard

      if reqstr.sons.len > 0:
        if requires.comment.isSome:
          reqStr.sons.insert(comment requires.comment.get.underline('-'), 0)
        featureStr.add reqstr
    if featureStr.sons.len > 0:
      res.add comment feature{"name"}
        .removeVkPrefix
        .replace("_", " ")
        .underline('=')
      res.add featureStr

  file.write res
  file.write "\n\n\n"

  res = sstring(kind: skBlock)
  for key, val in enumAliases:
    res.add val.render(resources.vendorTags)

  file.write res

proc genObjects =
  var res = sstring(kind: skBlock, title: "type")
  var rendered: Table[string, bool]
  let commonfile = open("src/vulkan/objects/objectdefs_common.nim", fmWrite)
  defer: commonfile.close
  commonfile.write warningText
  commonfile.write "import tools\n"
  commonfile.write "import temp_externalobjects\n"

  for feature in concat(xml.findAll("feature"), xml.findAll("extension")):
    var featureStr = sstring(kind: skBlock)
    for requiresXml in feature.findAll("require"):
      let requires = requiresXml.extractNodeRequire
      var reqStr = sstring(kind: skBlock)
      for req in requires.targets:
        if req.kind != nkrType: continue
        if rendered.hasKey(req.name): continue
        rendered[req.name] = true
        if resources.structs.hasKey(req.name):
          reqStr.add render(resources.structs[req.name])
        elif resources.funcPtrs.hasKey(req.name):
          reqStr.add render(resources.funcPtrs[req.name])

      if reqStr.sons.len != 0:
        if requires.comment.isSome:
          reqStr.sons.insert(comment requires.comment.get, 0)
        featureStr.add reqStr
    if featureStr.sons.len > 0:
      res.add comment feature{"name"}
        .removeVkPrefix
        .replace("_", " ")
        .underline('=')
      res.add featureStr
  
  commonfile.write res

proc isValidExtension(name: string): bool =
  let words = name.parseWords({'_'})
  if words.len >= 1 and words[1] == "RESERVED": return false

  if words.len == 4 and words[2] == "extension":
    try:
      discard words[3].parseInt
      return false
    except: discard

  return true

proc genCommands*() =
  const commandsDir = "commands"

  const featDir = commandsDir/"features"
  var features = new TableRef[string, Feature]
  var libfiles: seq[LibFile]

  let
    toolsFile = LibFile(path: commandsDir/"tools")
    toolsFeature = Feature(name: "tools")
  toolsFeature.affiliate toolsFile
  features["tools"] = toolsFeature

  # = VULKAN FEATURES =

  for featureXML in xml.findAll("feature"):

    let
      comment = featureXML{"comment"}
      name = featureXML{"name"}

    var feature = Feature(name: name)
    features[name] = feature

    if (?comment).isSome:
      feature.comment = some comment.underline('=').commentify

    for require in featureXML.findAll("require"):
      feature.requires.add require.extractNodeRequire

    var file = new LibFile
    libfiles.add file

    feature.affiliate file
    case feature.name
    of "VK_VERSION_1_0":
      file.path = featDir/"vk10"
    of "VK_VERSION_1_1":
      file.path = featDir/"vk11"
    of "VK_VERSION_1_2":
      file.path = featDir/"vk12"
    else: discard

  # = VULKAN EXTENSIONS =

  const
    extDir = commandsDir/"extensions"
    envDir = commandsDir/"envdeps"

  let envfile = (
    windows : LibFile(path: envDir/"windows" ),
    linux   : LibFile(path: envDir/"linux"   ),
    directfb: LibFile(path: envDir/"directfb"),
    metal   : LibFile(path: envDir/"metal"   ),
    macos   : LibFile(path: envDir/"macos"   ),
    ios     : LibFile(path: envDir/"ios"     ),
    android : LibFile(path: envDir/"android" ),
  )
  let stdfile = LibFile(path: commandsDir/"extension")
  let specifics = [
    envfile.windows,
    envfile.linux,
    envfile.directfb,
    envfile.metal,
    envfile.macos,
    envfile.ios,
    envfile.android,
    stdfile
    ]
  libfiles.add specifics

  let fileGroup = [
    ("win32", envfile.windows),
    ("wayland", envfile.linux),
    ("xlib", envfile.linux),
    ("xcb", envfile.linux),
    ("directfb", envfile.directfb),
    ("metal", envfile.metal),
    ("macos", envfile.macos),
    ("ios", envfile.ios),
    ("android", envfile.android),
    ("VK_ANDROID", envfile.android),

    ("VK_", stdfile)
  ].toTable

  for extension in xml["extensions"].findAll("extension"):
    let name = extension{"name"}
    if not name.isValidExtension: continue

    var feature = Feature(name: name)

    if (?extension.comment).isSome:
      feature.comment = some extension.comment.underline('=').commentify

    for require in extension.findAll("require"):
      feature.requires.add require.extractNodeRequire

    if feature.requires.len != 0:
      features[name] = feature

    block MAKE_FILE:
      if feature.affiliation.isNil:
        for keyword, file in fileGroup:
          if feature.name.find(keyword) != -1:
            feature.affiliate file
            break MAKE_FILE

      var file = new LibFile
      libfiles.add file

      file.path = extDir/feature.name
      feature.affiliate file

  # = RENDER =

  for libFile in libfiles:
    if libFile.isNil: continue
    let
      res = libFile.renderCommands(features, resources)
      filePath = &"{libRoot/libFile.path}.nim"
      file = filePath.open(fmwrite)
    defer: file.close
    file.write warningText
    file.write "\n"
    file.write $res

when isMainModule:
  genBaseTypes()
  genHandles()
  genEnums()
  genObjects()
  genCommands()