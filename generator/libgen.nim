import xmltree
import strformat
import strutils
import sequtils
import parseutils
import tables
import logging
import options
import os

import ./utils
import ./nodedefs
import ./liblogger
import ./extraction
import ./rendering
import ./libfiles
import ./structuredstring


# let logger = newMyLogger(open("log", fmWrite), fmtStr="[$time] - \x1b[32m$levelname\x1b[0m ")
let logger = newMyLogger(open("log", fmWrite), fmtStr="[$time] - $levelname ".fmt)
addHandler(logger)

const libRoot = "src/vulkan"

let
  xml = getVulkanXML()
  resources = xml.extractResources

const warningText = """
# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.
"""

let components = newTable [
  ("android", @[
    "VK_ANDROID_external_memory_android_hardware_buffer",
    "VK_ANDROID_native_buffer",
    "VK_KHR_android_surface"]),
  ("wayland", @[
    "VK_KHR_wayland_surface"]),
  ("win32", @[
    "VK_KHR_win32_surface"]),
  ("xcb", @[
    "VK_KHR_xcb_surface"]),
  ("xlib", @[
    "VK_KHR_xlib_surface"]),
  ("ios", @[
    "VK_MVK_ios_surface"]),
  ("macos", @[
    "VK_MVK_macos_surface"]),
  ("vi", @[
    "VK_NN_vi_surface"]),
  ("mir", @[
    "VK_KHR_mir_surface"]),
  ("ggp", @[
    "VK_GGP_stream_descriptor_surface"]),
  ("directfb", @[
    "VK_EXT_directfb_surface"]),
  ("metal", @[
    "VK_EXT_metal_surface"]),
  ("fuchsia", @[
    "VK_FUCHSIA_imagepipe_surface"]),
]


proc genBaseTypes*() =
  let file = open("src/vulkan/basetypes.nim", fmWrite)
  defer: close file
  file.write warningText
  file.write "type\n"
  for key, val in resources.basetypes:
    case val.kind
    of nkbExternal: discard
    of nkbNormal:
      file.write "  "
      file.write val.render
      file.write "\n"

  file.write "\n"

  var consts = sstring(kind: skBlock, title: "const")
  consts.add %"# == Constants == #"
  for key, val in resources.consts      : consts.add %val.render()
  consts.add %"# == Aliases == #"
  for key, val in resources.constAliases: consts.add %val.render()
  file.write $consts

proc genHandles* =
  block HandleTypes:
    let file = open("src/vulkan/handles/handleTypes.nim", fmWrite)
    defer: close file
    file.write warningText

    var handleTypes = sstring(kind: skBlock, title: "type HandleTypes* = enum")
    handleTypes.add %"HtNil"
    for key, val in resources.handles:
      let str = val.renderHandleType()
      handleTypes.add str
    file.write $handleTypes

  block Handles:
    let file = open("src/vulkan/handles/handleConcretes.nim", fmWrite)
    defer: close file
    file.write warningText

    file.write """
import handleTypes
import handleOperations

"""

    var handles = sstring(kind: skBlock, title: "type")
    for key, val in resources.handles: handles.add %val.render()

    file.write $handles

proc genEnums*() =
  var rendered: seq[string]

  template openFile(filePath: string) =
    let file {.inject.} = filePath.open(fmWrite)
    defer: close file
    file.write warningText


  proc renderComponent(feature: XmlNode, enumAliases: TableRef[string, NodeEnumAliases], rendered: var seq[string]): Option[sstring] =
    var res = sstring(kind: skBlock)
    for requiresXml in feature.findAll("require"):
      for req in requiresXml.extractNodeRequire.targets:
        if req.name in rendered: continue
        case req.kind

        of nkrType:
          if resources.enums.haskey(req.name):
            res.add render( resources.enums[req.name], resources.vendorTags )
          elif resources.bitmasks.hasKey(req.name):
            res.add render( resources.bitmasks[req.name] )
          if resources.enumAliases.hasKey(req.name):
            enumAliases[req.name] = resources.enumAliases[req.name]
          rendered.add req.name

        of nkrEnumExtendAlias:
          if enumAliases.hasKey(req.extends):
            enumAliases[req.extends].aliases.add NodeEnumAlias(
              name: req.name,
              alias: req.enumAlias,
            )
          else:
            enumAliases[req.extends] = NodeEnumAliases(
              name: req.extends,
              aliases: @[NodeEnumAlias(
                name: req.name,
                alias: req.enumAlias,
              )]
            )

        else: discard

    if res.sons.len > 0:
      res.sons.insert( %feature{"name"}
        .removeVkPrefix
        .replace("_", " ")
        .underline('-')
        .commentify,
        0)
      return some res
    return none sstring

  block:
    openFile( "src/vulkan/enums.nim" )
    file.write """

import utils/enumutilities
import basetypes

"""
    var enumAliases = newTable[string, NodeEnumAliases]()
    var results = sstring(kind: skBlock, title: "type")
    for x in xml.findAll("feature"):
      results.add renderComponent(x, enumAliases, rendered)
    for x in xml.findAll("extensions"):
      results.add renderComponent(x, enumAliases, rendered)
    
    file.write results
    file.write "\n\n\n"

    results = sstring(kind: skBlock)
    for key, val in enumAliases:
      results.add val.render(resources.vendorTags)

    file.write $results


proc isChanged*(newText, oldPath: string): bool =
  let oldText =
    if oldPath.fileExists: oldPath.readFile
    else: return true
  let
    newStart = newText.skipUntil('\n')
    oldStart = oldText.skipUntil('\n')
  newText[newStart..^1] != oldText[oldStart..^1]

proc generate*() =
  var library = new Library
  let fileGroup = [
    ("extensions/VK_KHR_surface", @["extensions/VK_KHR_display", #["extensions/VK_KHR_swapchain"]#]),
    ("extensions/VK_KHR_draw_indirect_count", @["extensions/VK_AMD_draw_indirect_count",]),
    ("extensions/VK_KHR_ray_tracing", @["extensions/VK_NV_ray_tracing",]),
  ].newTable
  # let fileGroup = newTable[string, seq[string]]()

  for feature in xml.findAll("feature"):

    let
      comment = feature{"comment"}
      name = feature{"name"}
    var
      libFile = LibFile(
          requires: @[newSeq[NodeRequire]()],
          fileName: name.parseFileName,
        )

    if (?comment).isSome:
      libFile.fileHeader.add comment.underline('=').commentify

    libFile.fileHeader.add "\nimport ../platform"
    case libFile.filename
    of "features/vk10": discard
    of "features/vk11": libFile.fileHeader.add "\nimport vk10\nexport vk10"
    of "features/vk12": libFile.fileHeader.add "\nimport vk11\nexport vk11"
    else: discard

    for require in feature.findAll("require"):
      libFile.requires[^1].add require.extractNodeRequire

    library[libFile.fileName] = libFile

  let customFeature = [
    ("extensions/VK_ANDROID_external_memory_android_hardware_buffer", "features/vk11"),
    ("extensions/VK_EXT_external_memory_host", "features/vk11"),
    ("extensions/VK_KHR_push_descriptor", "features/vk11"),
    ("extensions/VK_KHR_ray_tracing", "features/vk11"),
    ("extensions/VK_KHR_external_memory_win32", "features/vk11"),
    ("extensions/VK_KHR_external_semaphore_fd", "features/vk11"),
    ("extensions/VK_KHR_external_semaphore_win32", "features/vk11"),
    ("extensions/VK_NV_device_generated_commands", "features/vk11"),
    ("extensions/VK_EXT_buffer_device_address", "features/vk12"),
  ].newTable
  let customExtensions = [
    ("extensions/VK_KHR_ray_tracing", @["extensions/VK_EXT_debug_report"])
  ].newTable
  for extension in xml["extensions"].findAll("extension"):
    let name = extension{"name"}
    block Invalid_Extension_Test:
      let words = name.parseWords({'_'})
      if words.len == 4 and words[2] == "extension":
        try: discard words[3].parseInt; continue
        finally: discard
      if words[1] == "RESERVED": continue
    let requires = extension{"requires"}.parseWords({','}).mapIt((it.parseFileName, it.parseFileName.splitFile.dir == "extensions"))
    let promotedto =
      if (?extension{"promotedto"}).isSome:
        some (extension{"promotedto"}.parseFileName, extension{"promotedto"}.parseFileName.splitFile.dir == "extensions")
      else: none (string, bool)

    var
      libFile = LibFile(
        requires: @[newSeq[NodeRequire]()],
        fileName: name.parseFileName,
      )
    if customFeature.hasKey(libFile.fileName):
      libFile.deps.add (customFeature[libFile.fileName], false)
    else: libFile.deps.add ("features/vk10", false)
    if customExtensions.hasKey(libFile.fileName):
      libFile.deps.add customExtensions[libFile.fileName].mapIt((it, false))
    libFile.deps.add requires
    if promotedto.isSome:
      libFile.deps.add promotedto.get

    if (?extension.comment).isSome:
      libFile.fileHeader.add extension.comment.underline('=').commentify

    libFile.fileHeader.add "\nimport ../platform"

    for require in extension.findAll("require"):
      if (?require{"extension"}).isSome:
        libFile.deps.add (require{"extension"}.parseFileName, true)
      libFile.requires[^1].add require.extractNodeRequire

    if libFile.requires.len != 0:
      library[libFile.fileName] = libFile

  for fileName, mergeMaterials in fileGroup:
    library.merge(fileName, mergeMaterials)

  var updatedFiles: seq[string]
  for fileName, libFile in library:
    if libFile.isNil: continue
    let
      res = libFile.render(library, resources)
      filePath = &"{libRoot/libFile.fileName}.nim"
    if res.isChanged(filePath):
      filePath.writeFile res
      updatedFiles.add filePath

  if updatedFiles.len == 0:
    notice title"Generate Complate! No API files have been updated."
  else:
    notice title"Generate Complate! Following API files have been updated:":
      updatedFiles.join("\n").indent(2)

when isMainModule:
  generate()
  genBaseTypes()
  genHandles()
  genEnums()