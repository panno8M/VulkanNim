# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.

# VK_AMD_buffer_marker
# VK_AMD_device_coherent_memory
# VK_AMD_display_native_hdr
# VK_AMD_draw_indirect_count
# VK_AMD_gcn_shader
# VK_AMD_gpu_shader_half_float
# VK_AMD_gpu_shader_int16
# VK_AMD_memory_overallocation_behavior
# VK_AMD_mixed_attachment_samples
# VK_AMD_negative_viewport_height
# VK_AMD_pipeline_compiler_control
# VK_AMD_rasterization_order
# VK_AMD_shader_ballot
# VK_AMD_shader_core_properties
# VK_AMD_shader_core_properties2
# VK_AMD_shader_explicit_vertex_parameter
# VK_AMD_shader_fragment_mask
# VK_AMD_shader_image_load_store_lod
# VK_AMD_shader_info
# VK_AMD_shader_trinary_minmax
# VK_AMD_texture_gather_bias_lod
# VK_ARM_rasterization_order_attachment_access
# VK_EXT_4444_formats
# VK_EXT_acquire_drm_display
# VK_EXT_astc_decode_mode
# VK_EXT_blend_operation_advanced
# VK_EXT_border_color_swizzle
# VK_EXT_buffer_device_address
# VK_EXT_calibrated_timestamps
# VK_EXT_color_write_enable
# VK_EXT_conditional_rendering
# VK_EXT_conservative_rasterization
# VK_EXT_custom_border_color
# VK_EXT_debug_marker
# VK_EXT_debug_report
# VK_EXT_debug_utils
# VK_EXT_depth_clip_control
# VK_EXT_depth_clip_enable
# VK_EXT_depth_range_unrestricted
# VK_EXT_descriptor_indexing
# VK_EXT_device_memory_report
# VK_EXT_direct_mode_display
# VK_EXT_disable_cube_map_wrap
# VK_EXT_discard_rectangles
# VK_EXT_display_control
# VK_EXT_display_surface_counter
# VK_EXT_extended_dynamic_state
# VK_EXT_extended_dynamic_state2
# VK_EXT_external_memory_dma_buf
# VK_EXT_external_memory_host
# VK_EXT_filter_cubic
# VK_EXT_fragment_density_map
# VK_EXT_fragment_density_map2
# VK_EXT_fragment_shader_interlock
# VK_EXT_full_screen_exclusive
# VK_EXT_global_priority
# VK_EXT_global_priority_query
# VK_EXT_hdr_metadata
# VK_EXT_headless_surface
# VK_EXT_host_query_reset
# VK_EXT_image_drm_format_modifier
# VK_EXT_image_robustness
# VK_EXT_image_view_min_lod
# VK_EXT_index_type_uint8
# VK_EXT_inline_uniform_block
# VK_EXT_line_rasterization
# VK_EXT_load_store_op_none
# VK_EXT_memory_budget
# VK_EXT_memory_priority
# VK_EXT_multi_draw
# VK_EXT_pageable_device_local_memory
# VK_EXT_pci_bus_info
# VK_EXT_physical_device_drm
# VK_EXT_pipeline_creation_cache_control
# VK_EXT_pipeline_creation_feedback
# VK_EXT_post_depth_coverage
# VK_EXT_primitive_topology_list_restart
# VK_EXT_private_data
# VK_EXT_provoking_vertex
# VK_EXT_queue_family_foreign
# VK_EXT_rgba10x6_formats
# VK_EXT_robustness2
# VK_EXT_sample_locations
# VK_EXT_sampler_filter_minmax
# VK_EXT_scalar_block_layout
# VK_EXT_separate_stencil_usage
# VK_EXT_shader_atomic_float
# VK_EXT_shader_atomic_float2
# VK_EXT_shader_demote_to_helper_invocation
# VK_EXT_shader_image_atomic_int64
# VK_EXT_shader_stencil_export
# VK_EXT_shader_subgroup_ballot
# VK_EXT_shader_subgroup_vote
# VK_EXT_shader_viewport_index_layer
# VK_EXT_subgroup_size_control
# VK_EXT_swapchain_colorspace
# VK_EXT_texel_buffer_alignment
# VK_EXT_texture_compression_astc_hdr
# VK_EXT_tooling_info
# VK_EXT_transform_feedback
# VK_EXT_validation_cache
# VK_EXT_validation_features
# VK_EXT_validation_flags
# VK_EXT_vertex_attribute_divisor
# VK_EXT_vertex_input_dynamic_state
# VK_EXT_video_decode_h264
# VK_EXT_video_decode_h265
# VK_EXT_video_encode_h264
# VK_EXT_video_encode_h265
# VK_EXT_ycbcr_2plane_444_formats
# VK_EXT_ycbcr_image_arrays
# VK_FUCHSIA_buffer_collection
# VK_FUCHSIA_external_memory
# VK_FUCHSIA_external_semaphore
# VK_FUCHSIA_imagepipe_surface
# VK_GGP_frame_token
# VK_GGP_stream_descriptor_surface
# VK_GOOGLE_decorate_string
# VK_GOOGLE_display_timing
# VK_GOOGLE_hlsl_functionality1
# VK_GOOGLE_surfaceless_query
# VK_GOOGLE_user_type
# VK_HUAWEI_invocation_mask
# VK_HUAWEI_subpass_shading
# VK_IMG_filter_cubic
# VK_IMG_format_pvrtc
# VK_INTEL_performance_query
# VK_INTEL_shader_integer_functions2
# VK_KHR_16bit_storage
# VK_KHR_8bit_storage
# VK_KHR_acceleration_structure
# VK_KHR_bind_memory2
# VK_KHR_buffer_device_address
# VK_KHR_copy_commands2
# VK_KHR_create_renderpass2
# VK_KHR_dedicated_allocation
# VK_KHR_deferred_host_operations
# VK_KHR_depth_stencil_resolve
# VK_KHR_descriptor_update_template
# VK_KHR_device_group
# VK_KHR_device_group_creation
# VK_KHR_display
# VK_KHR_display_swapchain
# VK_KHR_draw_indirect_count
# VK_KHR_driver_properties
# VK_KHR_dynamic_rendering
# VK_KHR_external_fence
# VK_KHR_external_fence_capabilities
# VK_KHR_external_fence_fd
# VK_KHR_external_fence_win32
# VK_KHR_external_memory
# VK_KHR_external_memory_capabilities
# VK_KHR_external_memory_fd
# VK_KHR_external_memory_win32
# VK_KHR_external_semaphore
# VK_KHR_external_semaphore_capabilities
# VK_KHR_external_semaphore_fd
# VK_KHR_external_semaphore_win32
# VK_KHR_format_feature_flags2
# VK_KHR_fragment_shading_rate
# VK_KHR_get_display_properties2
# VK_KHR_get_memory_requirements2
# VK_KHR_get_physical_device_properties2
# VK_KHR_get_surface_capabilities2
# VK_KHR_image_format_list
# VK_KHR_imageless_framebuffer
# VK_KHR_incremental_present
# VK_KHR_maintenance1
# VK_KHR_maintenance2
# VK_KHR_maintenance3
# VK_KHR_maintenance4
# VK_KHR_mir_surface
# VK_KHR_multiview
# VK_KHR_performance_query
# VK_KHR_pipeline_executable_properties
# VK_KHR_pipeline_library
# VK_KHR_portability_subset
# VK_KHR_present_id
# VK_KHR_present_wait
# VK_KHR_push_descriptor
# VK_KHR_ray_query
# VK_KHR_ray_tracing_pipeline
# VK_KHR_relaxed_block_layout
# VK_KHR_sampler_mirror_clamp_to_edge
# VK_KHR_sampler_ycbcr_conversion
# VK_KHR_separate_depth_stencil_layouts
# VK_KHR_shader_atomic_int64
# VK_KHR_shader_clock
# VK_KHR_shader_draw_parameters
# VK_KHR_shader_float16_int8
# VK_KHR_shader_float_controls
# VK_KHR_shader_integer_dot_product
# VK_KHR_shader_non_semantic_info
# VK_KHR_shader_subgroup_extended_types
# VK_KHR_shader_subgroup_uniform_control_flow
# VK_KHR_shader_terminate_invocation
# VK_KHR_shared_presentable_image
# VK_KHR_spirv_1_4
# VK_KHR_storage_buffer_storage_class
# VK_KHR_surface
# VK_KHR_surface_protected_capabilities
# VK_KHR_swapchain
# VK_KHR_swapchain_mutable_format
# VK_KHR_synchronization2
# VK_KHR_timeline_semaphore
# VK_KHR_uniform_buffer_standard_layout
# VK_KHR_variable_pointers
# VK_KHR_video_decode_queue
# VK_KHR_video_encode_queue
# VK_KHR_video_queue
# VK_KHR_vulkan_memory_model
# VK_KHR_win32_keyed_mutex
# VK_KHR_win32_surface
# VK_KHR_workgroup_memory_explicit_layout
# VK_KHR_zero_initialize_workgroup_memory
# VK_MVK_macos_surface
# VK_MVK_moltenvk
# VK_NN_vi_surface
# VK_NVX_binary_import
# VK_NVX_device_generated_commands
# VK_NVX_image_view_handle
# VK_NVX_multiview_per_view_attributes
# VK_NV_acquire_winrt_display
# VK_NV_clip_space_w_scaling
# VK_NV_compute_shader_derivatives
# VK_NV_cooperative_matrix
# VK_NV_corner_sampled_image
# VK_NV_coverage_reduction_mode
# VK_NV_dedicated_allocation
# VK_NV_dedicated_allocation_image_aliasing
# VK_NV_device_diagnostic_checkpoints
# VK_NV_device_diagnostics_config
# VK_NV_device_generated_commands
# VK_NV_external_memory
# VK_NV_external_memory_capabilities
# VK_NV_external_memory_rdma
# VK_NV_external_memory_win32
# VK_NV_fill_rectangle
# VK_NV_fragment_coverage_to_color
# VK_NV_fragment_shader_barycentric
# VK_NV_fragment_shading_rate_enums
# VK_NV_framebuffer_mixed_samples
# VK_NV_geometry_shader_passthrough
# VK_NV_glsl_shader
# VK_NV_inherited_viewport_scissor
# VK_NV_linear_color_attachment
# VK_NV_mesh_shader
# VK_NV_ray_tracing
# VK_NV_ray_tracing_motion_blur
# VK_NV_representative_fragment_test
# VK_NV_sample_mask_override_coverage
# VK_NV_scissor_exclusive
# VK_NV_shader_image_footprint
# VK_NV_shader_sm_builtins
# VK_NV_shader_subgroup_partitioned
# VK_NV_shading_rate_image
# VK_NV_viewport_array2
# VK_NV_viewport_swizzle
# VK_NV_win32_keyed_mutex
# VK_QCOM_fragment_density_map_offset
# VK_QCOM_render_pass_shader_resolve
# VK_QCOM_render_pass_store_ops
# VK_QCOM_render_pass_transform
# VK_QCOM_rotated_copy_commands
# VK_QNX_screen_surface
# VK_VALVE_mutable_descriptor_type

import tools
const
  # VK_KHR_surface
  KhrSurfaceSpecVersion* = 25
  KhrSurfaceExtensionName* = "VK_KHR_surface"
  # VK_KHR_swapchain
  KhrSwapchainSpecVersion* = 70
  KhrSwapchainExtensionName* = "VK_KHR_swapchain"
  # VK_KHR_display
  KhrDisplaySpecVersion* = 23
  KhrDisplayExtensionName* = "VK_KHR_display"
  # VK_KHR_display_swapchain
  KhrDisplaySwapchainSpecVersion* = 10
  KhrDisplaySwapchainExtensionName* = "VK_KHR_display_swapchain"
  # VK_KHR_mir_surface
  KhrMirSurfaceSpecVersion* = 4
  KhrMirSurfaceExtensionName* = "VK_KHR_mir_surface"
  # VK_KHR_win32_surface
  KhrWin32SurfaceSpecVersion* = 6
  KhrWin32SurfaceExtensionName* = "VK_KHR_win32_surface"
  # VK_EXT_debug_report
  ExtDebugReportSpecVersion* = 10
  ExtDebugReportExtensionName* = "VK_EXT_debug_report"
  # VK_NV_glsl_shader
  NvGlslShaderSpecVersion* = 1
  NvGlslShaderExtensionName* = "VK_NV_glsl_shader"
  # VK_EXT_depth_range_unrestricted
  ExtDepthRangeUnrestrictedSpecVersion* = 1
  ExtDepthRangeUnrestrictedExtensionName* = "VK_EXT_depth_range_unrestricted"
  # VK_KHR_sampler_mirror_clamp_to_edge
  KhrSamplerMirrorClampToEdgeSpecVersion* = 3
  KhrSamplerMirrorClampToEdgeExtensionName* = "VK_KHR_sampler_mirror_clamp_to_edge"
  SamplerAddressModeMirrorClampToEdge* = 4
  # VK_IMG_filter_cubic
  ImgFilterCubicSpecVersion* = 1
  ImgFilterCubicExtensionName* = "VK_IMG_filter_cubic"
  # VK_AMD_rasterization_order
  AmdRasterizationOrderSpecVersion* = 1
  AmdRasterizationOrderExtensionName* = "VK_AMD_rasterization_order"
  # VK_AMD_shader_trinary_minmax
  AmdShaderTrinaryMinmaxSpecVersion* = 1
  AmdShaderTrinaryMinmaxExtensionName* = "VK_AMD_shader_trinary_minmax"
  # VK_AMD_shader_explicit_vertex_parameter
  AmdShaderExplicitVertexParameterSpecVersion* = 1
  AmdShaderExplicitVertexParameterExtensionName* = "VK_AMD_shader_explicit_vertex_parameter"
  # VK_EXT_debug_marker
  ExtDebugMarkerSpecVersion* = 4
  ExtDebugMarkerExtensionName* = "VK_EXT_debug_marker"
  # VK_KHR_video_queue
  KhrVideoQueueSpecVersion* = 2
  KhrVideoQueueExtensionName* = "VK_KHR_video_queue"
  # VK_KHR_video_decode_queue
  KhrVideoDecodeQueueSpecVersion* = 2
  KhrVideoDecodeQueueExtensionName* = "VK_KHR_video_decode_queue"
  # VK_AMD_gcn_shader
  AmdGcnShaderSpecVersion* = 1
  AmdGcnShaderExtensionName* = "VK_AMD_gcn_shader"
  # VK_NV_dedicated_allocation
  NvDedicatedAllocationSpecVersion* = 1
  NvDedicatedAllocationExtensionName* = "VK_NV_dedicated_allocation"
  # VK_EXT_transform_feedback
  ExtTransformFeedbackSpecVersion* = 1
  ExtTransformFeedbackExtensionName* = "VK_EXT_transform_feedback"
  # VK_NVX_binary_import
  NvxBinaryImportSpecVersion* = 1
  NvxBinaryImportExtensionName* = "VK_NVX_binary_import"
  # VK_NVX_image_view_handle
  NvxImageViewHandleSpecVersion* = 2
  NvxImageViewHandleExtensionName* = "VK_NVX_image_view_handle"
  # VK_AMD_draw_indirect_count
  AmdDrawIndirectCountSpecVersion* = 2
  AmdDrawIndirectCountExtensionName* = "VK_AMD_draw_indirect_count"
  # VK_AMD_negative_viewport_height
  AmdNegativeViewportHeightSpecVersion* = 1
  AmdNegativeViewportHeightExtensionName* = "VK_AMD_negative_viewport_height"
  # VK_AMD_gpu_shader_half_float
  AmdGpuShaderHalfFloatSpecVersion* = 2
  AmdGpuShaderHalfFloatExtensionName* = "VK_AMD_gpu_shader_half_float"
  # VK_AMD_shader_ballot
  AmdShaderBallotSpecVersion* = 1
  AmdShaderBallotExtensionName* = "VK_AMD_shader_ballot"
  # VK_EXT_video_encode_h264
  ExtVideoEncodeH264SpecVersion* = 3
  ExtVideoEncodeH264ExtensionName* = "VK_EXT_video_encode_h264"
  # VK_EXT_video_encode_h265
  ExtVideoEncodeH265SpecVersion* = 3
  ExtVideoEncodeH265ExtensionName* = "VK_EXT_video_encode_h265"
  # VK_EXT_video_decode_h264
  ExtVideoDecodeH264SpecVersion* = 3
  ExtVideoDecodeH264ExtensionName* = "VK_EXT_video_decode_h264"
  # VK_AMD_texture_gather_bias_lod
  AmdTextureGatherBiasLodSpecVersion* = 1
  AmdTextureGatherBiasLodExtensionName* = "VK_AMD_texture_gather_bias_lod"
  # VK_AMD_shader_info
  AmdShaderInfoSpecVersion* = 1
  AmdShaderInfoExtensionName* = "VK_AMD_shader_info"
  # VK_KHR_dynamic_rendering
  KhrDynamicRenderingSpecVersion* = 1
  KhrDynamicRenderingExtensionName* = "VK_KHR_dynamic_rendering"
  # VK_AMD_shader_image_load_store_lod
  AmdShaderImageLoadStoreLodSpecVersion* = 1
  AmdShaderImageLoadStoreLodExtensionName* = "VK_AMD_shader_image_load_store_lod"
  # VK_GGP_stream_descriptor_surface
  GgpStreamDescriptorSurfaceSpecVersion* = 1
  GgpStreamDescriptorSurfaceExtensionName* = "VK_GGP_stream_descriptor_surface"
  # VK_NV_corner_sampled_image
  NvCornerSampledImageSpecVersion* = 2
  NvCornerSampledImageExtensionName* = "VK_NV_corner_sampled_image"
  # VK_KHR_multiview
  KhrMultiviewSpecVersion* = 1
  KhrMultiviewExtensionName* = "VK_KHR_multiview"
  # VK_IMG_format_pvrtc
  ImgFormatPvrtcSpecVersion* = 1
  ImgFormatPvrtcExtensionName* = "VK_IMG_format_pvrtc"
  # VK_NV_external_memory_capabilities
  NvExternalMemoryCapabilitiesSpecVersion* = 1
  NvExternalMemoryCapabilitiesExtensionName* = "VK_NV_external_memory_capabilities"
  # VK_NV_external_memory
  NvExternalMemorySpecVersion* = 1
  NvExternalMemoryExtensionName* = "VK_NV_external_memory"
  # VK_NV_external_memory_win32
  NvExternalMemoryWin32SpecVersion* = 1
  NvExternalMemoryWin32ExtensionName* = "VK_NV_external_memory_win32"
  # VK_NV_win32_keyed_mutex
  NvWin32KeyedMutexSpecVersion* = 2
  NvWin32KeyedMutexExtensionName* = "VK_NV_win32_keyed_mutex"
  # VK_KHR_get_physical_device_properties2
  KhrGetPhysicalDeviceProperties2SpecVersion* = 2
  KhrGetPhysicalDeviceProperties2ExtensionName* = "VK_KHR_get_physical_device_properties2"
  # VK_KHR_device_group
  KhrDeviceGroupSpecVersion* = 4
  KhrDeviceGroupExtensionName* = "VK_KHR_device_group"
  # VK_EXT_validation_flags
  ExtValidationFlagsSpecVersion* = 2
  ExtValidationFlagsExtensionName* = "VK_EXT_validation_flags"
  # VK_NN_vi_surface
  NnViSurfaceSpecVersion* = 1
  NnViSurfaceExtensionName* = "VK_NN_vi_surface"
  # VK_KHR_shader_draw_parameters
  KhrShaderDrawParametersSpecVersion* = 1
  KhrShaderDrawParametersExtensionName* = "VK_KHR_shader_draw_parameters"
  # VK_EXT_shader_subgroup_ballot
  ExtShaderSubgroupBallotSpecVersion* = 1
  ExtShaderSubgroupBallotExtensionName* = "VK_EXT_shader_subgroup_ballot"
  # VK_EXT_shader_subgroup_vote
  ExtShaderSubgroupVoteSpecVersion* = 1
  ExtShaderSubgroupVoteExtensionName* = "VK_EXT_shader_subgroup_vote"
  # VK_EXT_texture_compression_astc_hdr
  ExtTextureCompressionAstcHdrSpecVersion* = 1
  ExtTextureCompressionAstcHdrExtensionName* = "VK_EXT_texture_compression_astc_hdr"
  # VK_EXT_astc_decode_mode
  ExtAstcDecodeModeSpecVersion* = 1
  ExtAstcDecodeModeExtensionName* = "VK_EXT_astc_decode_mode"
  # VK_KHR_maintenance1
  KhrMaintenance1SpecVersion* = 2
  KhrMaintenance1ExtensionName* = "VK_KHR_maintenance1"
  # VK_KHR_device_group_creation
  KhrDeviceGroupCreationSpecVersion* = 1
  KhrDeviceGroupCreationExtensionName* = "VK_KHR_device_group_creation"
  # VK_KHR_external_memory_capabilities
  KhrExternalMemoryCapabilitiesSpecVersion* = 1
  KhrExternalMemoryCapabilitiesExtensionName* = "VK_KHR_external_memory_capabilities"
  # VK_KHR_external_memory
  KhrExternalMemorySpecVersion* = 1
  KhrExternalMemoryExtensionName* = "VK_KHR_external_memory"
  # VK_KHR_external_memory_win32
  KhrExternalMemoryWin32SpecVersion* = 1
  KhrExternalMemoryWin32ExtensionName* = "VK_KHR_external_memory_win32"
  # VK_KHR_external_memory_fd
  KhrExternalMemoryFdSpecVersion* = 1
  KhrExternalMemoryFdExtensionName* = "VK_KHR_external_memory_fd"
  # VK_KHR_win32_keyed_mutex
  KhrWin32KeyedMutexSpecVersion* = 1
  KhrWin32KeyedMutexExtensionName* = "VK_KHR_win32_keyed_mutex"
  # VK_KHR_external_semaphore_capabilities
  KhrExternalSemaphoreCapabilitiesSpecVersion* = 1
  KhrExternalSemaphoreCapabilitiesExtensionName* = "VK_KHR_external_semaphore_capabilities"
  # VK_KHR_external_semaphore
  KhrExternalSemaphoreSpecVersion* = 1
  KhrExternalSemaphoreExtensionName* = "VK_KHR_external_semaphore"
  # VK_KHR_external_semaphore_win32
  KhrExternalSemaphoreWin32SpecVersion* = 1
  KhrExternalSemaphoreWin32ExtensionName* = "VK_KHR_external_semaphore_win32"
  # VK_KHR_external_semaphore_fd
  KhrExternalSemaphoreFdSpecVersion* = 1
  KhrExternalSemaphoreFdExtensionName* = "VK_KHR_external_semaphore_fd"
  # VK_KHR_push_descriptor
  KhrPushDescriptorSpecVersion* = 2
  KhrPushDescriptorExtensionName* = "VK_KHR_push_descriptor"
  DescriptorUpdateTemplateTypePushDescriptorsKhr* = 1
  # VK_EXT_conditional_rendering
  ExtConditionalRenderingSpecVersion* = 2
  ExtConditionalRenderingExtensionName* = "VK_EXT_conditional_rendering"
  # VK_KHR_shader_float16_int8
  KhrShaderFloat16Int8SpecVersion* = 1
  KhrShaderFloat16Int8ExtensionName* = "VK_KHR_shader_float16_int8"
  # VK_KHR_16bit_storage
  Khr16bitStorageSpecVersion* = 1
  Khr16bitStorageExtensionName* = "VK_KHR_16bit_storage"
  # VK_KHR_incremental_present
  KhrIncrementalPresentSpecVersion* = 2
  KhrIncrementalPresentExtensionName* = "VK_KHR_incremental_present"
  # VK_KHR_descriptor_update_template
  KhrDescriptorUpdateTemplateSpecVersion* = 1
  KhrDescriptorUpdateTemplateExtensionName* = "VK_KHR_descriptor_update_template"
  # VK_NVX_device_generated_commands
  NvxDeviceGeneratedCommandsSpecVersion* = 3
  NvxDeviceGeneratedCommandsExtensionName* = "VK_NVX_device_generated_commands"
  # VK_NV_clip_space_w_scaling
  NvClipSpaceWScalingSpecVersion* = 1
  NvClipSpaceWScalingExtensionName* = "VK_NV_clip_space_w_scaling"
  # VK_EXT_direct_mode_display
  ExtDirectModeDisplaySpecVersion* = 1
  ExtDirectModeDisplayExtensionName* = "VK_EXT_direct_mode_display"
  # VK_EXT_display_surface_counter
  ExtDisplaySurfaceCounterSpecVersion* = 1
  ExtDisplaySurfaceCounterExtensionName* = "VK_EXT_display_surface_counter"
  # VK_EXT_display_control
  ExtDisplayControlSpecVersion* = 1
  ExtDisplayControlExtensionName* = "VK_EXT_display_control"
  # VK_GOOGLE_display_timing
  GoogleDisplayTimingSpecVersion* = 1
  GoogleDisplayTimingExtensionName* = "VK_GOOGLE_display_timing"
  # VK_NV_sample_mask_override_coverage
  NvSampleMaskOverrideCoverageSpecVersion* = 1
  NvSampleMaskOverrideCoverageExtensionName* = "VK_NV_sample_mask_override_coverage"
  # VK_NV_geometry_shader_passthrough
  NvGeometryShaderPassthroughSpecVersion* = 1
  NvGeometryShaderPassthroughExtensionName* = "VK_NV_geometry_shader_passthrough"
  # VK_NV_viewport_array2
  NvViewportArray2SpecVersion* = 1
  NvViewportArray2ExtensionName* = "VK_NV_viewport_array2"
  # VK_NVX_multiview_per_view_attributes
  NvxMultiviewPerViewAttributesSpecVersion* = 1
  NvxMultiviewPerViewAttributesExtensionName* = "VK_NVX_multiview_per_view_attributes"
  # VK_NV_viewport_swizzle
  NvViewportSwizzleSpecVersion* = 1
  NvViewportSwizzleExtensionName* = "VK_NV_viewport_swizzle"
  # VK_EXT_discard_rectangles
  ExtDiscardRectanglesSpecVersion* = 1
  ExtDiscardRectanglesExtensionName* = "VK_EXT_discard_rectangles"
  # VK_EXT_conservative_rasterization
  ExtConservativeRasterizationSpecVersion* = 1
  ExtConservativeRasterizationExtensionName* = "VK_EXT_conservative_rasterization"
  # VK_EXT_depth_clip_enable
  ExtDepthClipEnableSpecVersion* = 1
  ExtDepthClipEnableExtensionName* = "VK_EXT_depth_clip_enable"
  # VK_EXT_swapchain_colorspace
  ExtSwapchainColorSpaceSpecVersion* = 4
  ExtSwapchainColorSpaceExtensionName* = "VK_EXT_swapchain_colorspace"
  # VK_EXT_hdr_metadata
  ExtHdrMetadataSpecVersion* = 2
  ExtHdrMetadataExtensionName* = "VK_EXT_hdr_metadata"
  # VK_KHR_imageless_framebuffer
  KhrImagelessFramebufferSpecVersion* = 1
  KhrImagelessFramebufferExtensionName* = "VK_KHR_imageless_framebuffer"
  # VK_KHR_create_renderpass2
  KhrCreateRenderpass2SpecVersion* = 1
  KhrCreateRenderpass2ExtensionName* = "VK_KHR_create_renderpass2"
  # VK_KHR_shared_presentable_image
  KhrSharedPresentableImageSpecVersion* = 1
  KhrSharedPresentableImageExtensionName* = "VK_KHR_shared_presentable_image"
  # VK_KHR_external_fence_capabilities
  KhrExternalFenceCapabilitiesSpecVersion* = 1
  KhrExternalFenceCapabilitiesExtensionName* = "VK_KHR_external_fence_capabilities"
  # VK_KHR_external_fence
  KhrExternalFenceSpecVersion* = 1
  KhrExternalFenceExtensionName* = "VK_KHR_external_fence"
  # VK_KHR_external_fence_win32
  KhrExternalFenceWin32SpecVersion* = 1
  KhrExternalFenceWin32ExtensionName* = "VK_KHR_external_fence_win32"
  # VK_KHR_external_fence_fd
  KhrExternalFenceFdSpecVersion* = 1
  KhrExternalFenceFdExtensionName* = "VK_KHR_external_fence_fd"
  # VK_KHR_performance_query
  KhrPerformanceQuerySpecVersion* = 1
  KhrPerformanceQueryExtensionName* = "VK_KHR_performance_query"
  # VK_KHR_maintenance2
  KhrMaintenance2SpecVersion* = 1
  KhrMaintenance2ExtensionName* = "VK_KHR_maintenance2"
  # VK_KHR_get_surface_capabilities2
  KhrGetSurfaceCapabilities2SpecVersion* = 1
  KhrGetSurfaceCapabilities2ExtensionName* = "VK_KHR_get_surface_capabilities2"
  # VK_KHR_variable_pointers
  KhrVariablePointersSpecVersion* = 1
  KhrVariablePointersExtensionName* = "VK_KHR_variable_pointers"
  # VK_KHR_get_display_properties2
  KhrGetDisplayProperties2SpecVersion* = 1
  KhrGetDisplayProperties2ExtensionName* = "VK_KHR_get_display_properties2"
  # VK_MVK_macos_surface
  MmacosSurfaceSpecVersion* = 3
  MmacosSurfaceExtensionName* = "VK_MVK_macos_surface"
  # VK_MVK_moltenvk
  MmoltenspecVersion* = 0
  MmoltenextensionName* = "VK_MVK_moltenvk"
  # VK_EXT_external_memory_dma_buf
  ExtExternalMemoryDmaBufSpecVersion* = 1
  ExtExternalMemoryDmaBufExtensionName* = "VK_EXT_external_memory_dma_buf"
  # VK_EXT_queue_family_foreign
  ExtQueueFamilyForeignSpecVersion* = 1
  ExtQueueFamilyForeignExtensionName* = "VK_EXT_queue_family_foreign"
  # VK_KHR_dedicated_allocation
  KhrDedicatedAllocationSpecVersion* = 3
  KhrDedicatedAllocationExtensionName* = "VK_KHR_dedicated_allocation"
  # VK_EXT_debug_utils
  ExtDebugUtilsSpecVersion* = 2
  ExtDebugUtilsExtensionName* = "VK_EXT_debug_utils"
  # VK_EXT_sampler_filter_minmax
  ExtSamplerFilterMinmaxSpecVersion* = 2
  ExtSamplerFilterMinmaxExtensionName* = "VK_EXT_sampler_filter_minmax"
  # VK_KHR_storage_buffer_storage_class
  KhrStorageBufferStorageClassSpecVersion* = 1
  KhrStorageBufferStorageClassExtensionName* = "VK_KHR_storage_buffer_storage_class"
  # VK_AMD_gpu_shader_int16
  AmdGpuShaderInt16SpecVersion* = 2
  AmdGpuShaderInt16ExtensionName* = "VK_AMD_gpu_shader_int16"
  # VK_AMD_mixed_attachment_samples
  AmdMixedAttachmentSamplesSpecVersion* = 1
  AmdMixedAttachmentSamplesExtensionName* = "VK_AMD_mixed_attachment_samples"
  # VK_AMD_shader_fragment_mask
  AmdShaderFragmentMaskSpecVersion* = 1
  AmdShaderFragmentMaskExtensionName* = "VK_AMD_shader_fragment_mask"
  # VK_EXT_inline_uniform_block
  ExtInlineUniformBlockSpecVersion* = 1
  ExtInlineUniformBlockExtensionName* = "VK_EXT_inline_uniform_block"
  # VK_EXT_shader_stencil_export
  ExtShaderStencilExportSpecVersion* = 1
  ExtShaderStencilExportExtensionName* = "VK_EXT_shader_stencil_export"
  # VK_EXT_sample_locations
  ExtSampleLocationsSpecVersion* = 1
  ExtSampleLocationsExtensionName* = "VK_EXT_sample_locations"
  # VK_KHR_relaxed_block_layout
  KhrRelaxedBlockLayoutSpecVersion* = 1
  KhrRelaxedBlockLayoutExtensionName* = "VK_KHR_relaxed_block_layout"
  # VK_KHR_get_memory_requirements2
  KhrGetMemoryRequirements2SpecVersion* = 1
  KhrGetMemoryRequirements2ExtensionName* = "VK_KHR_get_memory_requirements2"
  # VK_KHR_image_format_list
  KhrImageFormatListSpecVersion* = 1
  KhrImageFormatListExtensionName* = "VK_KHR_image_format_list"
  # VK_EXT_blend_operation_advanced
  ExtBlendOperationAdvancedSpecVersion* = 2
  ExtBlendOperationAdvancedExtensionName* = "VK_EXT_blend_operation_advanced"
  # VK_NV_fragment_coverage_to_color
  NvFragmentCoverageToColorSpecVersion* = 1
  NvFragmentCoverageToColorExtensionName* = "VK_NV_fragment_coverage_to_color"
  # VK_KHR_acceleration_structure
  KhrAccelerationStructureSpecVersion* = 13
  KhrAccelerationStructureExtensionName* = "VK_KHR_acceleration_structure"
  # VK_KHR_ray_tracing_pipeline
  KhrRayTracingPipelineSpecVersion* = 1
  KhrRayTracingPipelineExtensionName* = "VK_KHR_ray_tracing_pipeline"
  # VK_KHR_ray_query
  KhrRayQuerySpecVersion* = 1
  KhrRayQueryExtensionName* = "VK_KHR_ray_query"
  # VK_NV_framebuffer_mixed_samples
  NvFramebufferMixedSamplesSpecVersion* = 1
  NvFramebufferMixedSamplesExtensionName* = "VK_NV_framebuffer_mixed_samples"
  # VK_NV_fill_rectangle
  NvFillRectangleSpecVersion* = 1
  NvFillRectangleExtensionName* = "VK_NV_fill_rectangle"
  # VK_NV_shader_sm_builtins
  NvShaderSmBuiltinsSpecVersion* = 1
  NvShaderSmBuiltinsExtensionName* = "VK_NV_shader_sm_builtins"
  # VK_EXT_post_depth_coverage
  ExtPostDepthCoverageSpecVersion* = 1
  ExtPostDepthCoverageExtensionName* = "VK_EXT_post_depth_coverage"
  # VK_KHR_sampler_ycbcr_conversion
  KhrSamplerYcbcrConversionSpecVersion* = 14
  KhrSamplerYcbcrConversionExtensionName* = "VK_KHR_sampler_ycbcr_conversion"
  # VK_KHR_bind_memory2
  KhrBindMemory2SpecVersion* = 1
  KhrBindMemory2ExtensionName* = "VK_KHR_bind_memory2"
  # VK_EXT_image_drm_format_modifier
  ExtImageDrmFormatModifierSpecVersion* = 2
  ExtImageDrmFormatModifierExtensionName* = "VK_EXT_image_drm_format_modifier"
  # VK_EXT_validation_cache
  ExtValidationCacheSpecVersion* = 1
  ExtValidationCacheExtensionName* = "VK_EXT_validation_cache"
  # VK_EXT_descriptor_indexing
  ExtDescriptorIndexingSpecVersion* = 2
  ExtDescriptorIndexingExtensionName* = "VK_EXT_descriptor_indexing"
  # VK_EXT_shader_viewport_index_layer
  ExtShaderViewportIndexLayerSpecVersion* = 1
  ExtShaderViewportIndexLayerExtensionName* = "VK_EXT_shader_viewport_index_layer"
  # VK_KHR_portability_subset
  KhrPortabilitySubsetSpecVersion* = 1
  KhrPortabilitySubsetExtensionName* = "VK_KHR_portability_subset"
  # VK_NV_shading_rate_image
  NvShadingRateImageSpecVersion* = 3
  NvShadingRateImageExtensionName* = "VK_NV_shading_rate_image"
  # VK_NV_ray_tracing
  NvRayTracingSpecVersion* = 3
  NvRayTracingExtensionName* = "VK_NV_ray_tracing"
  # VK_NV_representative_fragment_test
  NvRepresentativeFragmentTestSpecVersion* = 2
  NvRepresentativeFragmentTestExtensionName* = "VK_NV_representative_fragment_test"
  # VK_KHR_maintenance3
  KhrMaintenance3SpecVersion* = 1
  KhrMaintenance3ExtensionName* = "VK_KHR_maintenance3"
  # VK_KHR_draw_indirect_count
  KhrDrawIndirectCountSpecVersion* = 1
  KhrDrawIndirectCountExtensionName* = "VK_KHR_draw_indirect_count"
  # VK_EXT_filter_cubic
  ExtFilterCubicSpecVersion* = 3
  ExtFilterCubicExtensionName* = "VK_EXT_filter_cubic"
  # VK_QCOM_render_pass_shader_resolve
  QcomRenderPassShaderResolveSpecVersion* = 4
  QcomRenderPassShaderResolveExtensionName* = "VK_QCOM_render_pass_shader_resolve"
  # VK_EXT_global_priority
  ExtGlobalPrioritySpecVersion* = 2
  ExtGlobalPriorityExtensionName* = "VK_EXT_global_priority"
  # VK_KHR_shader_subgroup_extended_types
  KhrShaderSubgroupExtendedTypesSpecVersion* = 1
  KhrShaderSubgroupExtendedTypesExtensionName* = "VK_KHR_shader_subgroup_extended_types"
  # VK_KHR_8bit_storage
  Khr8bitStorageSpecVersion* = 1
  Khr8bitStorageExtensionName* = "VK_KHR_8bit_storage"
  # VK_EXT_external_memory_host
  ExtExternalMemoryHostSpecVersion* = 1
  ExtExternalMemoryHostExtensionName* = "VK_EXT_external_memory_host"
  # VK_AMD_buffer_marker
  AmdBufferMarkerSpecVersion* = 1
  AmdBufferMarkerExtensionName* = "VK_AMD_buffer_marker"
  # VK_KHR_shader_atomic_int64
  KhrShaderAtomicInt64SpecVersion* = 1
  KhrShaderAtomicInt64ExtensionName* = "VK_KHR_shader_atomic_int64"
  # VK_KHR_shader_clock
  KhrShaderClockSpecVersion* = 1
  KhrShaderClockExtensionName* = "VK_KHR_shader_clock"
  # VK_AMD_pipeline_compiler_control
  AmdPipelineCompilerControlSpecVersion* = 1
  AmdPipelineCompilerControlExtensionName* = "VK_AMD_pipeline_compiler_control"
  # VK_EXT_calibrated_timestamps
  ExtCalibratedTimestampsSpecVersion* = 2
  ExtCalibratedTimestampsExtensionName* = "VK_EXT_calibrated_timestamps"
  # VK_AMD_shader_core_properties
  AmdShaderCorePropertiesSpecVersion* = 2
  AmdShaderCorePropertiesExtensionName* = "VK_AMD_shader_core_properties"
  # VK_EXT_video_decode_h265
  ExtVideoDecodeH265SpecVersion* = 1
  ExtVideoDecodeH265ExtensionName* = "VK_EXT_video_decode_h265"
  # VK_AMD_memory_overallocation_behavior
  AmdMemoryOverallocationBehaviorSpecVersion* = 1
  AmdMemoryOverallocationBehaviorExtensionName* = "VK_AMD_memory_overallocation_behavior"
  # VK_EXT_vertex_attribute_divisor
  ExtVertexAttributeDivisorSpecVersion* = 3
  ExtVertexAttributeDivisorExtensionName* = "VK_EXT_vertex_attribute_divisor"
  # VK_GGP_frame_token
  GgpFrameTokenSpecVersion* = 1
  GgpFrameTokenExtensionName* = "VK_GGP_frame_token"
  # VK_EXT_pipeline_creation_feedback
  ExtPipelineCreationFeedbackSpecVersion* = 1
  ExtPipelineCreationFeedbackExtensionName* = "VK_EXT_pipeline_creation_feedback"
  # VK_KHR_driver_properties
  KhrDriverPropertiesSpecVersion* = 1
  KhrDriverPropertiesExtensionName* = "VK_KHR_driver_properties"
  # VK_KHR_shader_float_controls
  KhrShaderFloatControlsSpecVersion* = 4
  KhrShaderFloatControlsExtensionName* = "VK_KHR_shader_float_controls"
  # VK_NV_shader_subgroup_partitioned
  NvShaderSubgroupPartitionedSpecVersion* = 1
  NvShaderSubgroupPartitionedExtensionName* = "VK_NV_shader_subgroup_partitioned"
  # VK_KHR_depth_stencil_resolve
  KhrDepthStencilResolveSpecVersion* = 1
  KhrDepthStencilResolveExtensionName* = "VK_KHR_depth_stencil_resolve"
  # VK_KHR_swapchain_mutable_format
  KhrSwapchainMutableFormatSpecVersion* = 1
  KhrSwapchainMutableFormatExtensionName* = "VK_KHR_swapchain_mutable_format"
  # VK_NV_compute_shader_derivatives
  NvComputeShaderDerivativesSpecVersion* = 1
  NvComputeShaderDerivativesExtensionName* = "VK_NV_compute_shader_derivatives"
  # VK_NV_mesh_shader
  NvMeshShaderSpecVersion* = 1
  NvMeshShaderExtensionName* = "VK_NV_mesh_shader"
  # VK_NV_fragment_shader_barycentric
  NvFragmentShaderBarycentricSpecVersion* = 1
  NvFragmentShaderBarycentricExtensionName* = "VK_NV_fragment_shader_barycentric"
  # VK_NV_shader_image_footprint
  NvShaderImageFootprintSpecVersion* = 2
  NvShaderImageFootprintExtensionName* = "VK_NV_shader_image_footprint"
  # VK_NV_scissor_exclusive
  NvScissorExclusiveSpecVersion* = 1
  NvScissorExclusiveExtensionName* = "VK_NV_scissor_exclusive"
  # VK_NV_device_diagnostic_checkpoints
  NvDeviceDiagnosticCheckpointsSpecVersion* = 2
  NvDeviceDiagnosticCheckpointsExtensionName* = "VK_NV_device_diagnostic_checkpoints"
  # VK_KHR_timeline_semaphore
  KhrTimelineSemaphoreSpecVersion* = 2
  KhrTimelineSemaphoreExtensionName* = "VK_KHR_timeline_semaphore"
  # VK_INTEL_shader_integer_functions2
  IntelShaderIntegerFunctions2SpecVersion* = 1
  IntelShaderIntegerFunctions2ExtensionName* = "VK_INTEL_shader_integer_functions2"
  # VK_INTEL_performance_query
  IntelPerformanceQuerySpecVersion* = 2
  IntelPerformanceQueryExtensionName* = "VK_INTEL_performance_query"
  # VK_KHR_vulkan_memory_model
  KhrVulkanMemoryModelSpecVersion* = 3
  KhrVulkanMemoryModelExtensionName* = "VK_KHR_vulkan_memory_model"
  # VK_EXT_pci_bus_info
  ExtPciBusInfoSpecVersion* = 2
  ExtPciBusInfoExtensionName* = "VK_EXT_pci_bus_info"
  # VK_AMD_display_native_hdr
  AmdDisplayNativeHdrSpecVersion* = 1
  AmdDisplayNativeHdrExtensionName* = "VK_AMD_display_native_hdr"
  # VK_FUCHSIA_imagepipe_surface
  FuchsiaImagepipeSurfaceSpecVersion* = 1
  FuchsiaImagepipeSurfaceExtensionName* = "VK_FUCHSIA_imagepipe_surface"
  # VK_KHR_shader_terminate_invocation
  KhrShaderTerminateInvocationSpecVersion* = 1
  KhrShaderTerminateInvocationExtensionName* = "VK_KHR_shader_terminate_invocation"
  # VK_EXT_fragment_density_map
  ExtFragmentDensityMapSpecVersion* = 2
  ExtFragmentDensityMapExtensionName* = "VK_EXT_fragment_density_map"
  # VK_EXT_scalar_block_layout
  ExtScalarBlockLayoutSpecVersion* = 1
  ExtScalarBlockLayoutExtensionName* = "VK_EXT_scalar_block_layout"
  # VK_GOOGLE_hlsl_functionality1
  GoogleHlslFunctionality1SpecVersion* = 1
  GoogleHlslFunctionality1ExtensionName* = "VK_GOOGLE_hlsl_functionality1"
  # VK_GOOGLE_decorate_string
  GoogleDecorateStringSpecVersion* = 1
  GoogleDecorateStringExtensionName* = "VK_GOOGLE_decorate_string"
  # VK_EXT_subgroup_size_control
  ExtSubgroupSizeControlSpecVersion* = 2
  ExtSubgroupSizeControlExtensionName* = "VK_EXT_subgroup_size_control"
  # VK_KHR_fragment_shading_rate
  KhrFragmentShadingRateSpecVersion* = 2
  KhrFragmentShadingRateExtensionName* = "VK_KHR_fragment_shading_rate"
  # VK_AMD_shader_core_properties2
  AmdShaderCoreProperties2SpecVersion* = 1
  AmdShaderCoreProperties2ExtensionName* = "VK_AMD_shader_core_properties2"
  # VK_AMD_device_coherent_memory
  AmdDeviceCoherentMemorySpecVersion* = 1
  AmdDeviceCoherentMemoryExtensionName* = "VK_AMD_device_coherent_memory"
  # VK_EXT_shader_image_atomic_int64
  ExtShaderImageAtomicInt64SpecVersion* = 1
  ExtShaderImageAtomicInt64ExtensionName* = "VK_EXT_shader_image_atomic_int64"
  # VK_KHR_spirv_1_4
  KhrSpirv14SpecVersion* = 1
  KhrSpirv14ExtensionName* = "VK_KHR_spirv_1_4"
  # VK_EXT_memory_budget
  ExtMemoryBudgetSpecVersion* = 1
  ExtMemoryBudgetExtensionName* = "VK_EXT_memory_budget"
  # VK_EXT_memory_priority
  ExtMemoryPrioritySpecVersion* = 1
  ExtMemoryPriorityExtensionName* = "VK_EXT_memory_priority"
  # VK_KHR_surface_protected_capabilities
  KhrSurfaceProtectedCapabilitiesSpecVersion* = 1
  KhrSurfaceProtectedCapabilitiesExtensionName* = "VK_KHR_surface_protected_capabilities"
  # VK_NV_dedicated_allocation_image_aliasing
  NvDedicatedAllocationImageAliasingSpecVersion* = 1
  NvDedicatedAllocationImageAliasingExtensionName* = "VK_NV_dedicated_allocation_image_aliasing"
  # VK_KHR_separate_depth_stencil_layouts
  KhrSeparateDepthStencilLayoutsSpecVersion* = 1
  KhrSeparateDepthStencilLayoutsExtensionName* = "VK_KHR_separate_depth_stencil_layouts"
  # VK_EXT_buffer_device_address
  ExtBufferDeviceAddressSpecVersion* = 2
  ExtBufferDeviceAddressExtensionName* = "VK_EXT_buffer_device_address"
  # VK_EXT_tooling_info
  ExtToolingInfoSpecVersion* = 1
  ExtToolingInfoExtensionName* = "VK_EXT_tooling_info"
  # VK_EXT_separate_stencil_usage
  ExtSeparateStencilUsageSpecVersion* = 1
  ExtSeparateStencilUsageExtensionName* = "VK_EXT_separate_stencil_usage"
  # VK_EXT_validation_features
  ExtValidationFeaturesSpecVersion* = 5
  ExtValidationFeaturesExtensionName* = "VK_EXT_validation_features"
  # VK_KHR_present_wait
  KhrPresentWaitSpecVersion* = 1
  KhrPresentWaitExtensionName* = "VK_KHR_present_wait"
  # VK_NV_cooperative_matrix
  NvCooperativeMatrixSpecVersion* = 1
  NvCooperativeMatrixExtensionName* = "VK_NV_cooperative_matrix"
  # VK_NV_coverage_reduction_mode
  NvCoverageReductionModeSpecVersion* = 1
  NvCoverageReductionModeExtensionName* = "VK_NV_coverage_reduction_mode"
  # VK_EXT_fragment_shader_interlock
  ExtFragmentShaderInterlockSpecVersion* = 1
  ExtFragmentShaderInterlockExtensionName* = "VK_EXT_fragment_shader_interlock"
  # VK_EXT_ycbcr_image_arrays
  ExtYcbcrImageArraysSpecVersion* = 1
  ExtYcbcrImageArraysExtensionName* = "VK_EXT_ycbcr_image_arrays"
  # VK_KHR_uniform_buffer_standard_layout
  KhrUniformBufferStandardLayoutSpecVersion* = 1
  KhrUniformBufferStandardLayoutExtensionName* = "VK_KHR_uniform_buffer_standard_layout"
  # VK_EXT_provoking_vertex
  ExtProvokingVertexSpecVersion* = 1
  ExtProvokingVertexExtensionName* = "VK_EXT_provoking_vertex"
  # VK_EXT_full_screen_exclusive
  ExtFullScreenExclusiveSpecVersion* = 4
  ExtFullScreenExclusiveExtensionName* = "VK_EXT_full_screen_exclusive"
  # VK_EXT_headless_surface
  ExtHeadlessSurfaceSpecVersion* = 1
  ExtHeadlessSurfaceExtensionName* = "VK_EXT_headless_surface"
  # VK_KHR_buffer_device_address
  KhrBufferDeviceAddressSpecVersion* = 1
  KhrBufferDeviceAddressExtensionName* = "VK_KHR_buffer_device_address"
  # VK_EXT_line_rasterization
  ExtLineRasterizationSpecVersion* = 1
  ExtLineRasterizationExtensionName* = "VK_EXT_line_rasterization"
  # VK_EXT_shader_atomic_float
  ExtShaderAtomicFloatSpecVersion* = 1
  ExtShaderAtomicFloatExtensionName* = "VK_EXT_shader_atomic_float"
  # VK_EXT_host_query_reset
  ExtHostQueryResetSpecVersion* = 1
  ExtHostQueryResetExtensionName* = "VK_EXT_host_query_reset"
  # VK_EXT_index_type_uint8
  ExtIndexTypeUint8SpecVersion* = 1
  ExtIndexTypeUint8ExtensionName* = "VK_EXT_index_type_uint8"
  # VK_EXT_extended_dynamic_state
  ExtExtendedDynamicStateSpecVersion* = 1
  ExtExtendedDynamicStateExtensionName* = "VK_EXT_extended_dynamic_state"
  # VK_KHR_deferred_host_operations
  KhrDeferredHostOperationsSpecVersion* = 4
  KhrDeferredHostOperationsExtensionName* = "VK_KHR_deferred_host_operations"
  # VK_KHR_pipeline_executable_properties
  KhrPipelineExecutablePropertiesSpecVersion* = 1
  KhrPipelineExecutablePropertiesExtensionName* = "VK_KHR_pipeline_executable_properties"
  # VK_EXT_shader_atomic_float2
  ExtShaderAtomicFloat2SpecVersion* = 1
  ExtShaderAtomicFloat2ExtensionName* = "VK_EXT_shader_atomic_float2"
  # VK_EXT_shader_demote_to_helper_invocation
  ExtShaderDemoteToHelperInvocationSpecVersion* = 1
  ExtShaderDemoteToHelperInvocationExtensionName* = "VK_EXT_shader_demote_to_helper_invocation"
  # VK_NV_device_generated_commands
  NvDeviceGeneratedCommandsSpecVersion* = 3
  NvDeviceGeneratedCommandsExtensionName* = "VK_NV_device_generated_commands"
  # VK_NV_inherited_viewport_scissor
  NvInheritedViewportScissorSpecVersion* = 1
  NvInheritedViewportScissorExtensionName* = "VK_NV_inherited_viewport_scissor"
  # VK_KHR_shader_integer_dot_product
  KhrShaderIntegerDotProductSpecVersion* = 1
  KhrShaderIntegerDotProductExtensionName* = "VK_KHR_shader_integer_dot_product"
  # VK_EXT_texel_buffer_alignment
  ExtTexelBufferAlignmentSpecVersion* = 1
  ExtTexelBufferAlignmentExtensionName* = "VK_EXT_texel_buffer_alignment"
  # VK_QCOM_render_pass_transform
  QcomRenderPassTransformSpecVersion* = 2
  QcomRenderPassTransformExtensionName* = "VK_QCOM_render_pass_transform"
  # VK_EXT_device_memory_report
  ExtDeviceMemoryReportSpecVersion* = 2
  ExtDeviceMemoryReportExtensionName* = "VK_EXT_device_memory_report"
  # VK_EXT_acquire_drm_display
  ExtAcquireDrmDisplaySpecVersion* = 1
  ExtAcquireDrmDisplayExtensionName* = "VK_EXT_acquire_drm_display"
  # VK_EXT_robustness2
  ExtRobustness2SpecVersion* = 1
  ExtRobustness2ExtensionName* = "VK_EXT_robustness2"
  # VK_EXT_custom_border_color
  ExtCustomBorderColorSpecVersion* = 12
  ExtCustomBorderColorExtensionName* = "VK_EXT_custom_border_color"
  # VK_GOOGLE_user_type
  GoogleUserTypeSpecVersion* = 1
  GoogleUserTypeExtensionName* = "VK_GOOGLE_user_type"
  # VK_KHR_pipeline_library
  KhrPipelineLibrarySpecVersion* = 1
  KhrPipelineLibraryExtensionName* = "VK_KHR_pipeline_library"
  # VK_KHR_shader_non_semantic_info
  KhrShaderNonSemanticInfoSpecVersion* = 1
  KhrShaderNonSemanticInfoExtensionName* = "VK_KHR_shader_non_semantic_info"
  # VK_KHR_present_id
  KhrPresentIdSpecVersion* = 1
  KhrPresentIdExtensionName* = "VK_KHR_present_id"
  # VK_EXT_private_data
  ExtPrivateDataSpecVersion* = 1
  ExtPrivateDataExtensionName* = "VK_EXT_private_data"
  # VK_EXT_pipeline_creation_cache_control
  ExtPipelineCreationCacheControlSpecVersion* = 3
  ExtPipelineCreationCacheControlExtensionName* = "VK_EXT_pipeline_creation_cache_control"
  # VK_KHR_video_encode_queue
  KhrVideoEncodeQueueSpecVersion* = 3
  KhrVideoEncodeQueueExtensionName* = "VK_KHR_video_encode_queue"
  # VK_NV_device_diagnostics_config
  NvDeviceDiagnosticsConfigSpecVersion* = 1
  NvDeviceDiagnosticsConfigExtensionName* = "VK_NV_device_diagnostics_config"
  # VK_QCOM_render_pass_store_ops
  QcomRenderPassStoreOpsSpecVersion* = 2
  QcomRenderPassStoreOpsExtensionName* = "VK_QCOM_render_pass_store_ops"
  # VK_KHR_synchronization2
  KhrSynchronization2SpecVersion* = 1
  KhrSynchronization2ExtensionName* = "VK_KHR_synchronization2"
  PipelineStageNoneKhr* = 0
  AccessNoneKhr* = 0
  # VK_KHR_shader_subgroup_uniform_control_flow
  KhrShaderSubgroupUniformControlFlowSpecVersion* = 1
  KhrShaderSubgroupUniformControlFlowExtensionName* = "VK_KHR_shader_subgroup_uniform_control_flow"
  # VK_KHR_zero_initialize_workgroup_memory
  KhrZeroInitializeWorkgroupMemorySpecVersion* = 1
  KhrZeroInitializeWorkgroupMemoryExtensionName* = "VK_KHR_zero_initialize_workgroup_memory"
  # VK_NV_fragment_shading_rate_enums
  NvFragmentShadingRateEnumsSpecVersion* = 1
  NvFragmentShadingRateEnumsExtensionName* = "VK_NV_fragment_shading_rate_enums"
  # VK_NV_ray_tracing_motion_blur
  NvRayTracingMotionBlurSpecVersion* = 1
  NvRayTracingMotionBlurExtensionName* = "VK_NV_ray_tracing_motion_blur"
  # VK_EXT_ycbcr_2plane_444_formats
  ExtYcbcr2plane444FormatsSpecVersion* = 1
  ExtYcbcr2plane444FormatsExtensionName* = "VK_EXT_ycbcr_2plane_444_formats"
  # VK_EXT_fragment_density_map2
  ExtFragmentDensityMap2SpecVersion* = 1
  ExtFragmentDensityMap2ExtensionName* = "VK_EXT_fragment_density_map2"
  # VK_QCOM_rotated_copy_commands
  QcomRotatedCopyCommandsSpecVersion* = 1
  QcomRotatedCopyCommandsExtensionName* = "VK_QCOM_rotated_copy_commands"
  # VK_EXT_image_robustness
  ExtImageRobustnessSpecVersion* = 1
  ExtImageRobustnessExtensionName* = "VK_EXT_image_robustness"
  # VK_KHR_workgroup_memory_explicit_layout
  KhrWorkgroupMemoryExplicitLayoutSpecVersion* = 1
  KhrWorkgroupMemoryExplicitLayoutExtensionName* = "VK_KHR_workgroup_memory_explicit_layout"
  # VK_KHR_copy_commands2
  KhrCopyCommands2SpecVersion* = 1
  KhrCopyCommands2ExtensionName* = "VK_KHR_copy_commands2"
  # VK_EXT_4444_formats
  Ext4444FormatsSpecVersion* = 1
  Ext4444FormatsExtensionName* = "VK_EXT_4444_formats"
  # VK_ARM_rasterization_order_attachment_access
  ArmRasterizationOrderAttachmentAccessSpecVersion* = 1
  ArmRasterizationOrderAttachmentAccessExtensionName* = "VK_ARM_rasterization_order_attachment_access"
  # VK_EXT_rgba10x6_formats
  ExtRgba10x6FormatsSpecVersion* = 1
  ExtRgba10x6FormatsExtensionName* = "VK_EXT_rgba10x6_formats"
  # VK_NV_acquire_winrt_display
  NvAcquireWinrtDisplaySpecVersion* = 1
  NvAcquireWinrtDisplayExtensionName* = "VK_NV_acquire_winrt_display"
  # VK_VALVE_mutable_descriptor_type
  ValveMutableDescriptorTypeSpecVersion* = 1
  ValveMutableDescriptorTypeExtensionName* = "VK_VALVE_mutable_descriptor_type"
  # VK_EXT_vertex_input_dynamic_state
  ExtVertexInputDynamicStateSpecVersion* = 2
  ExtVertexInputDynamicStateExtensionName* = "VK_EXT_vertex_input_dynamic_state"
  # VK_EXT_physical_device_drm
  ExtPhysicalDeviceDrmSpecVersion* = 1
  ExtPhysicalDeviceDrmExtensionName* = "VK_EXT_physical_device_drm"
  # VK_EXT_depth_clip_control
  ExtDepthClipControlSpecVersion* = 1
  ExtDepthClipControlExtensionName* = "VK_EXT_depth_clip_control"
  # VK_EXT_primitive_topology_list_restart
  ExtPrimitiveTopologyListRestartSpecVersion* = 1
  ExtPrimitiveTopologyListRestartExtensionName* = "VK_EXT_primitive_topology_list_restart"
  # VK_KHR_format_feature_flags2
  KhrFormatFeatureFlags2SpecVersion* = 1
  KhrFormatFeatureFlags2ExtensionName* = "VK_KHR_format_feature_flags2"
  # VK_FUCHSIA_external_memory
  FuchsiaExternalMemorySpecVersion* = 1
  FuchsiaExternalMemoryExtensionName* = "VK_FUCHSIA_external_memory"
  # VK_FUCHSIA_external_semaphore
  FuchsiaExternalSemaphoreSpecVersion* = 1
  FuchsiaExternalSemaphoreExtensionName* = "VK_FUCHSIA_external_semaphore"
  # VK_FUCHSIA_buffer_collection
  FuchsiaBufferCollectionSpecVersion* = 2
  FuchsiaBufferCollectionExtensionName* = "VK_FUCHSIA_buffer_collection"
  # VK_HUAWEI_subpass_shading
  HuaweiSubpassShadingSpecVersion* = 2
  HuaweiSubpassShadingExtensionName* = "VK_HUAWEI_subpass_shading"
  # VK_HUAWEI_invocation_mask
  HuaweiInvocationMaskSpecVersion* = 1
  HuaweiInvocationMaskExtensionName* = "VK_HUAWEI_invocation_mask"
  # VK_NV_external_memory_rdma
  NvExternalMemoryRdmaSpecVersion* = 1
  NvExternalMemoryRdmaExtensionName* = "VK_NV_external_memory_rdma"
  # VK_EXT_extended_dynamic_state2
  ExtExtendedDynamicState2SpecVersion* = 1
  ExtExtendedDynamicState2ExtensionName* = "VK_EXT_extended_dynamic_state2"
  # VK_QNX_screen_surface
  QnxScreenSurfaceSpecVersion* = 1
  QnxScreenSurfaceExtensionName* = "VK_QNX_screen_surface"
  # VK_EXT_color_write_enable
  ExtColorWriteEnableSpecVersion* = 1
  ExtColorWriteEnableExtensionName* = "VK_EXT_color_write_enable"
  # VK_EXT_global_priority_query
  ExtGlobalPriorityQuerySpecVersion* = 1
  ExtGlobalPriorityQueryExtensionName* = "VK_EXT_global_priority_query"
  # VK_EXT_image_view_min_lod
  ExtImageViewMinLodSpecVersion* = 1
  ExtImageViewMinLodExtensionName* = "VK_EXT_image_view_min_lod"
  # VK_EXT_multi_draw
  ExtMultiDrawSpecVersion* = 1
  ExtMultiDrawExtensionName* = "VK_EXT_multi_draw"
  # VK_EXT_load_store_op_none
  ExtLoadStoreOpNoneSpecVersion* = 1
  ExtLoadStoreOpNoneExtensionName* = "VK_EXT_load_store_op_none"
  # VK_EXT_border_color_swizzle
  ExtBorderColorSwizzleSpecVersion* = 1
  ExtBorderColorSwizzleExtensionName* = "VK_EXT_border_color_swizzle"
  # VK_EXT_pageable_device_local_memory
  ExtPageableDeviceLocalMemorySpecVersion* = 1
  ExtPageableDeviceLocalMemoryExtensionName* = "VK_EXT_pageable_device_local_memory"
  # VK_KHR_maintenance4
  KhrMaintenance4SpecVersion* = 2
  KhrMaintenance4ExtensionName* = "VK_KHR_maintenance4"
  ImageAspectNoneKhr* = 0
  # VK_EXT_disable_cube_map_wrap
  ExtDisableCubeMapWrapSpecVersion* = 0
  ExtDisableCubeMapWrapExtensionName* = "VK_EXT_disable_cube_map_wrap"
  # VK_QCOM_fragment_density_map_offset
  QcomFragmentDensityMapOffsetSpecVersion* = 1
  QcomFragmentDensityMapOffsetExtensionName* = "VK_QCOM_fragment_density_map_offset"
  # VK_NV_linear_color_attachment
  NvLinearColorAttachmentSpecVersion* = 1
  NvLinearColorAttachmentExtensionName* = "VK_NV_linear_color_attachment"
  # VK_GOOGLE_surfaceless_query
  GoogleSurfacelessQuerySpecVersion* = 1
  GoogleSurfacelessQueryExtensionName* = "VK_GOOGLE_surfaceless_query"


# VK_KHR_surface
# ==============
proc destroySurfaceKHR*(
      instance: Instance;
      surface = default(SurfaceKHR);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroySurfaceKHR", InstanceLevel).}
proc getPhysicalDeviceSurfaceSupportKHR*(
      physicalDevice: PhysicalDevice;
      queueFamilyIndex: uint32;
      surface: SurfaceKHR;
      pSupported: ptr Bool32;
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceSupportKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getPhysicalDeviceSurfaceCapabilitiesKHR*(
      physicalDevice: PhysicalDevice;
      surface: SurfaceKHR;
      pSurfaceCapabilities: ptr SurfaceCapabilitiesKHR;
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getPhysicalDeviceSurfaceFormatsKHR*(
      physicalDevice: PhysicalDevice;
      surface = default(SurfaceKHR);
      pSurfaceFormatCount: ptr uint32;
      pSurfaceFormats {.length: pSurfaceFormatCount.} = default(arrPtr[SurfaceFormatKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceFormatsKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getPhysicalDeviceSurfacePresentModesKHR*(
      physicalDevice: PhysicalDevice;
      surface = default(SurfaceKHR);
      pPresentModeCount: ptr uint32;
      pPresentModes {.length: pPresentModeCount.} = default(arrPtr[PresentModeKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceSurfacePresentModesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}

# VK_KHR_swapchain
# ================
proc createSwapchainKHR*(
      device: Device;
      pCreateInfo: ptr SwapchainCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pSwapchain: ptr SwapchainKHR;
    ): Result {.lazyload("vkCreateSwapchainKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost, Result.errorSurfaceLostKhr, Result.errorNativeWindowInUseKhr, Result.errorInitializationFailed].}
proc destroySwapchainKHR*(
      device: Device;
      swapchain = default(SwapchainKHR);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroySwapchainKHR", DeviceLevel).}
proc getSwapchainImagesKHR*(
      device: Device;
      swapchain: SwapchainKHR;
      pSwapchainImageCount: ptr uint32;
      pSwapchainImages {.length: pSwapchainImageCount.} = default(arrPtr[Image]);
    ): Result {.lazyload("vkGetSwapchainImagesKHR", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc acquireNextImageKHR*(
      device: Device;
      swapchain: SwapchainKHR;
      timeout: uint64;
      semaphore = default(Semaphore);
      fence = default(Fence);
      pImageIndex: ptr uint32;
    ): Result {.lazyload("vkAcquireNextImageKHR", DeviceLevel),
      successCodes: @[Result.success, Result.timeout, Result.notReady, Result.suboptimalKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr, Result.errorSurfaceLostKhr, Result.errorFullScreenExclusiveModeLostExt].}
proc queuePresentKHR*(
      queue: Queue;
      pPresentInfo: ptr PresentInfoKHR;
    ): Result {.lazyload("vkQueuePresentKHR", DeviceLevel),
      successCodes: @[Result.success, Result.suboptimalKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr, Result.errorSurfaceLostKhr, Result.errorFullScreenExclusiveModeLostExt].}
proc getDeviceGroupPresentCapabilitiesKHR*(
      device: Device;
      pDeviceGroupPresentCapabilities: ptr DeviceGroupPresentCapabilitiesKHR;
    ): Result {.lazyload("vkGetDeviceGroupPresentCapabilitiesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDeviceGroupSurfacePresentModesKHR*(
      device: Device;
      surface: SurfaceKHR;
      pModes: ptr DeviceGroupPresentModeFlagsKHR;
    ): Result {.lazyload("vkGetDeviceGroupSurfacePresentModesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getPhysicalDevicePresentRectanglesKHR*(
      physicalDevice: PhysicalDevice;
      surface: SurfaceKHR;
      pRectCount: ptr uint32;
      pRects {.length: pRectCount.} = default(arrPtr[Rect2D]);
    ): Result {.lazyload("vkGetPhysicalDevicePresentRectanglesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc acquireNextImage2KHR*(
      device: Device;
      pAcquireInfo: ptr AcquireNextImageInfoKHR;
      pImageIndex: ptr uint32;
    ): Result {.lazyload("vkAcquireNextImage2KHR", DeviceLevel),
      successCodes: @[Result.success, Result.timeout, Result.notReady, Result.suboptimalKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr, Result.errorSurfaceLostKhr, Result.errorFullScreenExclusiveModeLostExt].}

# VK_KHR_display
# ==============
proc getPhysicalDeviceDisplayPropertiesKHR*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayPropertiesKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceDisplayPropertiesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPhysicalDeviceDisplayPlanePropertiesKHR*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayPlanePropertiesKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDisplayPlaneSupportedDisplaysKHR*(
      physicalDevice: PhysicalDevice;
      planeIndex: uint32;
      pDisplayCount: ptr uint32;
      pDisplays {.length: pDisplayCount.} = default(arrPtr[DisplayKHR]);
    ): Result {.lazyload("vkGetDisplayPlaneSupportedDisplaysKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDisplayModePropertiesKHR*(
      physicalDevice: PhysicalDevice;
      display: DisplayKHR;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayModePropertiesKHR]);
    ): Result {.lazyload("vkGetDisplayModePropertiesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc createDisplayModeKHR*(
      physicalDevice: PhysicalDevice;
      display: DisplayKHR;
      pCreateInfo: ptr DisplayModeCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pMode: ptr DisplayModeKHR;
    ): Result {.lazyload("vkCreateDisplayModeKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed].}
proc getDisplayPlaneCapabilitiesKHR*(
      physicalDevice: PhysicalDevice;
      mode: DisplayModeKHR;
      planeIndex: uint32;
      pCapabilities: ptr DisplayPlaneCapabilitiesKHR;
    ): Result {.lazyload("vkGetDisplayPlaneCapabilitiesKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc createDisplayPlaneSurfaceKHR*(
      instance: Instance;
      pCreateInfo: ptr DisplaySurfaceCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateDisplayPlaneSurfaceKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_KHR_display_swapchain
# ========================
proc createSharedSwapchainsKHR*(
      device: Device;
      swapchainCount: uint32;
      pCreateInfos {.length: swapchainCount.}: arrPtr[SwapchainCreateInfoKHR];
      pAllocator = default(ptr AllocationCallbacks);
      pSwapchains {.length: swapchainCount.}: arrPtr[SwapchainKHR];
    ): Result {.lazyload("vkCreateSharedSwapchainsKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorIncompatibleDisplayKhr, Result.errorDeviceLost, Result.errorSurfaceLostKhr].}

# VK_KHR_win32_surface
# ====================
proc createWin32SurfaceKHR*(
      instance: Instance;
      pCreateInfo: ptr Win32SurfaceCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateWin32SurfaceKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPhysicalDeviceWin32PresentationSupportKHR*(
      physicalDevice: PhysicalDevice;
      queueFamilyIndex: uint32;
    ): Bool32 {.lazyload("vkGetPhysicalDeviceWin32PresentationSupportKHR", InstanceLevel).}

# VK_EXT_debug_report
# ===================
proc createDebugReportCallbackEXT*(
      instance: Instance;
      pCreateInfo: ptr DebugReportCallbackCreateInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pCallback: ptr DebugReportCallbackEXT;
    ): Result {.lazyload("vkCreateDebugReportCallbackEXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyDebugReportCallbackEXT*(
      instance: Instance;
      callback = default(DebugReportCallbackEXT);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyDebugReportCallbackEXT", InstanceLevel).}
proc debugReportMessageEXT*(
      instance: Instance;
      flags: DebugReportFlagsEXT;
      objectType: DebugReportObjectTypeEXT;
      `object`: uint64;
      location: uint;
      messageCode: int32;
      pLayerPrefix: cstring;
      pMessage: cstring;
    ): void {.lazyload("vkDebugReportMessageEXT", InstanceLevel).}

# VK_EXT_debug_marker
# ===================
proc debugMarkerSetObjectTagEXT*(
      device: Device;
      pTagInfo: ptr DebugMarkerObjectTagInfoEXT;
    ): Result {.lazyload("vkDebugMarkerSetObjectTagEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc debugMarkerSetObjectNameEXT*(
      device: Device;
      pNameInfo: ptr DebugMarkerObjectNameInfoEXT;
    ): Result {.lazyload("vkDebugMarkerSetObjectNameEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdDebugMarkerBeginEXT*(
      commandBuffer: CommandBuffer;
      pMarkerInfo: ptr DebugMarkerMarkerInfoEXT;
    ): void {.lazyload("vkCmdDebugMarkerBeginEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdDebugMarkerEndEXT*(
      commandBuffer: CommandBuffer;
    ): void {.lazyload("vkCmdDebugMarkerEndEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdDebugMarkerInsertEXT*(
      commandBuffer: CommandBuffer;
      pMarkerInfo: ptr DebugMarkerMarkerInfoEXT;
    ): void {.lazyload("vkCmdDebugMarkerInsertEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}

# VK_KHR_video_queue
# ==================
proc getPhysicalDeviceVideoCapabilitiesKHR*(
      physicalDevice: PhysicalDevice;
      pVideoProfile: ptr VideoProfileKHR;
      pCapabilities: ptr VideoCapabilitiesKHR;
    ): Result {.lazyload("vkGetPhysicalDeviceVideoCapabilitiesKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorExtensionNotPresent, Result.errorInitializationFailed, Result.errorFeatureNotPresent, Result.errorFormatNotSupported].}
proc getPhysicalDeviceVideoFormatPropertiesKHR*(
      physicalDevice: PhysicalDevice;
      pVideoFormatInfo: ptr PhysicalDeviceVideoFormatInfoKHR;
      pVideoFormatPropertyCount: ptr uint32;
      pVideoFormatProperties {.length: pVideoFormatPropertyCount.} = default(arrPtr[VideoFormatPropertiesKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceVideoFormatPropertiesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorExtensionNotPresent, Result.errorInitializationFailed, Result.errorFormatNotSupported].}
proc createVideoSessionKHR*(
      device: Device;
      pCreateInfo: ptr VideoSessionCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pVideoSession: ptr VideoSessionKHR;
    ): Result {.lazyload("vkCreateVideoSessionKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed, Result.errorIncompatibleDriver, Result.errorFeatureNotPresent].}
proc destroyVideoSessionKHR*(
      device: Device;
      videoSession: VideoSessionKHR;
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyVideoSessionKHR", DeviceLevel).}
proc getVideoSessionMemoryRequirementsKHR*(
      device: Device;
      videoSession: VideoSessionKHR;
      pVideoSessionMemoryRequirementsCount: ptr uint32;
      pVideoSessionMemoryRequirements {.length: pVideoSessionMemoryRequirementsCount.} = default(arrPtr[VideoGetMemoryPropertiesKHR]);
    ): Result {.lazyload("vkGetVideoSessionMemoryRequirementsKHR", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorInitializationFailed].}
proc bindVideoSessionMemoryKHR*(
      device: Device;
      videoSession: VideoSessionKHR;
      videoSessionBindMemoryCount: uint32;
      pVideoSessionBindMemories {.length: videoSessionBindMemoryCount.}: arrPtr[VideoBindMemoryKHR];
    ): Result {.lazyload("vkBindVideoSessionMemoryKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed].}
proc createVideoSessionParametersKHR*(
      device: Device;
      pCreateInfo: ptr VideoSessionParametersCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pVideoSessionParameters: ptr VideoSessionParametersKHR;
    ): Result {.lazyload("vkCreateVideoSessionParametersKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed, Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorTooManyObjects].}
proc updateVideoSessionParametersKHR*(
      device: Device;
      videoSessionParameters: VideoSessionParametersKHR;
      pUpdateInfo: ptr VideoSessionParametersUpdateInfoKHR;
    ): Result {.lazyload("vkUpdateVideoSessionParametersKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed, Result.errorTooManyObjects].}
proc destroyVideoSessionParametersKHR*(
      device: Device;
      videoSessionParameters: VideoSessionParametersKHR;
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyVideoSessionParametersKHR", DeviceLevel).}
proc cmdBeginVideoCodingKHR*(
      commandBuffer: CommandBuffer;
      pBeginInfo: ptr VideoBeginCodingInfoKHR;
    ): void {.lazyload("vkCmdBeginVideoCodingKHR", DeviceLevel),
      queues: QueueFlags{decode, encode}.}
proc cmdEndVideoCodingKHR*(
      commandBuffer: CommandBuffer;
      pEndCodingInfo: ptr VideoEndCodingInfoKHR;
    ): void {.lazyload("vkCmdEndVideoCodingKHR", DeviceLevel),
      queues: QueueFlags{decode, encode}.}
proc cmdControlVideoCodingKHR*(
      commandBuffer: CommandBuffer;
      pCodingControlInfo: ptr VideoCodingControlInfoKHR;
    ): void {.lazyload("vkCmdControlVideoCodingKHR", DeviceLevel),
      queues: QueueFlags{decode, encode}.}

# VK_KHR_video_decode_queue
# =========================
proc cmdDecodeVideoKHR*(
      commandBuffer: CommandBuffer;
      pFrameInfo: ptr VideoDecodeInfoKHR;
    ): void {.lazyload("vkCmdDecodeVideoKHR", DeviceLevel),
      queues: QueueFlags{decode}.}

# VK_EXT_transform_feedback
# =========================
proc cmdBindTransformFeedbackBuffersEXT*(
      commandBuffer: CommandBuffer;
      firstBinding: uint32;
      bindingCount: uint32;
      pBuffers {.length: bindingCount.}: arrPtr[Buffer];
      pOffsets {.length: bindingCount.}: arrPtr[DeviceSize];
      pSizes {.length: bindingCount.} = default(arrPtr[DeviceSize]);
    ): void {.lazyload("vkCmdBindTransformFeedbackBuffersEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdBeginTransformFeedbackEXT*(
      commandBuffer: CommandBuffer;
      firstCounterBuffer: uint32;
      counterBufferCount = default(uint32);
      pCounterBuffers {.length: counterBufferCount.}: arrPtr[Buffer];
      pCounterBufferOffsets {.length: counterBufferCount.} = default(arrPtr[DeviceSize]);
    ): void {.lazyload("vkCmdBeginTransformFeedbackEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdEndTransformFeedbackEXT*(
      commandBuffer: CommandBuffer;
      firstCounterBuffer: uint32;
      counterBufferCount = default(uint32);
      pCounterBuffers {.length: counterBufferCount.}: arrPtr[Buffer];
      pCounterBufferOffsets {.length: counterBufferCount.} = default(arrPtr[DeviceSize]);
    ): void {.lazyload("vkCmdEndTransformFeedbackEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdBeginQueryIndexedEXT*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      query: uint32;
      flags = default(QueryControlFlags);
      index: uint32;
    ): void {.lazyload("vkCmdBeginQueryIndexedEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdEndQueryIndexedEXT*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      query: uint32;
      index: uint32;
    ): void {.lazyload("vkCmdEndQueryIndexedEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdDrawIndirectByteCountEXT*(
      commandBuffer: CommandBuffer;
      instanceCount: uint32;
      firstInstance: uint32;
      counterBuffer: Buffer;
      counterBufferOffset: DeviceSize;
      counterOffset: uint32;
      vertexStride: uint32;
    ): void {.lazyload("vkCmdDrawIndirectByteCountEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_NVX_binary_import
# ====================
proc createCuModuleNVX*(
      device: Device;
      pCreateInfo: ptr CuModuleCreateInfoNVX;
      pAllocator = default(ptr AllocationCallbacks);
      pModule: ptr CuModuleNVX;
    ): Result {.lazyload("vkCreateCuModuleNVX", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInitializationFailed].}
proc createCuFunctionNVX*(
      device: Device;
      pCreateInfo: ptr CuFunctionCreateInfoNVX;
      pAllocator = default(ptr AllocationCallbacks);
      pFunction: ptr CuFunctionNVX;
    ): Result {.lazyload("vkCreateCuFunctionNVX", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInitializationFailed].}
proc destroyCuModuleNVX*(
      device: Device;
      module: CuModuleNVX;
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyCuModuleNVX", DeviceLevel).}
proc destroyCuFunctionNVX*(
      device: Device;
      function: CuFunctionNVX;
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyCuFunctionNVX", DeviceLevel).}
proc cmdCuLaunchKernelNVX*(
      commandBuffer: CommandBuffer;
      pLaunchInfo: ptr CuLaunchInfoNVX;
    ): void {.lazyload("vkCmdCuLaunchKernelNVX", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}

# VK_NVX_image_view_handle
# ========================
proc getImageViewHandleNVX*(
      device: Device;
      pInfo: ptr ImageViewHandleInfoNVX;
    ): uint32 {.lazyload("vkGetImageViewHandleNVX", DeviceLevel).}
proc getImageViewAddressNVX*(
      device: Device;
      imageView: ImageView;
      pProperties: ptr ImageViewAddressPropertiesNVX;
    ): Result {.lazyload("vkGetImageViewAddressNVX", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorUnknown].}

# VK_AMD_draw_indirect_count
# ==========================
template cmdDrawIndirectCountAMD* = cmdDrawIndirectCount
template cmdDrawIndexedIndirectCountAMD* = cmdDrawIndexedIndirectCount

# VK_AMD_shader_info
# ==================
proc getShaderInfoAMD*(
      device: Device;
      pipeline: Pipeline;
      shaderStage: ShaderStageFlagBits;
      infoType: ShaderInfoTypeAMD;
      pInfoSize: ptr uint;
      pInfo {.length: pInfoSize.} = default(pointer);
    ): Result {.lazyload("vkGetShaderInfoAMD", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorFeatureNotPresent, Result.errorOutOfHostMemory].}

# VK_KHR_dynamic_rendering
# ========================
proc cmdBeginRenderingKHR*(
      commandBuffer: CommandBuffer;
      pRenderingInfo: ptr RenderingInfoKHR;
    ): void {.lazyload("vkCmdBeginRenderingKHR", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdEndRenderingKHR*(
      commandBuffer: CommandBuffer;
    ): void {.lazyload("vkCmdEndRenderingKHR", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_GGP_stream_descriptor_surface
# ================================
proc createStreamDescriptorSurfaceGGP*(
      instance: Instance;
      pCreateInfo: ptr StreamDescriptorSurfaceCreateInfoGGP;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateStreamDescriptorSurfaceGGP", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorNativeWindowInUseKhr].}

# VK_NV_external_memory_capabilities
# ==================================
proc getPhysicalDeviceExternalImageFormatPropertiesNV*(
      physicalDevice: PhysicalDevice;
      format: Format;
      theType: ImageType;
      tiling: ImageTiling;
      usage: ImageUsageFlags;
      flags = default(ImageCreateFlags);
      externalHandleType = default(ExternalMemoryHandleTypeFlagsNV);
      pExternalImageFormatProperties: ptr ExternalImageFormatPropertiesNV;
    ): Result {.lazyload("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorFormatNotSupported].}

# VK_NV_external_memory_win32
# ===========================
proc getMemoryWin32HandleNV*(
      device: Device;
      memory: DeviceMemory;
      handleType: ExternalMemoryHandleTypeFlagsNV;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetMemoryWin32HandleNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_get_physical_device_properties2
# ======================================
template getPhysicalDeviceFeatures2KHR* = getPhysicalDeviceFeatures2
template getPhysicalDeviceProperties2KHR* = getPhysicalDeviceProperties2
template getPhysicalDeviceFormatProperties2KHR* = getPhysicalDeviceFormatProperties2
template getPhysicalDeviceImageFormatProperties2KHR* = getPhysicalDeviceImageFormatProperties2
template getPhysicalDeviceQueueFamilyProperties2KHR* = getPhysicalDeviceQueueFamilyProperties2
template getPhysicalDeviceMemoryProperties2KHR* = getPhysicalDeviceMemoryProperties2
template getPhysicalDeviceSparseImageFormatProperties2KHR* = getPhysicalDeviceSparseImageFormatProperties2

# VK_KHR_device_group
# ===================
template getDeviceGroupPeerMemoryFeaturesKHR* = getDeviceGroupPeerMemoryFeatures
template cmdSetDeviceMaskKHR* = cmdSetDeviceMask
template cmdDispatchBaseKHR* = cmdDispatchBase

# VK_NN_vi_surface
# ================
proc createViSurfaceNN*(
      instance: Instance;
      pCreateInfo: ptr ViSurfaceCreateInfoNN;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateViSurfaceNN", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorNativeWindowInUseKhr].}

# VK_KHR_maintenance1
# ===================
template trimCommandPoolKHR* = trimCommandPool

# VK_KHR_device_group_creation
# ============================
template enumeratePhysicalDeviceGroupsKHR* = enumeratePhysicalDeviceGroups

# VK_KHR_external_memory_capabilities
# ===================================
template getPhysicalDeviceExternalBufferPropertiesKHR* = getPhysicalDeviceExternalBufferProperties

# VK_KHR_external_memory_win32
# ============================
proc getMemoryWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr MemoryGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetMemoryWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc getMemoryWin32HandlePropertiesKHR*(
      device: Device;
      handleType: ExternalMemoryHandleTypeFlagBits;
      handle: Win32Handle;
      pMemoryWin32HandleProperties: ptr MemoryWin32HandlePropertiesKHR;
    ): Result {.lazyload("vkGetMemoryWin32HandlePropertiesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}

# VK_KHR_external_memory_fd
# =========================
proc getMemoryFdKHR*(
      device: Device;
      pGetFdInfo: ptr MemoryGetFdInfoKHR;
      pFd: ptr int;
    ): Result {.lazyload("vkGetMemoryFdKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc getMemoryFdPropertiesKHR*(
      device: Device;
      handleType: ExternalMemoryHandleTypeFlagBits;
      fd: int;
      pMemoryFdProperties: ptr MemoryFdPropertiesKHR;
    ): Result {.lazyload("vkGetMemoryFdPropertiesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}

# VK_KHR_external_semaphore_capabilities
# ======================================
template getPhysicalDeviceExternalSemaphorePropertiesKHR* = getPhysicalDeviceExternalSemaphoreProperties

# VK_KHR_external_semaphore_win32
# ===============================
proc importSemaphoreWin32HandleKHR*(
      device: Device;
      pImportSemaphoreWin32HandleInfo: ptr ImportSemaphoreWin32HandleInfoKHR;
    ): Result {.lazyload("vkImportSemaphoreWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getSemaphoreWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr SemaphoreGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetSemaphoreWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_external_semaphore_fd
# ============================
proc importSemaphoreFdKHR*(
      device: Device;
      pImportSemaphoreFdInfo: ptr ImportSemaphoreFdInfoKHR;
    ): Result {.lazyload("vkImportSemaphoreFdKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getSemaphoreFdKHR*(
      device: Device;
      pGetFdInfo: ptr SemaphoreGetFdInfoKHR;
      pFd: ptr int;
    ): Result {.lazyload("vkGetSemaphoreFdKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_push_descriptor
# ======================
proc cmdPushDescriptorSetKHR*(
      commandBuffer: CommandBuffer;
      pipelineBindPoint: PipelineBindPoint;
      layout: PipelineLayout;
      set: uint32;
      descriptorWriteCount: uint32;
      pDescriptorWrites {.length: descriptorWriteCount.}: arrPtr[WriteDescriptorSet];
    ): void {.lazyload("vkCmdPushDescriptorSetKHR", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdPushDescriptorSetWithTemplateKHR*(
      commandBuffer: CommandBuffer;
      descriptorUpdateTemplate: DescriptorUpdateTemplate;
      layout: PipelineLayout;
      set: uint32;
      pData: pointer;
    ): void {.lazyload("vkCmdPushDescriptorSetWithTemplateKHR", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}

# VK_EXT_conditional_rendering
# ============================
proc cmdBeginConditionalRenderingEXT*(
      commandBuffer: CommandBuffer;
      pConditionalRenderingBegin: ptr ConditionalRenderingBeginInfoEXT;
    ): void {.lazyload("vkCmdBeginConditionalRenderingEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdEndConditionalRenderingEXT*(
      commandBuffer: CommandBuffer;
    ): void {.lazyload("vkCmdEndConditionalRenderingEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}

# VK_KHR_descriptor_update_template
# =================================
template createDescriptorUpdateTemplateKHR* = createDescriptorUpdateTemplate
template destroyDescriptorUpdateTemplateKHR* = destroyDescriptorUpdateTemplate
template updateDescriptorSetWithTemplateKHR* = updateDescriptorSetWithTemplate

# VK_NV_clip_space_w_scaling
# ==========================
proc cmdSetViewportWScalingNV*(
      commandBuffer: CommandBuffer;
      firstViewport: uint32;
      viewportCount: uint32;
      pViewportWScalings {.length: viewportCount.}: arrPtr[ViewportWScalingNV];
    ): void {.lazyload("vkCmdSetViewportWScalingNV", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_direct_mode_display
# ==========================
proc releaseDisplayEXT*(
      physicalDevice: PhysicalDevice;
      display: DisplayKHR;
    ): Result {.lazyload("vkReleaseDisplayEXT", InstanceLevel),
      successCodes: @[Result.success].}

# VK_EXT_display_surface_counter
# ==============================
proc getPhysicalDeviceSurfaceCapabilities2EXT*(
      physicalDevice: PhysicalDevice;
      surface: SurfaceKHR;
      pSurfaceCapabilities: ptr SurfaceCapabilities2EXT;
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceCapabilities2EXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}

# VK_EXT_display_control
# ======================
proc displayPowerControlEXT*(
      device: Device;
      display: DisplayKHR;
      pDisplayPowerInfo: ptr DisplayPowerInfoEXT;
    ): Result {.lazyload("vkDisplayPowerControlEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc registerDeviceEventEXT*(
      device: Device;
      pDeviceEventInfo: ptr DeviceEventInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pFence: ptr Fence;
    ): Result {.lazyload("vkRegisterDeviceEventEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc registerDisplayEventEXT*(
      device: Device;
      display: DisplayKHR;
      pDisplayEventInfo: ptr DisplayEventInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pFence: ptr Fence;
    ): Result {.lazyload("vkRegisterDisplayEventEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc getSwapchainCounterEXT*(
      device: Device;
      swapchain: SwapchainKHR;
      counter: SurfaceCounterFlagBitsEXT;
      pCounterValue: ptr uint64;
    ): Result {.lazyload("vkGetSwapchainCounterEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr].}

# VK_GOOGLE_display_timing
# ========================
proc getRefreshCycleDurationGOOGLE*(
      device: Device;
      swapchain: SwapchainKHR;
      pDisplayTimingProperties: ptr RefreshCycleDurationGOOGLE;
    ): Result {.lazyload("vkGetRefreshCycleDurationGOOGLE", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorDeviceLost, Result.errorSurfaceLostKhr].}
proc getPastPresentationTimingGOOGLE*(
      device: Device;
      swapchain: SwapchainKHR;
      pPresentationTimingCount: ptr uint32;
      pPresentationTimings {.length: pPresentationTimingCount.} = default(arrPtr[PastPresentationTimingGOOGLE]);
    ): Result {.lazyload("vkGetPastPresentationTimingGOOGLE", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr, Result.errorSurfaceLostKhr].}

# VK_EXT_discard_rectangles
# =========================
proc cmdSetDiscardRectangleEXT*(
      commandBuffer: CommandBuffer;
      firstDiscardRectangle: uint32;
      discardRectangleCount: uint32;
      pDiscardRectangles {.length: discardRectangleCount.}: arrPtr[Rect2D];
    ): void {.lazyload("vkCmdSetDiscardRectangleEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_hdr_metadata
# ===================
proc setHdrMetadataEXT*(
      device: Device;
      swapchainCount: uint32;
      pSwapchains {.length: swapchainCount.}: arrPtr[SwapchainKHR];
      pMetadata {.length: swapchainCount.}: arrPtr[HdrMetadataEXT];
    ): void {.lazyload("vkSetHdrMetadataEXT", DeviceLevel).}

# VK_KHR_create_renderpass2
# =========================
template createRenderPass2KHR* = createRenderPass2
template cmdBeginRenderPass2KHR* = cmdBeginRenderPass2
template cmdNextSubpass2KHR* = cmdNextSubpass2
template cmdEndRenderPass2KHR* = cmdEndRenderPass2

# VK_KHR_shared_presentable_image
# ===============================
proc getSwapchainStatusKHR*(
      device: Device;
      swapchain: SwapchainKHR;
    ): Result {.lazyload("vkGetSwapchainStatusKHR", DeviceLevel),
      successCodes: @[Result.success, Result.suboptimalKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost, Result.errorOutOfDateKhr, Result.errorSurfaceLostKhr, Result.errorFullScreenExclusiveModeLostExt].}

# VK_KHR_external_fence_capabilities
# ==================================
template getPhysicalDeviceExternalFencePropertiesKHR* = getPhysicalDeviceExternalFenceProperties

# VK_KHR_external_fence_win32
# ===========================
proc importFenceWin32HandleKHR*(
      device: Device;
      pImportFenceWin32HandleInfo: ptr ImportFenceWin32HandleInfoKHR;
    ): Result {.lazyload("vkImportFenceWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getFenceWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr FenceGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetFenceWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_external_fence_fd
# ========================
proc importFenceFdKHR*(
      device: Device;
      pImportFenceFdInfo: ptr ImportFenceFdInfoKHR;
    ): Result {.lazyload("vkImportFenceFdKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getFenceFdKHR*(
      device: Device;
      pGetFdInfo: ptr FenceGetFdInfoKHR;
      pFd: ptr int;
    ): Result {.lazyload("vkGetFenceFdKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_performance_query
# ========================
proc enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR*(
      physicalDevice: PhysicalDevice;
      queueFamilyIndex: uint32;
      pCounterCount: ptr uint32;
      pCounters {.length: pCounterCount.} = default(arrPtr[PerformanceCounterKHR]);
      pCounterDescriptions {.length: pCounterCount.} = default(arrPtr[PerformanceCounterDescriptionKHR]);
    ): Result {.lazyload("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed].}
proc getPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR*(
      physicalDevice: PhysicalDevice;
      pPerformanceQueryCreateInfo: ptr QueryPoolPerformanceCreateInfoKHR;
      pNumPasses: ptr uint32;
    ): void {.lazyload("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", InstanceLevel).}
proc acquireProfilingLockKHR*(
      device: Device;
      pInfo: ptr AcquireProfilingLockInfoKHR;
    ): Result {.lazyload("vkAcquireProfilingLockKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.timeout].}
proc releaseProfilingLockKHR*(
      device: Device;
    ): void {.lazyload("vkReleaseProfilingLockKHR", DeviceLevel).}

# VK_KHR_get_surface_capabilities2
# ================================
proc getPhysicalDeviceSurfaceCapabilities2KHR*(
      physicalDevice: PhysicalDevice;
      pSurfaceInfo: ptr PhysicalDeviceSurfaceInfo2KHR;
      pSurfaceCapabilities: ptr SurfaceCapabilities2KHR;
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceCapabilities2KHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getPhysicalDeviceSurfaceFormats2KHR*(
      physicalDevice: PhysicalDevice;
      pSurfaceInfo: ptr PhysicalDeviceSurfaceInfo2KHR;
      pSurfaceFormatCount: ptr uint32;
      pSurfaceFormats {.length: pSurfaceFormatCount.} = default(arrPtr[SurfaceFormat2KHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceSurfaceFormats2KHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}

# VK_KHR_get_display_properties2
# ==============================
proc getPhysicalDeviceDisplayProperties2KHR*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayProperties2KHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceDisplayProperties2KHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPhysicalDeviceDisplayPlaneProperties2KHR*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayPlaneProperties2KHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDisplayModeProperties2KHR*(
      physicalDevice: PhysicalDevice;
      display: DisplayKHR;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[DisplayModeProperties2KHR]);
    ): Result {.lazyload("vkGetDisplayModeProperties2KHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDisplayPlaneCapabilities2KHR*(
      physicalDevice: PhysicalDevice;
      pDisplayPlaneInfo: ptr DisplayPlaneInfo2KHR;
      pCapabilities: ptr DisplayPlaneCapabilities2KHR;
    ): Result {.lazyload("vkGetDisplayPlaneCapabilities2KHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_MVK_macos_surface
# ====================
proc createMacOSSurfaceMVK*(
      instance: Instance;
      pCreateInfo: ptr MacOSSurfaceCreateInfoMVK;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateMacOSSurfaceMVK", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorNativeWindowInUseKhr].}

# VK_EXT_debug_utils
# ==================
proc setDebugUtilsObjectNameEXT*(
      device: Device;
      pNameInfo: ptr DebugUtilsObjectNameInfoEXT;
    ): Result {.lazyload("vkSetDebugUtilsObjectNameEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc setDebugUtilsObjectTagEXT*(
      device: Device;
      pTagInfo: ptr DebugUtilsObjectTagInfoEXT;
    ): Result {.lazyload("vkSetDebugUtilsObjectTagEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc queueBeginDebugUtilsLabelEXT*(
      queue: Queue;
      pLabelInfo: ptr DebugUtilsLabelEXT;
    ): void {.lazyload("vkQueueBeginDebugUtilsLabelEXT", DeviceLevel).}
proc queueEndDebugUtilsLabelEXT*(
      queue: Queue;
    ): void {.lazyload("vkQueueEndDebugUtilsLabelEXT", DeviceLevel).}
proc queueInsertDebugUtilsLabelEXT*(
      queue: Queue;
      pLabelInfo: ptr DebugUtilsLabelEXT;
    ): void {.lazyload("vkQueueInsertDebugUtilsLabelEXT", DeviceLevel).}
proc cmdBeginDebugUtilsLabelEXT*(
      commandBuffer: CommandBuffer;
      pLabelInfo: ptr DebugUtilsLabelEXT;
    ): void {.lazyload("vkCmdBeginDebugUtilsLabelEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdEndDebugUtilsLabelEXT*(
      commandBuffer: CommandBuffer;
    ): void {.lazyload("vkCmdEndDebugUtilsLabelEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdInsertDebugUtilsLabelEXT*(
      commandBuffer: CommandBuffer;
      pLabelInfo: ptr DebugUtilsLabelEXT;
    ): void {.lazyload("vkCmdInsertDebugUtilsLabelEXT", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc createDebugUtilsMessengerEXT*(
      instance: Instance;
      pCreateInfo: ptr DebugUtilsMessengerCreateInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pMessenger: ptr DebugUtilsMessengerEXT;
    ): Result {.lazyload("vkCreateDebugUtilsMessengerEXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyDebugUtilsMessengerEXT*(
      instance: Instance;
      messenger = default(DebugUtilsMessengerEXT);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyDebugUtilsMessengerEXT", InstanceLevel).}
proc submitDebugUtilsMessageEXT*(
      instance: Instance;
      messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT;
      messageTypes: DebugUtilsMessageTypeFlagsEXT;
      pCallbackData: ptr DebugUtilsMessengerCallbackDataEXT;
    ): void {.lazyload("vkSubmitDebugUtilsMessageEXT", InstanceLevel).}

# VK_EXT_sample_locations
# =======================
proc cmdSetSampleLocationsEXT*(
      commandBuffer: CommandBuffer;
      pSampleLocationsInfo: ptr SampleLocationsInfoEXT;
    ): void {.lazyload("vkCmdSetSampleLocationsEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc getPhysicalDeviceMultisamplePropertiesEXT*(
      physicalDevice: PhysicalDevice;
      samples: SampleCountFlagBits;
      pMultisampleProperties: ptr MultisamplePropertiesEXT;
    ): void {.lazyload("vkGetPhysicalDeviceMultisamplePropertiesEXT", InstanceLevel).}

# VK_KHR_get_memory_requirements2
# ===============================
template getImageMemoryRequirements2KHR* = getImageMemoryRequirements2
template getBufferMemoryRequirements2KHR* = getBufferMemoryRequirements2
template getImageSparseMemoryRequirements2KHR* = getImageSparseMemoryRequirements2

# VK_KHR_acceleration_structure
# =============================
proc createAccelerationStructureKHR*(
      device: Device;
      pCreateInfo: ptr AccelerationStructureCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pAccelerationStructure: ptr AccelerationStructureKHR;
    ): Result {.lazyload("vkCreateAccelerationStructureKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidOpaqueCaptureAddressKhr].}
proc destroyAccelerationStructureKHR*(
      device: Device;
      accelerationStructure = default(AccelerationStructureKHR);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyAccelerationStructureKHR", DeviceLevel).}
proc cmdBuildAccelerationStructuresKHR*(
      commandBuffer: CommandBuffer;
      infoCount: uint32;
      pInfos {.length: infoCount.}: arrPtr[AccelerationStructureBuildGeometryInfoKHR];
      ppBuildRangeInfos {.length: infoCount.}: arrPtr[arrPtr[AccelerationStructureBuildRangeInfoKHR]];
    ): void {.lazyload("vkCmdBuildAccelerationStructuresKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc cmdBuildAccelerationStructuresIndirectKHR*(
      commandBuffer: CommandBuffer;
      infoCount: uint32;
      pInfos {.length: infoCount.}: arrPtr[AccelerationStructureBuildGeometryInfoKHR];
      pIndirectDeviceAddresses {.length: infoCount.}: arrPtr[DeviceAddress];
      pIndirectStrides {.length: infoCount.}: arrPtr[uint32];
      ppMaxPrimitiveCounts {.length: infoCount.}: arrPtr[arrPtr[uint32]];
    ): void {.lazyload("vkCmdBuildAccelerationStructuresIndirectKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc buildAccelerationStructuresKHR*(
      device: Device;
      deferredOperation = default(DeferredOperationKHR);
      infoCount: uint32;
      pInfos {.length: infoCount.}: arrPtr[AccelerationStructureBuildGeometryInfoKHR];
      ppBuildRangeInfos {.length: infoCount.}: arrPtr[arrPtr[AccelerationStructureBuildRangeInfoKHR]];
    ): Result {.lazyload("vkBuildAccelerationStructuresKHR", DeviceLevel),
      successCodes: @[Result.success, Result.operationDeferredKhr, Result.operationNotDeferredKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc copyAccelerationStructureKHR*(
      device: Device;
      deferredOperation = default(DeferredOperationKHR);
      pInfo: ptr CopyAccelerationStructureInfoKHR;
    ): Result {.lazyload("vkCopyAccelerationStructureKHR", DeviceLevel),
      successCodes: @[Result.success, Result.operationDeferredKhr, Result.operationNotDeferredKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc copyAccelerationStructureToMemoryKHR*(
      device: Device;
      deferredOperation = default(DeferredOperationKHR);
      pInfo: ptr CopyAccelerationStructureToMemoryInfoKHR;
    ): Result {.lazyload("vkCopyAccelerationStructureToMemoryKHR", DeviceLevel),
      successCodes: @[Result.success, Result.operationDeferredKhr, Result.operationNotDeferredKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc copyMemoryToAccelerationStructureKHR*(
      device: Device;
      deferredOperation = default(DeferredOperationKHR);
      pInfo: ptr CopyMemoryToAccelerationStructureInfoKHR;
    ): Result {.lazyload("vkCopyMemoryToAccelerationStructureKHR", DeviceLevel),
      successCodes: @[Result.success, Result.operationDeferredKhr, Result.operationNotDeferredKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc writeAccelerationStructuresPropertiesKHR*(
      device: Device;
      accelerationStructureCount: uint32;
      pAccelerationStructures {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureKHR];
      queryType: QueryType;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
      stride: uint;
    ): Result {.lazyload("vkWriteAccelerationStructuresPropertiesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdCopyAccelerationStructureKHR*(
      commandBuffer: CommandBuffer;
      pInfo: ptr CopyAccelerationStructureInfoKHR;
    ): void {.lazyload("vkCmdCopyAccelerationStructureKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc cmdCopyAccelerationStructureToMemoryKHR*(
      commandBuffer: CommandBuffer;
      pInfo: ptr CopyAccelerationStructureToMemoryInfoKHR;
    ): void {.lazyload("vkCmdCopyAccelerationStructureToMemoryKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc cmdCopyMemoryToAccelerationStructureKHR*(
      commandBuffer: CommandBuffer;
      pInfo: ptr CopyMemoryToAccelerationStructureInfoKHR;
    ): void {.lazyload("vkCmdCopyMemoryToAccelerationStructureKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc getAccelerationStructureDeviceAddressKHR*(
      device: Device;
      pInfo: ptr AccelerationStructureDeviceAddressInfoKHR;
    ): DeviceAddress {.lazyload("vkGetAccelerationStructureDeviceAddressKHR", DeviceLevel).}
proc cmdWriteAccelerationStructuresPropertiesKHR*(
      commandBuffer: CommandBuffer;
      accelerationStructureCount: uint32;
      pAccelerationStructures {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureKHR];
      queryType: QueryType;
      queryPool: QueryPool;
      firstQuery: uint32;
    ): void {.lazyload("vkCmdWriteAccelerationStructuresPropertiesKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc getDeviceAccelerationStructureCompatibilityKHR*(
      device: Device;
      pVersionInfo: ptr AccelerationStructureVersionInfoKHR;
      pCompatibility: ptr AccelerationStructureCompatibilityKHR;
    ): void {.lazyload("vkGetDeviceAccelerationStructureCompatibilityKHR", DeviceLevel).}
proc getAccelerationStructureBuildSizesKHR*(
      device: Device;
      buildType: AccelerationStructureBuildTypeKHR;
      pBuildInfo: ptr AccelerationStructureBuildGeometryInfoKHR;
      pMaxPrimitiveCounts {.length: pBuildInfo.geometryCount.} = default(arrPtr[uint32]);
      pSizeInfo: ptr AccelerationStructureBuildSizesInfoKHR;
    ): void {.lazyload("vkGetAccelerationStructureBuildSizesKHR", DeviceLevel).}

# VK_KHR_ray_tracing_pipeline
# ===========================
proc cmdTraceRaysKHR*(
      commandBuffer: CommandBuffer;
      pRaygenShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pMissShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pHitShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pCallableShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      width: uint32;
      height: uint32;
      depth: uint32;
    ): void {.lazyload("vkCmdTraceRaysKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc createRayTracingPipelinesKHR*(
      device: Device;
      deferredOperation = default(DeferredOperationKHR);
      pipelineCache = default(PipelineCache);
      createInfoCount: uint32;
      pCreateInfos {.length: createInfoCount.}: arrPtr[RayTracingPipelineCreateInfoKHR];
      pAllocator = default(ptr AllocationCallbacks);
      pPipelines {.length: createInfoCount.}: arrPtr[Pipeline];
    ): Result {.lazyload("vkCreateRayTracingPipelinesKHR", DeviceLevel),
      successCodes: @[Result.success, Result.operationDeferredKhr, Result.operationNotDeferredKhr, Result.pipelineCompileRequiredExt],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidOpaqueCaptureAddress].}
proc getRayTracingShaderGroupHandlesKHR*(
      device: Device;
      pipeline: Pipeline;
      firstGroup: uint32;
      groupCount: uint32;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
    ): Result {.lazyload("vkGetRayTracingShaderGroupHandlesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getRayTracingCaptureReplayShaderGroupHandlesKHR*(
      device: Device;
      pipeline: Pipeline;
      firstGroup: uint32;
      groupCount: uint32;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
    ): Result {.lazyload("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdTraceRaysIndirectKHR*(
      commandBuffer: CommandBuffer;
      pRaygenShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pMissShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pHitShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      pCallableShaderBindingTable: ptr StridedDeviceAddressRegionKHR;
      indirectDeviceAddress: DeviceAddress;
    ): void {.lazyload("vkCmdTraceRaysIndirectKHR", DeviceLevel),
      queues: QueueFlags{compute}.}
proc getRayTracingShaderGroupStackSizeKHR*(
      device: Device;
      pipeline: Pipeline;
      group: uint32;
      groupShader: ShaderGroupShaderKHR;
    ): DeviceSize {.lazyload("vkGetRayTracingShaderGroupStackSizeKHR", DeviceLevel).}
proc cmdSetRayTracingPipelineStackSizeKHR*(
      commandBuffer: CommandBuffer;
      pipelineStackSize: uint32;
    ): void {.lazyload("vkCmdSetRayTracingPipelineStackSizeKHR", DeviceLevel),
      queues: QueueFlags{compute}.}

# VK_KHR_sampler_ycbcr_conversion
# ===============================
template createSamplerYcbcrConversionKHR* = createSamplerYcbcrConversion
template destroySamplerYcbcrConversionKHR* = destroySamplerYcbcrConversion

# VK_KHR_bind_memory2
# ===================
template bindBufferMemory2KHR* = bindBufferMemory2
template bindImageMemory2KHR* = bindImageMemory2

# VK_EXT_image_drm_format_modifier
# ================================
proc getImageDrmFormatModifierPropertiesEXT*(
      device: Device;
      image: Image;
      pProperties: ptr ImageDrmFormatModifierPropertiesEXT;
    ): Result {.lazyload("vkGetImageDrmFormatModifierPropertiesEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}

# VK_EXT_validation_cache
# =======================
proc createValidationCacheEXT*(
      device: Device;
      pCreateInfo: ptr ValidationCacheCreateInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pValidationCache: ptr ValidationCacheEXT;
    ): Result {.lazyload("vkCreateValidationCacheEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyValidationCacheEXT*(
      device: Device;
      validationCache = default(ValidationCacheEXT);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyValidationCacheEXT", DeviceLevel).}
proc mergeValidationCachesEXT*(
      device: Device;
      dstCache: ValidationCacheEXT;
      srcCacheCount: uint32;
      pSrcCaches {.length: srcCacheCount.}: arrPtr[ValidationCacheEXT];
    ): Result {.lazyload("vkMergeValidationCachesEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getValidationCacheDataEXT*(
      device: Device;
      validationCache: ValidationCacheEXT;
      pDataSize: ptr uint;
      pData {.length: pDataSize.} = default(pointer);
    ): Result {.lazyload("vkGetValidationCacheDataEXT", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_NV_shading_rate_image
# ========================
proc cmdBindShadingRateImageNV*(
      commandBuffer: CommandBuffer;
      imageView = default(ImageView);
      imageLayout: ImageLayout;
    ): void {.lazyload("vkCmdBindShadingRateImageNV", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetViewportShadingRatePaletteNV*(
      commandBuffer: CommandBuffer;
      firstViewport: uint32;
      viewportCount: uint32;
      pShadingRatePalettes {.length: viewportCount.}: arrPtr[ShadingRatePaletteNV];
    ): void {.lazyload("vkCmdSetViewportShadingRatePaletteNV", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetCoarseSampleOrderNV*(
      commandBuffer: CommandBuffer;
      sampleOrderType: CoarseSampleOrderTypeNV;
      customSampleOrderCount = default(uint32);
      pCustomSampleOrders {.length: customSampleOrderCount.}: arrPtr[CoarseSampleOrderCustomNV];
    ): void {.lazyload("vkCmdSetCoarseSampleOrderNV", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_NV_ray_tracing
# =================
proc createAccelerationStructureNV*(
      device: Device;
      pCreateInfo: ptr AccelerationStructureCreateInfoNV;
      pAllocator = default(ptr AllocationCallbacks);
      pAccelerationStructure: ptr AccelerationStructureNV;
    ): Result {.lazyload("vkCreateAccelerationStructureNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyAccelerationStructureNV*(
      device: Device;
      accelerationStructure = default(AccelerationStructureNV);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyAccelerationStructureNV", DeviceLevel).}
proc getAccelerationStructureMemoryRequirementsNV*(
      device: Device;
      pInfo: ptr AccelerationStructureMemoryRequirementsInfoNV;
      pMemoryRequirements: ptr MemoryRequirements2KHR;
    ): void {.lazyload("vkGetAccelerationStructureMemoryRequirementsNV", DeviceLevel).}
proc bindAccelerationStructureMemoryNV*(
      device: Device;
      bindInfoCount: uint32;
      pBindInfos {.length: bindInfoCount.}: arrPtr[BindAccelerationStructureMemoryInfoNV];
    ): Result {.lazyload("vkBindAccelerationStructureMemoryNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdBuildAccelerationStructureNV*(
      commandBuffer: CommandBuffer;
      pInfo: ptr AccelerationStructureInfoNV;
      instanceData = default(Buffer);
      instanceOffset: DeviceSize;
      update: Bool32;
      dst: AccelerationStructureNV;
      src = default(AccelerationStructureNV);
      scratch: Buffer;
      scratchOffset: DeviceSize;
    ): void {.lazyload("vkCmdBuildAccelerationStructureNV", DeviceLevel),
      queues: QueueFlags{compute}.}
proc cmdCopyAccelerationStructureNV*(
      commandBuffer: CommandBuffer;
      dst: AccelerationStructureNV;
      src: AccelerationStructureNV;
      mode: CopyAccelerationStructureModeKHR;
    ): void {.lazyload("vkCmdCopyAccelerationStructureNV", DeviceLevel),
      queues: QueueFlags{compute}.}
proc cmdTraceRaysNV*(
      commandBuffer: CommandBuffer;
      raygenShaderBindingTableBuffer: Buffer;
      raygenShaderBindingOffset: DeviceSize;
      missShaderBindingTableBuffer = default(Buffer);
      missShaderBindingOffset: DeviceSize;
      missShaderBindingStride: DeviceSize;
      hitShaderBindingTableBuffer = default(Buffer);
      hitShaderBindingOffset: DeviceSize;
      hitShaderBindingStride: DeviceSize;
      callableShaderBindingTableBuffer = default(Buffer);
      callableShaderBindingOffset: DeviceSize;
      callableShaderBindingStride: DeviceSize;
      width: uint32;
      height: uint32;
      depth: uint32;
    ): void {.lazyload("vkCmdTraceRaysNV", DeviceLevel),
      queues: QueueFlags{compute}.}
proc createRayTracingPipelinesNV*(
      device: Device;
      pipelineCache = default(PipelineCache);
      createInfoCount: uint32;
      pCreateInfos {.length: createInfoCount.}: arrPtr[RayTracingPipelineCreateInfoNV];
      pAllocator = default(ptr AllocationCallbacks);
      pPipelines {.length: createInfoCount.}: arrPtr[Pipeline];
    ): Result {.lazyload("vkCreateRayTracingPipelinesNV", DeviceLevel),
      successCodes: @[Result.success, Result.pipelineCompileRequiredExt],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidShaderNv].}
template getRayTracingShaderGroupHandlesNV* = getRayTracingShaderGroupHandlesKHR
proc getAccelerationStructureHandleNV*(
      device: Device;
      accelerationStructure: AccelerationStructureNV;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
    ): Result {.lazyload("vkGetAccelerationStructureHandleNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdWriteAccelerationStructuresPropertiesNV*(
      commandBuffer: CommandBuffer;
      accelerationStructureCount: uint32;
      pAccelerationStructures {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureNV];
      queryType: QueryType;
      queryPool: QueryPool;
      firstQuery: uint32;
    ): void {.lazyload("vkCmdWriteAccelerationStructuresPropertiesNV", DeviceLevel),
      queues: QueueFlags{compute}.}
proc compileDeferredNV*(
      device: Device;
      pipeline: Pipeline;
      shader: uint32;
    ): Result {.lazyload("vkCompileDeferredNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_KHR_maintenance3
# ===================
template getDescriptorSetLayoutSupportKHR* = getDescriptorSetLayoutSupport

# VK_KHR_draw_indirect_count
# ==========================
template cmdDrawIndirectCountKHR* = cmdDrawIndirectCount
template cmdDrawIndexedIndirectCountKHR* = cmdDrawIndexedIndirectCount

# VK_EXT_external_memory_host
# ===========================
proc getMemoryHostPointerPropertiesEXT*(
      device: Device;
      handleType: ExternalMemoryHandleTypeFlagBits;
      pHostPointer: pointer;
      pMemoryHostPointerProperties: ptr MemoryHostPointerPropertiesEXT;
    ): Result {.lazyload("vkGetMemoryHostPointerPropertiesEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}

# VK_AMD_buffer_marker
# ====================
proc cmdWriteBufferMarkerAMD*(
      commandBuffer: CommandBuffer;
      pipelineStage = default(PipelineStageFlagBits);
      dstBuffer: Buffer;
      dstOffset: DeviceSize;
      marker: uint32;
    ): void {.lazyload("vkCmdWriteBufferMarkerAMD", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}

# VK_EXT_calibrated_timestamps
# ============================
proc getPhysicalDeviceCalibrateableTimeDomainsEXT*(
      physicalDevice: PhysicalDevice;
      pTimeDomainCount: ptr uint32;
      pTimeDomains {.length: pTimeDomainCount.} = default(arrPtr[TimeDomainEXT]);
    ): Result {.lazyload("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getCalibratedTimestampsEXT*(
      device: Device;
      timestampCount: uint32;
      pTimestampInfos {.length: timestampCount.}: arrPtr[CalibratedTimestampInfoEXT];
      pTimestamps {.length: timestampCount.}: arrPtr[uint64];
      pMaxDeviation: ptr uint64;
    ): Result {.lazyload("vkGetCalibratedTimestampsEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_NV_mesh_shader
# =================
proc cmdDrawMeshTasksNV*(
      commandBuffer: CommandBuffer;
      taskCount: uint32;
      firstTask: uint32;
    ): void {.lazyload("vkCmdDrawMeshTasksNV", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdDrawMeshTasksIndirectNV*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
      drawCount: uint32;
      stride: uint32;
    ): void {.lazyload("vkCmdDrawMeshTasksIndirectNV", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdDrawMeshTasksIndirectCountNV*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
      countBuffer: Buffer;
      countBufferOffset: DeviceSize;
      maxDrawCount: uint32;
      stride: uint32;
    ): void {.lazyload("vkCmdDrawMeshTasksIndirectCountNV", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_NV_scissor_exclusive
# =======================
proc cmdSetExclusiveScissorNV*(
      commandBuffer: CommandBuffer;
      firstExclusiveScissor: uint32;
      exclusiveScissorCount: uint32;
      pExclusiveScissors {.length: exclusiveScissorCount.}: arrPtr[Rect2D];
    ): void {.lazyload("vkCmdSetExclusiveScissorNV", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_NV_device_diagnostic_checkpoints
# ===================================
proc cmdSetCheckpointNV*(
      commandBuffer: CommandBuffer;
      pCheckpointMarker: pointer;
    ): void {.lazyload("vkCmdSetCheckpointNV", DeviceLevel),
      queues: QueueFlags{graphics, compute, transfer}.}
proc getQueueCheckpointDataNV*(
      queue: Queue;
      pCheckpointDataCount: ptr uint32;
      pCheckpointData {.length: pCheckpointDataCount.} = default(arrPtr[CheckpointDataNV]);
    ): void {.lazyload("vkGetQueueCheckpointDataNV", DeviceLevel).}

# VK_KHR_timeline_semaphore
# =========================
template getSemaphoreCounterValueKHR* = getSemaphoreCounterValue
template waitSemaphoresKHR* = waitSemaphores
template signalSemaphoreKHR* = signalSemaphore

# VK_INTEL_performance_query
# ==========================
proc initializePerformanceApiINTEL*(
      device: Device;
      pInitializeInfo: ptr InitializePerformanceApiInfoINTEL;
    ): Result {.lazyload("vkInitializePerformanceApiINTEL", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc uninitializePerformanceApiINTEL*(
      device: Device;
    ): void {.lazyload("vkUninitializePerformanceApiINTEL", DeviceLevel).}
proc cmdSetPerformanceMarkerINTEL*(
      commandBuffer: CommandBuffer;
      pMarkerInfo: ptr PerformanceMarkerInfoINTEL;
    ): Result {.lazyload("vkCmdSetPerformanceMarkerINTEL", DeviceLevel),
      queues: QueueFlags{graphics, compute, transfer},
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc cmdSetPerformanceStreamMarkerINTEL*(
      commandBuffer: CommandBuffer;
      pMarkerInfo: ptr PerformanceStreamMarkerInfoINTEL;
    ): Result {.lazyload("vkCmdSetPerformanceStreamMarkerINTEL", DeviceLevel),
      queues: QueueFlags{graphics, compute, transfer},
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc cmdSetPerformanceOverrideINTEL*(
      commandBuffer: CommandBuffer;
      pOverrideInfo: ptr PerformanceOverrideInfoINTEL;
    ): Result {.lazyload("vkCmdSetPerformanceOverrideINTEL", DeviceLevel),
      queues: QueueFlags{graphics, compute, transfer},
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc acquirePerformanceConfigurationINTEL*(
      device: Device;
      pAcquireInfo: ptr PerformanceConfigurationAcquireInfoINTEL;
      pConfiguration: ptr PerformanceConfigurationINTEL;
    ): Result {.lazyload("vkAcquirePerformanceConfigurationINTEL", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc releasePerformanceConfigurationINTEL*(
      device: Device;
      configuration = default(PerformanceConfigurationINTEL);
    ): Result {.lazyload("vkReleasePerformanceConfigurationINTEL", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc queueSetPerformanceConfigurationINTEL*(
      queue: Queue;
      configuration: PerformanceConfigurationINTEL;
    ): Result {.lazyload("vkQueueSetPerformanceConfigurationINTEL", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc getPerformanceParameterINTEL*(
      device: Device;
      parameter: PerformanceParameterTypeINTEL;
      pValue: ptr PerformanceValueINTEL;
    ): Result {.lazyload("vkGetPerformanceParameterINTEL", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_AMD_display_native_hdr
# =========================
proc setLocalDimmingAMD*(
      device: Device;
      swapChain: SwapchainKHR;
      localDimmingEnable: Bool32;
    ): void {.lazyload("vkSetLocalDimmingAMD", DeviceLevel).}

# VK_FUCHSIA_imagepipe_surface
# ============================
proc createImagePipeSurfaceFUCHSIA*(
      instance: Instance;
      pCreateInfo: ptr ImagePipeSurfaceCreateInfoFUCHSIA;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateImagePipeSurfaceFUCHSIA", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_KHR_fragment_shading_rate
# ============================
proc getPhysicalDeviceFragmentShadingRatesKHR*(
      physicalDevice: PhysicalDevice;
      pFragmentShadingRateCount: ptr uint32;
      pFragmentShadingRates {.length: pFragmentShadingRateCount.} = default(arrPtr[PhysicalDeviceFragmentShadingRateKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceFragmentShadingRatesKHR", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc cmdSetFragmentShadingRateKHR*(
      commandBuffer: CommandBuffer;
      pFragmentSize: ptr Extent2D;
      combinerOps: FragmentShadingRateCombinerOpKHR;
    ): void {.lazyload("vkCmdSetFragmentShadingRateKHR", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_buffer_device_address
# ============================
template getBufferDeviceAddressEXT* = getBufferDeviceAddress

# VK_EXT_tooling_info
# ===================
proc getPhysicalDeviceToolPropertiesEXT*(
      physicalDevice: PhysicalDevice;
      pToolCount: ptr uint32;
      pToolProperties {.length: pToolCount.} = default(arrPtr[PhysicalDeviceToolPropertiesEXT]);
    ): Result {.lazyload("vkGetPhysicalDeviceToolPropertiesEXT", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory].}

# VK_KHR_present_wait
# ===================
proc waitForPresentKHR*(
      device: Device;
      swapchain: SwapchainKHR;
      presentId: uint64;
      timeout: uint64;
    ): Result {.lazyload("vkWaitForPresentKHR", DeviceLevel),
      successCodes: @[Result.success, Result.timeout],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}

# VK_NV_cooperative_matrix
# ========================
proc getPhysicalDeviceCooperativeMatrixPropertiesNV*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[CooperativeMatrixPropertiesNV]);
    ): Result {.lazyload("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_NV_coverage_reduction_mode
# =============================
proc getPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV*(
      physicalDevice: PhysicalDevice;
      pCombinationCount: ptr uint32;
      pCombinations {.length: pCombinationCount.} = default(arrPtr[FramebufferMixedSamplesCombinationNV]);
    ): Result {.lazyload("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_EXT_full_screen_exclusive
# ============================
proc getPhysicalDeviceSurfacePresentModes2EXT*(
      physicalDevice: PhysicalDevice;
      pSurfaceInfo: ptr PhysicalDeviceSurfaceInfo2KHR;
      pPresentModeCount: ptr uint32;
      pPresentModes {.length: pPresentModeCount.} = default(arrPtr[PresentModeKHR]);
    ): Result {.lazyload("vkGetPhysicalDeviceSurfacePresentModes2EXT", InstanceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc acquireFullScreenExclusiveModeEXT*(
      device: Device;
      swapchain: SwapchainKHR;
    ): Result {.lazyload("vkAcquireFullScreenExclusiveModeEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed, Result.errorSurfaceLostKhr].}
proc releaseFullScreenExclusiveModeEXT*(
      device: Device;
      swapchain: SwapchainKHR;
    ): Result {.lazyload("vkReleaseFullScreenExclusiveModeEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc getDeviceGroupSurfacePresentModes2EXT*(
      device: Device;
      pSurfaceInfo: ptr PhysicalDeviceSurfaceInfo2KHR;
      pModes: ptr DeviceGroupPresentModeFlagsKHR;
    ): Result {.lazyload("vkGetDeviceGroupSurfacePresentModes2EXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}

# VK_EXT_headless_surface
# =======================
proc createHeadlessSurfaceEXT*(
      instance: Instance;
      pCreateInfo: ptr HeadlessSurfaceCreateInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateHeadlessSurfaceEXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_KHR_buffer_device_address
# ============================
template getBufferDeviceAddressKHR* = getBufferDeviceAddress
template getBufferOpaqueCaptureAddressKHR* = getBufferOpaqueCaptureAddress
template getDeviceMemoryOpaqueCaptureAddressKHR* = getDeviceMemoryOpaqueCaptureAddress

# VK_EXT_line_rasterization
# =========================
proc cmdSetLineStippleEXT*(
      commandBuffer: CommandBuffer;
      lineStippleFactor: uint32;
      lineStipplePattern: uint16;
    ): void {.lazyload("vkCmdSetLineStippleEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_host_query_reset
# =======================
template resetQueryPoolEXT* = resetQueryPool

# VK_EXT_extended_dynamic_state
# =============================
proc cmdSetCullModeEXT*(
      commandBuffer: CommandBuffer;
      cullMode = default(CullModeFlags);
    ): void {.lazyload("vkCmdSetCullModeEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetFrontFaceEXT*(
      commandBuffer: CommandBuffer;
      frontFace: FrontFace;
    ): void {.lazyload("vkCmdSetFrontFaceEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetPrimitiveTopologyEXT*(
      commandBuffer: CommandBuffer;
      primitiveTopology: PrimitiveTopology;
    ): void {.lazyload("vkCmdSetPrimitiveTopologyEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetViewportWithCountEXT*(
      commandBuffer: CommandBuffer;
      viewportCount: uint32;
      pViewports {.length: viewportCount.}: arrPtr[Viewport];
    ): void {.lazyload("vkCmdSetViewportWithCountEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetScissorWithCountEXT*(
      commandBuffer: CommandBuffer;
      scissorCount: uint32;
      pScissors {.length: scissorCount.}: arrPtr[Rect2D];
    ): void {.lazyload("vkCmdSetScissorWithCountEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdBindVertexBuffers2EXT*(
      commandBuffer: CommandBuffer;
      firstBinding: uint32;
      bindingCount: uint32;
      pBuffers {.length: bindingCount.}: arrPtr[Buffer];
      pOffsets {.length: bindingCount.}: arrPtr[DeviceSize];
      pSizes {.length: bindingCount.} = default(arrPtr[DeviceSize]);
      pStrides {.length: bindingCount.} = default(arrPtr[DeviceSize]);
    ): void {.lazyload("vkCmdBindVertexBuffers2EXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetDepthTestEnableEXT*(
      commandBuffer: CommandBuffer;
      depthTestEnable: Bool32;
    ): void {.lazyload("vkCmdSetDepthTestEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetDepthWriteEnableEXT*(
      commandBuffer: CommandBuffer;
      depthWriteEnable: Bool32;
    ): void {.lazyload("vkCmdSetDepthWriteEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetDepthCompareOpEXT*(
      commandBuffer: CommandBuffer;
      depthCompareOp: CompareOp;
    ): void {.lazyload("vkCmdSetDepthCompareOpEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetDepthBoundsTestEnableEXT*(
      commandBuffer: CommandBuffer;
      depthBoundsTestEnable: Bool32;
    ): void {.lazyload("vkCmdSetDepthBoundsTestEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetStencilTestEnableEXT*(
      commandBuffer: CommandBuffer;
      stencilTestEnable: Bool32;
    ): void {.lazyload("vkCmdSetStencilTestEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetStencilOpEXT*(
      commandBuffer: CommandBuffer;
      faceMask: StencilFaceFlags;
      failOp: StencilOp;
      passOp: StencilOp;
      depthFailOp: StencilOp;
      compareOp: CompareOp;
    ): void {.lazyload("vkCmdSetStencilOpEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_KHR_deferred_host_operations
# ===============================
proc createDeferredOperationKHR*(
      device: Device;
      pAllocator = default(ptr AllocationCallbacks);
      pDeferredOperation: ptr DeferredOperationKHR;
    ): Result {.lazyload("vkCreateDeferredOperationKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyDeferredOperationKHR*(
      device: Device;
      operation = default(DeferredOperationKHR);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyDeferredOperationKHR", DeviceLevel).}
proc getDeferredOperationMaxConcurrencyKHR*(
      device: Device;
      operation: DeferredOperationKHR;
    ): uint32 {.lazyload("vkGetDeferredOperationMaxConcurrencyKHR", DeviceLevel).}
proc getDeferredOperationResultKHR*(
      device: Device;
      operation: DeferredOperationKHR;
    ): Result {.lazyload("vkGetDeferredOperationResultKHR", DeviceLevel),
      successCodes: @[Result.success, Result.notReady].}
proc deferredOperationJoinKHR*(
      device: Device;
      operation: DeferredOperationKHR;
    ): Result {.lazyload("vkDeferredOperationJoinKHR", DeviceLevel),
      successCodes: @[Result.success, Result.threadDoneKhr, Result.threadIdleKhr],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_KHR_pipeline_executable_properties
# =====================================
proc getPipelineExecutablePropertiesKHR*(
      device: Device;
      pPipelineInfo: ptr PipelineInfoKHR;
      pExecutableCount: ptr uint32;
      pProperties {.length: pExecutableCount.} = default(arrPtr[PipelineExecutablePropertiesKHR]);
    ): Result {.lazyload("vkGetPipelineExecutablePropertiesKHR", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPipelineExecutableStatisticsKHR*(
      device: Device;
      pExecutableInfo: ptr PipelineExecutableInfoKHR;
      pStatisticCount: ptr uint32;
      pStatistics {.length: pStatisticCount.} = default(arrPtr[PipelineExecutableStatisticKHR]);
    ): Result {.lazyload("vkGetPipelineExecutableStatisticsKHR", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPipelineExecutableInternalRepresentationsKHR*(
      device: Device;
      pExecutableInfo: ptr PipelineExecutableInfoKHR;
      pInternalRepresentationCount: ptr uint32;
      pInternalRepresentations {.length: pInternalRepresentationCount.} = default(arrPtr[PipelineExecutableInternalRepresentationKHR]);
    ): Result {.lazyload("vkGetPipelineExecutableInternalRepresentationsKHR", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}

# VK_NV_device_generated_commands
# ===============================
proc getGeneratedCommandsMemoryRequirementsNV*(
      device: Device;
      pInfo: ptr GeneratedCommandsMemoryRequirementsInfoNV;
      pMemoryRequirements: ptr MemoryRequirements2;
    ): void {.lazyload("vkGetGeneratedCommandsMemoryRequirementsNV", DeviceLevel).}
proc cmdPreprocessGeneratedCommandsNV*(
      commandBuffer: CommandBuffer;
      pGeneratedCommandsInfo: ptr GeneratedCommandsInfoNV;
    ): void {.lazyload("vkCmdPreprocessGeneratedCommandsNV", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdExecuteGeneratedCommandsNV*(
      commandBuffer: CommandBuffer;
      isPreprocessed: Bool32;
      pGeneratedCommandsInfo: ptr GeneratedCommandsInfoNV;
    ): void {.lazyload("vkCmdExecuteGeneratedCommandsNV", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdBindPipelineShaderGroupNV*(
      commandBuffer: CommandBuffer;
      pipelineBindPoint: PipelineBindPoint;
      pipeline: Pipeline;
      groupIndex: uint32;
    ): void {.lazyload("vkCmdBindPipelineShaderGroupNV", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc createIndirectCommandsLayoutNV*(
      device: Device;
      pCreateInfo: ptr IndirectCommandsLayoutCreateInfoNV;
      pAllocator = default(ptr AllocationCallbacks);
      pIndirectCommandsLayout: ptr IndirectCommandsLayoutNV;
    ): Result {.lazyload("vkCreateIndirectCommandsLayoutNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyIndirectCommandsLayoutNV*(
      device: Device;
      indirectCommandsLayout = default(IndirectCommandsLayoutNV);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyIndirectCommandsLayoutNV", DeviceLevel).}

# VK_EXT_acquire_drm_display
# ==========================
proc acquireDrmDisplayEXT*(
      physicalDevice: PhysicalDevice;
      drmFd: int32;
      display: DisplayKHR;
    ): Result {.lazyload("vkAcquireDrmDisplayEXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed].}
proc getDrmDisplayEXT*(
      physicalDevice: PhysicalDevice;
      drmFd: int32;
      connectorId: uint32;
      display: ptr DisplayKHR;
    ): Result {.lazyload("vkGetDrmDisplayEXT", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed, Result.errorOutOfHostMemory].}

# VK_EXT_private_data
# ===================
proc createPrivateDataSlotEXT*(
      device: Device;
      pCreateInfo: ptr PrivateDataSlotCreateInfoEXT;
      pAllocator = default(ptr AllocationCallbacks);
      pPrivateDataSlot: ptr PrivateDataSlotEXT;
    ): Result {.lazyload("vkCreatePrivateDataSlotEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyPrivateDataSlotEXT*(
      device: Device;
      privateDataSlot = default(PrivateDataSlotEXT);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyPrivateDataSlotEXT", DeviceLevel).}
proc setPrivateDataEXT*(
      device: Device;
      objectType: ObjectType;
      objectHandle: uint64;
      privateDataSlot: PrivateDataSlotEXT;
      data: uint64;
    ): Result {.lazyload("vkSetPrivateDataEXT", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc getPrivateDataEXT*(
      device: Device;
      objectType: ObjectType;
      objectHandle: uint64;
      privateDataSlot: PrivateDataSlotEXT;
      pData: ptr uint64;
    ): void {.lazyload("vkGetPrivateDataEXT", DeviceLevel).}

# VK_KHR_video_encode_queue
# =========================
proc cmdEncodeVideoKHR*(
      commandBuffer: CommandBuffer;
      pEncodeInfo: ptr VideoEncodeInfoKHR;
    ): void {.lazyload("vkCmdEncodeVideoKHR", DeviceLevel),
      queues: QueueFlags{encode}.}

# VK_KHR_synchronization2
# =======================
proc cmdSetEvent2KHR*(
      commandBuffer: CommandBuffer;
      event: Event;
      pDependencyInfo: ptr DependencyInfoKHR;
    ): void {.lazyload("vkCmdSetEvent2KHR", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdResetEvent2KHR*(
      commandBuffer: CommandBuffer;
      event: Event;
      stageMask = default(PipelineStageFlags2KHR);
    ): void {.lazyload("vkCmdResetEvent2KHR", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdWaitEvents2KHR*(
      commandBuffer: CommandBuffer;
      eventCount: uint32;
      pEvents {.length: eventCount.}: arrPtr[Event];
      pDependencyInfos {.length: eventCount.}: arrPtr[DependencyInfoKHR];
    ): void {.lazyload("vkCmdWaitEvents2KHR", DeviceLevel),
      queues: QueueFlags{graphics, compute}.}
proc cmdPipelineBarrier2KHR*(
      commandBuffer: CommandBuffer;
      pDependencyInfo: ptr DependencyInfoKHR;
    ): void {.lazyload("vkCmdPipelineBarrier2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc cmdWriteTimestamp2KHR*(
      commandBuffer: CommandBuffer;
      stage = default(PipelineStageFlags2KHR);
      queryPool: QueryPool;
      query: uint32;
    ): void {.lazyload("vkCmdWriteTimestamp2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute, decode, encode}.}
proc queueSubmit2KHR*(
      queue: Queue;
      submitCount = default(uint32);
      pSubmits {.length: submitCount.}: arrPtr[SubmitInfo2KHR];
      fence = default(Fence);
    ): Result {.lazyload("vkQueueSubmit2KHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
proc cmdWriteBufferMarker2AMD*(
      commandBuffer: CommandBuffer;
      stage = default(PipelineStageFlags2KHR);
      dstBuffer: Buffer;
      dstOffset: DeviceSize;
      marker: uint32;
    ): void {.lazyload("vkCmdWriteBufferMarker2AMD", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc getQueueCheckpointData2NV*(
      queue: Queue;
      pCheckpointDataCount: ptr uint32;
      pCheckpointData {.length: pCheckpointDataCount.} = default(arrPtr[CheckpointData2NV]);
    ): void {.lazyload("vkGetQueueCheckpointData2NV", DeviceLevel).}

# VK_NV_fragment_shading_rate_enums
# =================================
proc cmdSetFragmentShadingRateEnumNV*(
      commandBuffer: CommandBuffer;
      shadingRate: FragmentShadingRateNV;
      combinerOps: FragmentShadingRateCombinerOpKHR;
    ): void {.lazyload("vkCmdSetFragmentShadingRateEnumNV", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_KHR_copy_commands2
# =====================
proc cmdCopyBuffer2KHR*(
      commandBuffer: CommandBuffer;
      pCopyBufferInfo: ptr CopyBufferInfo2KHR;
    ): void {.lazyload("vkCmdCopyBuffer2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc cmdCopyImage2KHR*(
      commandBuffer: CommandBuffer;
      pCopyImageInfo: ptr CopyImageInfo2KHR;
    ): void {.lazyload("vkCmdCopyImage2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc cmdCopyBufferToImage2KHR*(
      commandBuffer: CommandBuffer;
      pCopyBufferToImageInfo: ptr CopyBufferToImageInfo2KHR;
    ): void {.lazyload("vkCmdCopyBufferToImage2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc cmdCopyImageToBuffer2KHR*(
      commandBuffer: CommandBuffer;
      pCopyImageToBufferInfo: ptr CopyImageToBufferInfo2KHR;
    ): void {.lazyload("vkCmdCopyImageToBuffer2KHR", DeviceLevel),
      queues: QueueFlags{transfer, graphics, compute}.}
proc cmdBlitImage2KHR*(
      commandBuffer: CommandBuffer;
      pBlitImageInfo: ptr BlitImageInfo2KHR;
    ): void {.lazyload("vkCmdBlitImage2KHR", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdResolveImage2KHR*(
      commandBuffer: CommandBuffer;
      pResolveImageInfo: ptr ResolveImageInfo2KHR;
    ): void {.lazyload("vkCmdResolveImage2KHR", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_NV_acquire_winrt_display
# ===========================
proc acquireWinrtDisplayNV*(
      physicalDevice: PhysicalDevice;
      display: DisplayKHR;
    ): Result {.lazyload("vkAcquireWinrtDisplayNV", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorDeviceLost, Result.errorInitializationFailed].}
proc getWinrtDisplayNV*(
      physicalDevice: PhysicalDevice;
      deviceRelativeId: uint32;
      pDisplay: ptr DisplayKHR;
    ): Result {.lazyload("vkGetWinrtDisplayNV", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorDeviceLost, Result.errorInitializationFailed].}

# VK_EXT_vertex_input_dynamic_state
# =================================
proc cmdSetVertexInputEXT*(
      commandBuffer: CommandBuffer;
      vertexBindingDescriptionCount = default(uint32);
      pVertexBindingDescriptions {.length: vertexBindingDescriptionCount.}: arrPtr[VertexInputBindingDescription2EXT];
      vertexAttributeDescriptionCount = default(uint32);
      pVertexAttributeDescriptions {.length: vertexAttributeDescriptionCount.}: arrPtr[VertexInputAttributeDescription2EXT];
    ): void {.lazyload("vkCmdSetVertexInputEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_FUCHSIA_external_memory
# ==========================
proc getMemoryZirconHandleFUCHSIA*(
      device: Device;
      pGetZirconHandleInfo: ptr MemoryGetZirconHandleInfoFUCHSIA;
      pZirconHandle: ptr zx_handle_t;
    ): Result {.lazyload("vkGetMemoryZirconHandleFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc getMemoryZirconHandlePropertiesFUCHSIA*(
      device: Device;
      handleType: ExternalMemoryHandleTypeFlagBits;
      zirconHandle: zx_handle_t;
      pMemoryZirconHandleProperties: ptr MemoryZirconHandlePropertiesFUCHSIA;
    ): Result {.lazyload("vkGetMemoryZirconHandlePropertiesFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInvalidExternalHandle].}

# VK_FUCHSIA_external_semaphore
# =============================
proc importSemaphoreZirconHandleFUCHSIA*(
      device: Device;
      pImportSemaphoreZirconHandleInfo: ptr ImportSemaphoreZirconHandleInfoFUCHSIA;
    ): Result {.lazyload("vkImportSemaphoreZirconHandleFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getSemaphoreZirconHandleFUCHSIA*(
      device: Device;
      pGetZirconHandleInfo: ptr SemaphoreGetZirconHandleInfoFUCHSIA;
      pZirconHandle: ptr zx_handle_t;
    ): Result {.lazyload("vkGetSemaphoreZirconHandleFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_FUCHSIA_buffer_collection
# ============================
proc createBufferCollectionFUCHSIA*(
      device: Device;
      pCreateInfo: ptr BufferCollectionCreateInfoFUCHSIA;
      pAllocator = default(ptr AllocationCallbacks);
      pCollection: ptr BufferCollectionFUCHSIA;
    ): Result {.lazyload("vkCreateBufferCollectionFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle, Result.errorInitializationFailed].}
proc setBufferCollectionImageConstraintsFUCHSIA*(
      device: Device;
      collection: BufferCollectionFUCHSIA;
      pImageConstraintsInfo: ptr ImageConstraintsInfoFUCHSIA;
    ): Result {.lazyload("vkSetBufferCollectionImageConstraintsFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed, Result.errorOutOfHostMemory, Result.errorFormatNotSupported].}
proc setBufferCollectionBufferConstraintsFUCHSIA*(
      device: Device;
      collection: BufferCollectionFUCHSIA;
      pBufferConstraintsInfo: ptr BufferConstraintsInfoFUCHSIA;
    ): Result {.lazyload("vkSetBufferCollectionBufferConstraintsFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInitializationFailed, Result.errorOutOfHostMemory, Result.errorFormatNotSupported].}
proc destroyBufferCollectionFUCHSIA*(
      device: Device;
      collection: BufferCollectionFUCHSIA;
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyBufferCollectionFUCHSIA", DeviceLevel).}
proc getBufferCollectionPropertiesFUCHSIA*(
      device: Device;
      collection: BufferCollectionFUCHSIA;
      pProperties: ptr BufferCollectionPropertiesFUCHSIA;
    ): Result {.lazyload("vkGetBufferCollectionPropertiesFUCHSIA", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInitializationFailed].}

# VK_HUAWEI_subpass_shading
# =========================
proc getDeviceSubpassShadingMaxWorkgroupSizeHUAWEI*(
      device: Device;
      renderpass: RenderPass;
      pMaxWorkgroupSize: ptr Extent2D;
    ): Result {.lazyload("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", DeviceLevel),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorSurfaceLostKhr].}
proc cmdSubpassShadingHUAWEI*(
      commandBuffer: CommandBuffer;
    ): void {.lazyload("vkCmdSubpassShadingHUAWEI", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_HUAWEI_invocation_mask
# =========================
proc cmdBindInvocationMaskHUAWEI*(
      commandBuffer: CommandBuffer;
      imageView = default(ImageView);
      imageLayout: ImageLayout;
    ): void {.lazyload("vkCmdBindInvocationMaskHUAWEI", DeviceLevel),
      queues: QueueFlags{compute}.}

# VK_NV_external_memory_rdma
# ==========================
proc getMemoryRemoteAddressNV*(
      device: Device;
      pMemoryGetRemoteAddressInfo: ptr MemoryGetRemoteAddressInfoNV;
      pAddress: ptr RemoteAddressNV;
    ): Result {.lazyload("vkGetMemoryRemoteAddressNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorInvalidExternalHandle].}

# VK_EXT_extended_dynamic_state2
# ==============================
proc cmdSetPatchControlPointsEXT*(
      commandBuffer: CommandBuffer;
      patchControlPoints: uint32;
    ): void {.lazyload("vkCmdSetPatchControlPointsEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetRasterizerDiscardEnableEXT*(
      commandBuffer: CommandBuffer;
      rasterizerDiscardEnable: Bool32;
    ): void {.lazyload("vkCmdSetRasterizerDiscardEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetDepthBiasEnableEXT*(
      commandBuffer: CommandBuffer;
      depthBiasEnable: Bool32;
    ): void {.lazyload("vkCmdSetDepthBiasEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetLogicOpEXT*(
      commandBuffer: CommandBuffer;
      logicOp: LogicOp;
    ): void {.lazyload("vkCmdSetLogicOpEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdSetPrimitiveRestartEnableEXT*(
      commandBuffer: CommandBuffer;
      primitiveRestartEnable: Bool32;
    ): void {.lazyload("vkCmdSetPrimitiveRestartEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_QNX_screen_surface
# =====================
proc createScreenSurfaceQNX*(
      instance: Instance;
      pCreateInfo: ptr ScreenSurfaceCreateInfoQNX;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateScreenSurfaceQNX", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPhysicalDeviceScreenPresentationSupportQNX*(
      physicalDevice: PhysicalDevice;
      queueFamilyIndex: uint32;
      window: ptr screen_window;
    ): Bool32 {.lazyload("vkGetPhysicalDeviceScreenPresentationSupportQNX", InstanceLevel).}

# VK_EXT_color_write_enable
# =========================
proc cmdSetColorWriteEnableEXT*(
      commandBuffer: CommandBuffer;
      attachmentCount: uint32;
      pColorWriteEnables {.length: attachmentCount.}: arrPtr[Bool32];
    ): void {.lazyload("vkCmdSetColorWriteEnableEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_multi_draw
# =================
proc cmdDrawMultiEXT*(
      commandBuffer: CommandBuffer;
      drawCount = default(uint32);
      pVertexInfo {.length: drawCount.}: arrPtr[MultiDrawInfoEXT];
      instanceCount: uint32;
      firstInstance: uint32;
      stride: uint32;
    ): void {.lazyload("vkCmdDrawMultiEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}
proc cmdDrawMultiIndexedEXT*(
      commandBuffer: CommandBuffer;
      drawCount = default(uint32);
      pIndexInfo {.length: drawCount.}: arrPtr[MultiDrawIndexedInfoEXT];
      instanceCount: uint32;
      firstInstance: uint32;
      stride: uint32;
      pVertexOffset = default(ptr int32);
    ): void {.lazyload("vkCmdDrawMultiIndexedEXT", DeviceLevel),
      queues: QueueFlags{graphics}.}

# VK_EXT_pageable_device_local_memory
# ===================================
proc setDeviceMemoryPriorityEXT*(
      device: Device;
      memory: DeviceMemory;
      priority: float32;
    ): void {.lazyload("vkSetDeviceMemoryPriorityEXT", DeviceLevel).}

# VK_KHR_maintenance4
# ===================
proc getDeviceBufferMemoryRequirementsKHR*(
      device: Device;
      pInfo: ptr DeviceBufferMemoryRequirementsKHR;
      pMemoryRequirements: ptr MemoryRequirements2;
    ): void {.lazyload("vkGetDeviceBufferMemoryRequirementsKHR", DeviceLevel).}
proc getDeviceImageMemoryRequirementsKHR*(
      device: Device;
      pInfo: ptr DeviceImageMemoryRequirementsKHR;
      pMemoryRequirements: ptr MemoryRequirements2;
    ): void {.lazyload("vkGetDeviceImageMemoryRequirementsKHR", DeviceLevel).}
proc getDeviceImageSparseMemoryRequirementsKHR*(
      device: Device;
      pInfo: ptr DeviceImageMemoryRequirementsKHR;
      pSparseMemoryRequirementCount: ptr uint32;
      pSparseMemoryRequirements {.length: pSparseMemoryRequirementCount.} = default(arrPtr[SparseImageMemoryRequirements2]);
    ): void {.lazyload("vkGetDeviceImageSparseMemoryRequirementsKHR", DeviceLevel).}


proc loadAllVK_KHR_surface*(instance: Instance) = instance.loadCommands:
  destroySurfaceKHR
  getPhysicalDeviceSurfaceSupportKHR
  getPhysicalDeviceSurfaceCapabilitiesKHR
  getPhysicalDeviceSurfaceFormatsKHR
  getPhysicalDeviceSurfacePresentModesKHR
proc loadAllVK_KHR_swapchain*(instance: Instance) = instance.loadCommands:
  createSwapchainKHR
  destroySwapchainKHR
  getSwapchainImagesKHR
  acquireNextImageKHR
  queuePresentKHR
  getDeviceGroupPresentCapabilitiesKHR
  getDeviceGroupSurfacePresentModesKHR
  getPhysicalDevicePresentRectanglesKHR
  acquireNextImage2KHR
proc loadAllVK_KHR_display*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceDisplayPropertiesKHR
  getPhysicalDeviceDisplayPlanePropertiesKHR
  getDisplayPlaneSupportedDisplaysKHR
  getDisplayModePropertiesKHR
  createDisplayModeKHR
  getDisplayPlaneCapabilitiesKHR
  createDisplayPlaneSurfaceKHR
proc loadAllVK_KHR_display_swapchain*(instance: Instance) = instance.loadCommands:
  createSharedSwapchainsKHR
proc loadAllVK_KHR_win32_surface*(instance: Instance) = instance.loadCommands:
  createWin32SurfaceKHR
  getPhysicalDeviceWin32PresentationSupportKHR
proc loadAllVK_EXT_debug_report*(instance: Instance) = instance.loadCommands:
  createDebugReportCallbackEXT
  destroyDebugReportCallbackEXT
  debugReportMessageEXT
proc loadAllVK_EXT_debug_marker*(instance: Instance) = instance.loadCommands:
  debugMarkerSetObjectTagEXT
  debugMarkerSetObjectNameEXT
  cmdDebugMarkerBeginEXT
  cmdDebugMarkerEndEXT
  cmdDebugMarkerInsertEXT
proc loadAllVK_KHR_video_queue*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceVideoCapabilitiesKHR
  getPhysicalDeviceVideoFormatPropertiesKHR
  createVideoSessionKHR
  destroyVideoSessionKHR
  getVideoSessionMemoryRequirementsKHR
  bindVideoSessionMemoryKHR
  createVideoSessionParametersKHR
  updateVideoSessionParametersKHR
  destroyVideoSessionParametersKHR
  cmdBeginVideoCodingKHR
  cmdEndVideoCodingKHR
  cmdControlVideoCodingKHR
proc loadAllVK_KHR_video_decode_queue*(instance: Instance) = instance.loadCommands:
  cmdDecodeVideoKHR
proc loadAllVK_EXT_transform_feedback*(instance: Instance) = instance.loadCommands:
  cmdBindTransformFeedbackBuffersEXT
  cmdBeginTransformFeedbackEXT
  cmdEndTransformFeedbackEXT
  cmdBeginQueryIndexedEXT
  cmdEndQueryIndexedEXT
  cmdDrawIndirectByteCountEXT
proc loadAllVK_NVX_binary_import*(instance: Instance) = instance.loadCommands:
  createCuModuleNVX
  createCuFunctionNVX
  destroyCuModuleNVX
  destroyCuFunctionNVX
  cmdCuLaunchKernelNVX
proc loadAllVK_NVX_image_view_handle*(instance: Instance) = instance.loadCommands:
  getImageViewHandleNVX
  getImageViewAddressNVX
proc loadAllVK_AMD_shader_info*(instance: Instance) = instance.loadCommands:
  getShaderInfoAMD
proc loadAllVK_KHR_dynamic_rendering*(instance: Instance) = instance.loadCommands:
  cmdBeginRenderingKHR
  cmdEndRenderingKHR
proc loadAllVK_GGP_stream_descriptor_surface*(instance: Instance) = instance.loadCommands:
  createStreamDescriptorSurfaceGGP
proc loadAllVK_NV_external_memory_capabilities*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceExternalImageFormatPropertiesNV
proc loadAllVK_NV_external_memory_win32*(instance: Instance) = instance.loadCommands:
  getMemoryWin32HandleNV
proc loadAllVK_KHR_device_group*(instance: Instance) = instance.loadCommands:
  getDeviceGroupPresentCapabilitiesKHR
  getDeviceGroupSurfacePresentModesKHR
  getPhysicalDevicePresentRectanglesKHR
  acquireNextImage2KHR
proc loadAllVK_NN_vi_surface*(instance: Instance) = instance.loadCommands:
  createViSurfaceNN
proc loadAllVK_KHR_external_memory_win32*(instance: Instance) = instance.loadCommands:
  getMemoryWin32HandleKHR
  getMemoryWin32HandlePropertiesKHR
proc loadAllVK_KHR_external_memory_fd*(instance: Instance) = instance.loadCommands:
  getMemoryFdKHR
  getMemoryFdPropertiesKHR
proc loadAllVK_KHR_external_semaphore_win32*(instance: Instance) = instance.loadCommands:
  importSemaphoreWin32HandleKHR
  getSemaphoreWin32HandleKHR
proc loadAllVK_KHR_external_semaphore_fd*(instance: Instance) = instance.loadCommands:
  importSemaphoreFdKHR
  getSemaphoreFdKHR
proc loadAllVK_KHR_push_descriptor*(instance: Instance) = instance.loadCommands:
  cmdPushDescriptorSetKHR
  cmdPushDescriptorSetWithTemplateKHR
  cmdPushDescriptorSetWithTemplateKHR
proc loadAllVK_EXT_conditional_rendering*(instance: Instance) = instance.loadCommands:
  cmdBeginConditionalRenderingEXT
  cmdEndConditionalRenderingEXT
proc loadAllVK_KHR_descriptor_update_template*(instance: Instance) = instance.loadCommands:
  cmdPushDescriptorSetWithTemplateKHR
proc loadAllVK_NV_clip_space_w_scaling*(instance: Instance) = instance.loadCommands:
  cmdSetViewportWScalingNV
proc loadAllVK_EXT_direct_mode_display*(instance: Instance) = instance.loadCommands:
  releaseDisplayEXT
proc loadAllVK_EXT_display_surface_counter*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfaceCapabilities2EXT
proc loadAllVK_EXT_display_control*(instance: Instance) = instance.loadCommands:
  displayPowerControlEXT
  registerDeviceEventEXT
  registerDisplayEventEXT
  getSwapchainCounterEXT
proc loadAllVK_GOOGLE_display_timing*(instance: Instance) = instance.loadCommands:
  getRefreshCycleDurationGOOGLE
  getPastPresentationTimingGOOGLE
proc loadAllVK_EXT_discard_rectangles*(instance: Instance) = instance.loadCommands:
  cmdSetDiscardRectangleEXT
proc loadAllVK_EXT_hdr_metadata*(instance: Instance) = instance.loadCommands:
  setHdrMetadataEXT
proc loadAllVK_KHR_shared_presentable_image*(instance: Instance) = instance.loadCommands:
  getSwapchainStatusKHR
proc loadAllVK_KHR_external_fence_win32*(instance: Instance) = instance.loadCommands:
  importFenceWin32HandleKHR
  getFenceWin32HandleKHR
proc loadAllVK_KHR_external_fence_fd*(instance: Instance) = instance.loadCommands:
  importFenceFdKHR
  getFenceFdKHR
proc loadAllVK_KHR_performance_query*(instance: Instance) = instance.loadCommands:
  enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
  getPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
  acquireProfilingLockKHR
  releaseProfilingLockKHR
proc loadAllVK_KHR_get_surface_capabilities2*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfaceCapabilities2KHR
  getPhysicalDeviceSurfaceFormats2KHR
proc loadAllVK_KHR_get_display_properties2*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceDisplayProperties2KHR
  getPhysicalDeviceDisplayPlaneProperties2KHR
  getDisplayModeProperties2KHR
  getDisplayPlaneCapabilities2KHR
proc loadAllVK_MVK_macos_surface*(instance: Instance) = instance.loadCommands:
  createMacOSSurfaceMVK
proc loadAllVK_EXT_debug_utils*(instance: Instance) = instance.loadCommands:
  setDebugUtilsObjectNameEXT
  setDebugUtilsObjectTagEXT
  queueBeginDebugUtilsLabelEXT
  queueEndDebugUtilsLabelEXT
  queueInsertDebugUtilsLabelEXT
  cmdBeginDebugUtilsLabelEXT
  cmdEndDebugUtilsLabelEXT
  cmdInsertDebugUtilsLabelEXT
  createDebugUtilsMessengerEXT
  destroyDebugUtilsMessengerEXT
  submitDebugUtilsMessageEXT
proc loadAllVK_EXT_sample_locations*(instance: Instance) = instance.loadCommands:
  cmdSetSampleLocationsEXT
  getPhysicalDeviceMultisamplePropertiesEXT
proc loadAllVK_KHR_acceleration_structure*(instance: Instance) = instance.loadCommands:
  createAccelerationStructureKHR
  destroyAccelerationStructureKHR
  cmdBuildAccelerationStructuresKHR
  cmdBuildAccelerationStructuresIndirectKHR
  buildAccelerationStructuresKHR
  copyAccelerationStructureKHR
  copyAccelerationStructureToMemoryKHR
  copyMemoryToAccelerationStructureKHR
  writeAccelerationStructuresPropertiesKHR
  cmdCopyAccelerationStructureKHR
  cmdCopyAccelerationStructureToMemoryKHR
  cmdCopyMemoryToAccelerationStructureKHR
  getAccelerationStructureDeviceAddressKHR
  cmdWriteAccelerationStructuresPropertiesKHR
  getDeviceAccelerationStructureCompatibilityKHR
  getAccelerationStructureBuildSizesKHR
proc loadAllVK_KHR_ray_tracing_pipeline*(instance: Instance) = instance.loadCommands:
  cmdTraceRaysKHR
  createRayTracingPipelinesKHR
  getRayTracingShaderGroupHandlesKHR
  getRayTracingCaptureReplayShaderGroupHandlesKHR
  cmdTraceRaysIndirectKHR
  getRayTracingShaderGroupStackSizeKHR
  cmdSetRayTracingPipelineStackSizeKHR
proc loadAllVK_EXT_image_drm_format_modifier*(instance: Instance) = instance.loadCommands:
  getImageDrmFormatModifierPropertiesEXT
proc loadAllVK_EXT_validation_cache*(instance: Instance) = instance.loadCommands:
  createValidationCacheEXT
  destroyValidationCacheEXT
  mergeValidationCachesEXT
  getValidationCacheDataEXT
proc loadAllVK_NV_shading_rate_image*(instance: Instance) = instance.loadCommands:
  cmdBindShadingRateImageNV
  cmdSetViewportShadingRatePaletteNV
  cmdSetCoarseSampleOrderNV
proc loadAllVK_NV_ray_tracing*(instance: Instance) = instance.loadCommands:
  createAccelerationStructureNV
  destroyAccelerationStructureNV
  getAccelerationStructureMemoryRequirementsNV
  bindAccelerationStructureMemoryNV
  cmdBuildAccelerationStructureNV
  cmdCopyAccelerationStructureNV
  cmdTraceRaysNV
  createRayTracingPipelinesNV
  getAccelerationStructureHandleNV
  cmdWriteAccelerationStructuresPropertiesNV
  compileDeferredNV
proc loadAllVK_EXT_external_memory_host*(instance: Instance) = instance.loadCommands:
  getMemoryHostPointerPropertiesEXT
proc loadAllVK_AMD_buffer_marker*(instance: Instance) = instance.loadCommands:
  cmdWriteBufferMarkerAMD
proc loadAllVK_EXT_calibrated_timestamps*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceCalibrateableTimeDomainsEXT
  getCalibratedTimestampsEXT
proc loadAllVK_NV_mesh_shader*(instance: Instance) = instance.loadCommands:
  cmdDrawMeshTasksNV
  cmdDrawMeshTasksIndirectNV
  cmdDrawMeshTasksIndirectCountNV
proc loadAllVK_NV_scissor_exclusive*(instance: Instance) = instance.loadCommands:
  cmdSetExclusiveScissorNV
proc loadAllVK_NV_device_diagnostic_checkpoints*(instance: Instance) = instance.loadCommands:
  cmdSetCheckpointNV
  getQueueCheckpointDataNV
proc loadAllVK_INTEL_performance_query*(instance: Instance) = instance.loadCommands:
  initializePerformanceApiINTEL
  uninitializePerformanceApiINTEL
  cmdSetPerformanceMarkerINTEL
  cmdSetPerformanceStreamMarkerINTEL
  cmdSetPerformanceOverrideINTEL
  acquirePerformanceConfigurationINTEL
  releasePerformanceConfigurationINTEL
  queueSetPerformanceConfigurationINTEL
  getPerformanceParameterINTEL
proc loadAllVK_AMD_display_native_hdr*(instance: Instance) = instance.loadCommands:
  setLocalDimmingAMD
proc loadAllVK_FUCHSIA_imagepipe_surface*(instance: Instance) = instance.loadCommands:
  createImagePipeSurfaceFUCHSIA
proc loadAllVK_KHR_fragment_shading_rate*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceFragmentShadingRatesKHR
  cmdSetFragmentShadingRateKHR
proc loadAllVK_EXT_tooling_info*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceToolPropertiesEXT
proc loadAllVK_KHR_present_wait*(instance: Instance) = instance.loadCommands:
  waitForPresentKHR
proc loadAllVK_NV_cooperative_matrix*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceCooperativeMatrixPropertiesNV
proc loadAllVK_NV_coverage_reduction_mode*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
proc loadAllVK_EXT_full_screen_exclusive*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfacePresentModes2EXT
  acquireFullScreenExclusiveModeEXT
  releaseFullScreenExclusiveModeEXT
  getDeviceGroupSurfacePresentModes2EXT
  getDeviceGroupSurfacePresentModes2EXT
proc loadAllVK_EXT_headless_surface*(instance: Instance) = instance.loadCommands:
  createHeadlessSurfaceEXT
proc loadAllVK_EXT_line_rasterization*(instance: Instance) = instance.loadCommands:
  cmdSetLineStippleEXT
proc loadAllVK_EXT_extended_dynamic_state*(instance: Instance) = instance.loadCommands:
  cmdSetCullModeEXT
  cmdSetFrontFaceEXT
  cmdSetPrimitiveTopologyEXT
  cmdSetViewportWithCountEXT
  cmdSetScissorWithCountEXT
  cmdBindVertexBuffers2EXT
  cmdSetDepthTestEnableEXT
  cmdSetDepthWriteEnableEXT
  cmdSetDepthCompareOpEXT
  cmdSetDepthBoundsTestEnableEXT
  cmdSetStencilTestEnableEXT
  cmdSetStencilOpEXT
proc loadAllVK_KHR_deferred_host_operations*(instance: Instance) = instance.loadCommands:
  createDeferredOperationKHR
  destroyDeferredOperationKHR
  getDeferredOperationMaxConcurrencyKHR
  getDeferredOperationResultKHR
  deferredOperationJoinKHR
proc loadAllVK_KHR_pipeline_executable_properties*(instance: Instance) = instance.loadCommands:
  getPipelineExecutablePropertiesKHR
  getPipelineExecutableStatisticsKHR
  getPipelineExecutableInternalRepresentationsKHR
proc loadAllVK_NV_device_generated_commands*(instance: Instance) = instance.loadCommands:
  getGeneratedCommandsMemoryRequirementsNV
  cmdPreprocessGeneratedCommandsNV
  cmdExecuteGeneratedCommandsNV
  cmdBindPipelineShaderGroupNV
  createIndirectCommandsLayoutNV
  destroyIndirectCommandsLayoutNV
proc loadAllVK_EXT_acquire_drm_display*(instance: Instance) = instance.loadCommands:
  acquireDrmDisplayEXT
  getDrmDisplayEXT
proc loadAllVK_EXT_private_data*(instance: Instance) = instance.loadCommands:
  createPrivateDataSlotEXT
  destroyPrivateDataSlotEXT
  setPrivateDataEXT
  getPrivateDataEXT
proc loadAllVK_KHR_video_encode_queue*(instance: Instance) = instance.loadCommands:
  cmdEncodeVideoKHR
proc loadAllVK_KHR_synchronization2*(instance: Instance) = instance.loadCommands:
  cmdSetEvent2KHR
  cmdResetEvent2KHR
  cmdWaitEvents2KHR
  cmdPipelineBarrier2KHR
  cmdWriteTimestamp2KHR
  queueSubmit2KHR
  cmdWriteBufferMarker2AMD
  getQueueCheckpointData2NV
proc loadAllVK_NV_fragment_shading_rate_enums*(instance: Instance) = instance.loadCommands:
  cmdSetFragmentShadingRateEnumNV
proc loadAllVK_KHR_copy_commands2*(instance: Instance) = instance.loadCommands:
  cmdCopyBuffer2KHR
  cmdCopyImage2KHR
  cmdCopyBufferToImage2KHR
  cmdCopyImageToBuffer2KHR
  cmdBlitImage2KHR
  cmdResolveImage2KHR
proc loadAllVK_NV_acquire_winrt_display*(instance: Instance) = instance.loadCommands:
  acquireWinrtDisplayNV
  getWinrtDisplayNV
proc loadAllVK_EXT_vertex_input_dynamic_state*(instance: Instance) = instance.loadCommands:
  cmdSetVertexInputEXT
proc loadAllVK_FUCHSIA_external_memory*(instance: Instance) = instance.loadCommands:
  getMemoryZirconHandleFUCHSIA
  getMemoryZirconHandlePropertiesFUCHSIA
proc loadAllVK_FUCHSIA_external_semaphore*(instance: Instance) = instance.loadCommands:
  importSemaphoreZirconHandleFUCHSIA
  getSemaphoreZirconHandleFUCHSIA
proc loadAllVK_FUCHSIA_buffer_collection*(instance: Instance) = instance.loadCommands:
  createBufferCollectionFUCHSIA
  setBufferCollectionImageConstraintsFUCHSIA
  setBufferCollectionBufferConstraintsFUCHSIA
  destroyBufferCollectionFUCHSIA
  getBufferCollectionPropertiesFUCHSIA
proc loadAllVK_HUAWEI_subpass_shading*(instance: Instance) = instance.loadCommands:
  getDeviceSubpassShadingMaxWorkgroupSizeHUAWEI
  cmdSubpassShadingHUAWEI
proc loadAllVK_HUAWEI_invocation_mask*(instance: Instance) = instance.loadCommands:
  cmdBindInvocationMaskHUAWEI
proc loadAllVK_NV_external_memory_rdma*(instance: Instance) = instance.loadCommands:
  getMemoryRemoteAddressNV
proc loadAllVK_EXT_extended_dynamic_state2*(instance: Instance) = instance.loadCommands:
  cmdSetPatchControlPointsEXT
  cmdSetRasterizerDiscardEnableEXT
  cmdSetDepthBiasEnableEXT
  cmdSetLogicOpEXT
  cmdSetPrimitiveRestartEnableEXT
proc loadAllVK_QNX_screen_surface*(instance: Instance) = instance.loadCommands:
  createScreenSurfaceQNX
  getPhysicalDeviceScreenPresentationSupportQNX
proc loadAllVK_EXT_color_write_enable*(instance: Instance) = instance.loadCommands:
  cmdSetColorWriteEnableEXT
proc loadAllVK_EXT_multi_draw*(instance: Instance) = instance.loadCommands:
  cmdDrawMultiEXT
  cmdDrawMultiIndexedEXT
proc loadAllVK_EXT_pageable_device_local_memory*(instance: Instance) = instance.loadCommands:
  setDeviceMemoryPriorityEXT
proc loadAllVK_KHR_maintenance4*(instance: Instance) = instance.loadCommands:
  getDeviceBufferMemoryRequirementsKHR
  getDeviceImageMemoryRequirementsKHR
  getDeviceImageSparseMemoryRequirementsKHR
proc loadVK_KHR_surface*(instance: Instance) = instance.loadCommands:
  destroySurfaceKHR
  getPhysicalDeviceSurfaceSupportKHR
  getPhysicalDeviceSurfaceCapabilitiesKHR
  getPhysicalDeviceSurfaceFormatsKHR
  getPhysicalDeviceSurfacePresentModesKHR
proc loadVK_KHR_swapchain*(instance: Instance) = instance.loadCommands:
  getPhysicalDevicePresentRectanglesKHR
proc loadVK_KHR_display*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceDisplayPropertiesKHR
  getPhysicalDeviceDisplayPlanePropertiesKHR
  getDisplayPlaneSupportedDisplaysKHR
  getDisplayModePropertiesKHR
  createDisplayModeKHR
  getDisplayPlaneCapabilitiesKHR
  createDisplayPlaneSurfaceKHR
proc loadVK_KHR_win32_surface*(instance: Instance) = instance.loadCommands:
  createWin32SurfaceKHR
  getPhysicalDeviceWin32PresentationSupportKHR
proc loadVK_EXT_debug_report*(instance: Instance) = instance.loadCommands:
  createDebugReportCallbackEXT
  destroyDebugReportCallbackEXT
  debugReportMessageEXT
proc loadVK_KHR_video_queue*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceVideoCapabilitiesKHR
  getPhysicalDeviceVideoFormatPropertiesKHR
proc loadVK_GGP_stream_descriptor_surface*(instance: Instance) = instance.loadCommands:
  createStreamDescriptorSurfaceGGP
proc loadVK_NV_external_memory_capabilities*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceExternalImageFormatPropertiesNV
proc loadVK_KHR_device_group*(instance: Instance) = instance.loadCommands:
  getPhysicalDevicePresentRectanglesKHR
proc loadVK_NN_vi_surface*(instance: Instance) = instance.loadCommands:
  createViSurfaceNN
proc loadVK_EXT_direct_mode_display*(instance: Instance) = instance.loadCommands:
  releaseDisplayEXT
proc loadVK_EXT_display_surface_counter*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfaceCapabilities2EXT
proc loadVK_KHR_performance_query*(instance: Instance) = instance.loadCommands:
  enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
  getPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
proc loadVK_KHR_get_surface_capabilities2*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfaceCapabilities2KHR
  getPhysicalDeviceSurfaceFormats2KHR
proc loadVK_KHR_get_display_properties2*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceDisplayProperties2KHR
  getPhysicalDeviceDisplayPlaneProperties2KHR
  getDisplayModeProperties2KHR
  getDisplayPlaneCapabilities2KHR
proc loadVK_MVK_macos_surface*(instance: Instance) = instance.loadCommands:
  createMacOSSurfaceMVK
proc loadVK_EXT_debug_utils*(instance: Instance) = instance.loadCommands:
  createDebugUtilsMessengerEXT
  destroyDebugUtilsMessengerEXT
  submitDebugUtilsMessageEXT
proc loadVK_EXT_sample_locations*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceMultisamplePropertiesEXT
proc loadVK_EXT_calibrated_timestamps*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceCalibrateableTimeDomainsEXT
proc loadVK_FUCHSIA_imagepipe_surface*(instance: Instance) = instance.loadCommands:
  createImagePipeSurfaceFUCHSIA
proc loadVK_KHR_fragment_shading_rate*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceFragmentShadingRatesKHR
proc loadVK_EXT_tooling_info*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceToolPropertiesEXT
proc loadVK_NV_cooperative_matrix*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceCooperativeMatrixPropertiesNV
proc loadVK_NV_coverage_reduction_mode*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
proc loadVK_EXT_full_screen_exclusive*(instance: Instance) = instance.loadCommands:
  getPhysicalDeviceSurfacePresentModes2EXT
proc loadVK_EXT_headless_surface*(instance: Instance) = instance.loadCommands:
  createHeadlessSurfaceEXT
proc loadVK_EXT_acquire_drm_display*(instance: Instance) = instance.loadCommands:
  acquireDrmDisplayEXT
  getDrmDisplayEXT
proc loadVK_NV_acquire_winrt_display*(instance: Instance) = instance.loadCommands:
  acquireWinrtDisplayNV
  getWinrtDisplayNV
proc loadVK_QNX_screen_surface*(instance: Instance) = instance.loadCommands:
  createScreenSurfaceQNX
  getPhysicalDeviceScreenPresentationSupportQNX
proc loadVK_KHR_swapchain*(device: Device) = device.loadCommands:
  createSwapchainKHR
  destroySwapchainKHR
  getSwapchainImagesKHR
  acquireNextImageKHR
  queuePresentKHR
  getDeviceGroupPresentCapabilitiesKHR
  getDeviceGroupSurfacePresentModesKHR
  acquireNextImage2KHR
proc loadVK_KHR_display_swapchain*(device: Device) = device.loadCommands:
  createSharedSwapchainsKHR
proc loadVK_EXT_debug_marker*(device: Device) = device.loadCommands:
  debugMarkerSetObjectTagEXT
  debugMarkerSetObjectNameEXT
  cmdDebugMarkerBeginEXT
  cmdDebugMarkerEndEXT
  cmdDebugMarkerInsertEXT
proc loadVK_KHR_video_queue*(device: Device) = device.loadCommands:
  createVideoSessionKHR
  destroyVideoSessionKHR
  getVideoSessionMemoryRequirementsKHR
  bindVideoSessionMemoryKHR
  createVideoSessionParametersKHR
  updateVideoSessionParametersKHR
  destroyVideoSessionParametersKHR
  cmdBeginVideoCodingKHR
  cmdEndVideoCodingKHR
  cmdControlVideoCodingKHR
proc loadVK_KHR_video_decode_queue*(device: Device) = device.loadCommands:
  cmdDecodeVideoKHR
proc loadVK_EXT_transform_feedback*(device: Device) = device.loadCommands:
  cmdBindTransformFeedbackBuffersEXT
  cmdBeginTransformFeedbackEXT
  cmdEndTransformFeedbackEXT
  cmdBeginQueryIndexedEXT
  cmdEndQueryIndexedEXT
  cmdDrawIndirectByteCountEXT
proc loadVK_NVX_binary_import*(device: Device) = device.loadCommands:
  createCuModuleNVX
  createCuFunctionNVX
  destroyCuModuleNVX
  destroyCuFunctionNVX
  cmdCuLaunchKernelNVX
proc loadVK_NVX_image_view_handle*(device: Device) = device.loadCommands:
  getImageViewHandleNVX
  getImageViewAddressNVX
proc loadVK_AMD_shader_info*(device: Device) = device.loadCommands:
  getShaderInfoAMD
proc loadVK_KHR_dynamic_rendering*(device: Device) = device.loadCommands:
  cmdBeginRenderingKHR
  cmdEndRenderingKHR
proc loadVK_NV_external_memory_win32*(device: Device) = device.loadCommands:
  getMemoryWin32HandleNV
proc loadVK_KHR_device_group*(device: Device) = device.loadCommands:
  getDeviceGroupPresentCapabilitiesKHR
  getDeviceGroupSurfacePresentModesKHR
  acquireNextImage2KHR
proc loadVK_KHR_external_memory_win32*(device: Device) = device.loadCommands:
  getMemoryWin32HandleKHR
  getMemoryWin32HandlePropertiesKHR
proc loadVK_KHR_external_memory_fd*(device: Device) = device.loadCommands:
  getMemoryFdKHR
  getMemoryFdPropertiesKHR
proc loadVK_KHR_external_semaphore_win32*(device: Device) = device.loadCommands:
  importSemaphoreWin32HandleKHR
  getSemaphoreWin32HandleKHR
proc loadVK_KHR_external_semaphore_fd*(device: Device) = device.loadCommands:
  importSemaphoreFdKHR
  getSemaphoreFdKHR
proc loadVK_KHR_push_descriptor*(device: Device) = device.loadCommands:
  cmdPushDescriptorSetKHR
  cmdPushDescriptorSetWithTemplateKHR
  cmdPushDescriptorSetWithTemplateKHR
proc loadVK_EXT_conditional_rendering*(device: Device) = device.loadCommands:
  cmdBeginConditionalRenderingEXT
  cmdEndConditionalRenderingEXT
proc loadVK_KHR_descriptor_update_template*(device: Device) = device.loadCommands:
  cmdPushDescriptorSetWithTemplateKHR
proc loadVK_NV_clip_space_w_scaling*(device: Device) = device.loadCommands:
  cmdSetViewportWScalingNV
proc loadVK_EXT_display_control*(device: Device) = device.loadCommands:
  displayPowerControlEXT
  registerDeviceEventEXT
  registerDisplayEventEXT
  getSwapchainCounterEXT
proc loadVK_GOOGLE_display_timing*(device: Device) = device.loadCommands:
  getRefreshCycleDurationGOOGLE
  getPastPresentationTimingGOOGLE
proc loadVK_EXT_discard_rectangles*(device: Device) = device.loadCommands:
  cmdSetDiscardRectangleEXT
proc loadVK_EXT_hdr_metadata*(device: Device) = device.loadCommands:
  setHdrMetadataEXT
proc loadVK_KHR_shared_presentable_image*(device: Device) = device.loadCommands:
  getSwapchainStatusKHR
proc loadVK_KHR_external_fence_win32*(device: Device) = device.loadCommands:
  importFenceWin32HandleKHR
  getFenceWin32HandleKHR
proc loadVK_KHR_external_fence_fd*(device: Device) = device.loadCommands:
  importFenceFdKHR
  getFenceFdKHR
proc loadVK_KHR_performance_query*(device: Device) = device.loadCommands:
  acquireProfilingLockKHR
  releaseProfilingLockKHR
proc loadVK_EXT_debug_utils*(device: Device) = device.loadCommands:
  setDebugUtilsObjectNameEXT
  setDebugUtilsObjectTagEXT
  queueBeginDebugUtilsLabelEXT
  queueEndDebugUtilsLabelEXT
  queueInsertDebugUtilsLabelEXT
  cmdBeginDebugUtilsLabelEXT
  cmdEndDebugUtilsLabelEXT
  cmdInsertDebugUtilsLabelEXT
proc loadVK_EXT_sample_locations*(device: Device) = device.loadCommands:
  cmdSetSampleLocationsEXT
proc loadVK_KHR_acceleration_structure*(device: Device) = device.loadCommands:
  createAccelerationStructureKHR
  destroyAccelerationStructureKHR
  cmdBuildAccelerationStructuresKHR
  cmdBuildAccelerationStructuresIndirectKHR
  buildAccelerationStructuresKHR
  copyAccelerationStructureKHR
  copyAccelerationStructureToMemoryKHR
  copyMemoryToAccelerationStructureKHR
  writeAccelerationStructuresPropertiesKHR
  cmdCopyAccelerationStructureKHR
  cmdCopyAccelerationStructureToMemoryKHR
  cmdCopyMemoryToAccelerationStructureKHR
  getAccelerationStructureDeviceAddressKHR
  cmdWriteAccelerationStructuresPropertiesKHR
  getDeviceAccelerationStructureCompatibilityKHR
  getAccelerationStructureBuildSizesKHR
proc loadVK_KHR_ray_tracing_pipeline*(device: Device) = device.loadCommands:
  cmdTraceRaysKHR
  createRayTracingPipelinesKHR
  getRayTracingShaderGroupHandlesKHR
  getRayTracingCaptureReplayShaderGroupHandlesKHR
  cmdTraceRaysIndirectKHR
  getRayTracingShaderGroupStackSizeKHR
  cmdSetRayTracingPipelineStackSizeKHR
proc loadVK_EXT_image_drm_format_modifier*(device: Device) = device.loadCommands:
  getImageDrmFormatModifierPropertiesEXT
proc loadVK_EXT_validation_cache*(device: Device) = device.loadCommands:
  createValidationCacheEXT
  destroyValidationCacheEXT
  mergeValidationCachesEXT
  getValidationCacheDataEXT
proc loadVK_NV_shading_rate_image*(device: Device) = device.loadCommands:
  cmdBindShadingRateImageNV
  cmdSetViewportShadingRatePaletteNV
  cmdSetCoarseSampleOrderNV
proc loadVK_NV_ray_tracing*(device: Device) = device.loadCommands:
  createAccelerationStructureNV
  destroyAccelerationStructureNV
  getAccelerationStructureMemoryRequirementsNV
  bindAccelerationStructureMemoryNV
  cmdBuildAccelerationStructureNV
  cmdCopyAccelerationStructureNV
  cmdTraceRaysNV
  createRayTracingPipelinesNV
  getAccelerationStructureHandleNV
  cmdWriteAccelerationStructuresPropertiesNV
  compileDeferredNV
proc loadVK_EXT_external_memory_host*(device: Device) = device.loadCommands:
  getMemoryHostPointerPropertiesEXT
proc loadVK_AMD_buffer_marker*(device: Device) = device.loadCommands:
  cmdWriteBufferMarkerAMD
proc loadVK_EXT_calibrated_timestamps*(device: Device) = device.loadCommands:
  getCalibratedTimestampsEXT
proc loadVK_NV_mesh_shader*(device: Device) = device.loadCommands:
  cmdDrawMeshTasksNV
  cmdDrawMeshTasksIndirectNV
  cmdDrawMeshTasksIndirectCountNV
proc loadVK_NV_scissor_exclusive*(device: Device) = device.loadCommands:
  cmdSetExclusiveScissorNV
proc loadVK_NV_device_diagnostic_checkpoints*(device: Device) = device.loadCommands:
  cmdSetCheckpointNV
  getQueueCheckpointDataNV
proc loadVK_INTEL_performance_query*(device: Device) = device.loadCommands:
  initializePerformanceApiINTEL
  uninitializePerformanceApiINTEL
  cmdSetPerformanceMarkerINTEL
  cmdSetPerformanceStreamMarkerINTEL
  cmdSetPerformanceOverrideINTEL
  acquirePerformanceConfigurationINTEL
  releasePerformanceConfigurationINTEL
  queueSetPerformanceConfigurationINTEL
  getPerformanceParameterINTEL
proc loadVK_AMD_display_native_hdr*(device: Device) = device.loadCommands:
  setLocalDimmingAMD
proc loadVK_KHR_fragment_shading_rate*(device: Device) = device.loadCommands:
  cmdSetFragmentShadingRateKHR
proc loadVK_KHR_present_wait*(device: Device) = device.loadCommands:
  waitForPresentKHR
proc loadVK_EXT_full_screen_exclusive*(device: Device) = device.loadCommands:
  acquireFullScreenExclusiveModeEXT
  releaseFullScreenExclusiveModeEXT
  getDeviceGroupSurfacePresentModes2EXT
  getDeviceGroupSurfacePresentModes2EXT
proc loadVK_EXT_line_rasterization*(device: Device) = device.loadCommands:
  cmdSetLineStippleEXT
proc loadVK_EXT_extended_dynamic_state*(device: Device) = device.loadCommands:
  cmdSetCullModeEXT
  cmdSetFrontFaceEXT
  cmdSetPrimitiveTopologyEXT
  cmdSetViewportWithCountEXT
  cmdSetScissorWithCountEXT
  cmdBindVertexBuffers2EXT
  cmdSetDepthTestEnableEXT
  cmdSetDepthWriteEnableEXT
  cmdSetDepthCompareOpEXT
  cmdSetDepthBoundsTestEnableEXT
  cmdSetStencilTestEnableEXT
  cmdSetStencilOpEXT
proc loadVK_KHR_deferred_host_operations*(device: Device) = device.loadCommands:
  createDeferredOperationKHR
  destroyDeferredOperationKHR
  getDeferredOperationMaxConcurrencyKHR
  getDeferredOperationResultKHR
  deferredOperationJoinKHR
proc loadVK_KHR_pipeline_executable_properties*(device: Device) = device.loadCommands:
  getPipelineExecutablePropertiesKHR
  getPipelineExecutableStatisticsKHR
  getPipelineExecutableInternalRepresentationsKHR
proc loadVK_NV_device_generated_commands*(device: Device) = device.loadCommands:
  getGeneratedCommandsMemoryRequirementsNV
  cmdPreprocessGeneratedCommandsNV
  cmdExecuteGeneratedCommandsNV
  cmdBindPipelineShaderGroupNV
  createIndirectCommandsLayoutNV
  destroyIndirectCommandsLayoutNV
proc loadVK_EXT_private_data*(device: Device) = device.loadCommands:
  createPrivateDataSlotEXT
  destroyPrivateDataSlotEXT
  setPrivateDataEXT
  getPrivateDataEXT
proc loadVK_KHR_video_encode_queue*(device: Device) = device.loadCommands:
  cmdEncodeVideoKHR
proc loadVK_KHR_synchronization2*(device: Device) = device.loadCommands:
  cmdSetEvent2KHR
  cmdResetEvent2KHR
  cmdWaitEvents2KHR
  cmdPipelineBarrier2KHR
  cmdWriteTimestamp2KHR
  queueSubmit2KHR
  cmdWriteBufferMarker2AMD
  getQueueCheckpointData2NV
proc loadVK_NV_fragment_shading_rate_enums*(device: Device) = device.loadCommands:
  cmdSetFragmentShadingRateEnumNV
proc loadVK_KHR_copy_commands2*(device: Device) = device.loadCommands:
  cmdCopyBuffer2KHR
  cmdCopyImage2KHR
  cmdCopyBufferToImage2KHR
  cmdCopyImageToBuffer2KHR
  cmdBlitImage2KHR
  cmdResolveImage2KHR
proc loadVK_EXT_vertex_input_dynamic_state*(device: Device) = device.loadCommands:
  cmdSetVertexInputEXT
proc loadVK_FUCHSIA_external_memory*(device: Device) = device.loadCommands:
  getMemoryZirconHandleFUCHSIA
  getMemoryZirconHandlePropertiesFUCHSIA
proc loadVK_FUCHSIA_external_semaphore*(device: Device) = device.loadCommands:
  importSemaphoreZirconHandleFUCHSIA
  getSemaphoreZirconHandleFUCHSIA
proc loadVK_FUCHSIA_buffer_collection*(device: Device) = device.loadCommands:
  createBufferCollectionFUCHSIA
  setBufferCollectionImageConstraintsFUCHSIA
  setBufferCollectionBufferConstraintsFUCHSIA
  destroyBufferCollectionFUCHSIA
  getBufferCollectionPropertiesFUCHSIA
proc loadVK_HUAWEI_subpass_shading*(device: Device) = device.loadCommands:
  getDeviceSubpassShadingMaxWorkgroupSizeHUAWEI
  cmdSubpassShadingHUAWEI
proc loadVK_HUAWEI_invocation_mask*(device: Device) = device.loadCommands:
  cmdBindInvocationMaskHUAWEI
proc loadVK_NV_external_memory_rdma*(device: Device) = device.loadCommands:
  getMemoryRemoteAddressNV
proc loadVK_EXT_extended_dynamic_state2*(device: Device) = device.loadCommands:
  cmdSetPatchControlPointsEXT
  cmdSetRasterizerDiscardEnableEXT
  cmdSetDepthBiasEnableEXT
  cmdSetLogicOpEXT
  cmdSetPrimitiveRestartEnableEXT
proc loadVK_EXT_color_write_enable*(device: Device) = device.loadCommands:
  cmdSetColorWriteEnableEXT
proc loadVK_EXT_multi_draw*(device: Device) = device.loadCommands:
  cmdDrawMultiEXT
  cmdDrawMultiIndexedEXT
proc loadVK_EXT_pageable_device_local_memory*(device: Device) = device.loadCommands:
  setDeviceMemoryPriorityEXT
proc loadVK_KHR_maintenance4*(device: Device) = device.loadCommands:
  getDeviceBufferMemoryRequirementsKHR
  getDeviceImageMemoryRequirementsKHR
  getDeviceImageSparseMemoryRequirementsKHR