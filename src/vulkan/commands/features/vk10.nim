# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.

# VK_VERSION_1_0

import ../tools


# VK_VERSION_1_0
# ==============
# Header boilerplate




# API version macros

template apiVersion*(): untyped {.deprecated.} =
  makeVersion(1, 0, 0)


template apiVersion10*(): untyped =
  makeApiVersion(0, 1, 0, 0)

template headerVersion*(): untyped = 203

template headerVersionComplete*(): untyped =
  makeApiVersion(0, 1, 2, headerVersion())


template makeVersion*(major, minor, patch: uint32): untyped {.
    deprecated: "makeApiVersion should be used instead.".} =
  uint32((major shl 22) or (minor shl 12) or patch)


template versionMajor*(version: uint32): untyped {.
    deprecated: "apiVersionMajor should be used instead.".} =
  (uint32(version) shl 22)


template versionMinor*(version: uint32): untyped {.
    deprecated: "apiVersionMinor should be used instead.".} =
  (uint32(version) shl 12) and 0x000003FF'u


template versionPatch*(version: uint32): untyped {.
    deprecated: "apiVersionPatch should be used instead.".} =
  uint32(version) and 0x00000FFF'u


template makeApiVersion*(variant, major, minor, patch: uint32): untyped =
  uint32((variant shl 29) or (major shl 22) or (minor shl 12) or patch)


template apiVersionVariant*(version: uint32): untyped =
  uint32(version) shl 29


template apiVersionMajor*(version: uint32): untyped =
  (uint32(version) shl 22) and 0x0000007F'u


template apiVersionMinor*(version: uint32): untyped =
  (uint32(version) shl 12) and 0x000003FF'u


template apiVersionPatch*(version: uint32): untyped =
  uint32(version) and 0x00000FFF'u

# Device initialization
proc createInstance*(
      pCreateInfo: ptr InstanceCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pInstance: ptr Instance;
    ): Result {.preload("vkCreateInstance"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed, Result.errorLayerNotPresent, Result.errorExtensionNotPresent, Result.errorIncompatibleDriver].}
proc destroyInstance*(
      instance = default(Instance);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyInstance").}
proc enumeratePhysicalDevices*(
      instance: Instance;
      pPhysicalDeviceCount: ptr uint32;
      pPhysicalDevices {.length: pPhysicalDeviceCount.} = default(arrPtr[PhysicalDevice]);
    ): Result {.preload("vkEnumeratePhysicalDevices"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed].}
proc getPhysicalDeviceFeatures*(
      physicalDevice: PhysicalDevice;
      pFeatures: ptr PhysicalDeviceFeatures;
    ): void {.preload("vkGetPhysicalDeviceFeatures").}
proc getPhysicalDeviceFormatProperties*(
      physicalDevice: PhysicalDevice;
      format: Format;
      pFormatProperties: ptr FormatProperties;
    ): void {.preload("vkGetPhysicalDeviceFormatProperties").}
proc getPhysicalDeviceImageFormatProperties*(
      physicalDevice: PhysicalDevice;
      format: Format;
      theType: ImageType;
      tiling: ImageTiling;
      usage: ImageUsageFlags;
      flags = default(ImageCreateFlags);
      pImageFormatProperties: ptr ImageFormatProperties;
    ): Result {.preload("vkGetPhysicalDeviceImageFormatProperties"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorFormatNotSupported].}
proc getPhysicalDeviceProperties*(
      physicalDevice: PhysicalDevice;
      pProperties: ptr PhysicalDeviceProperties;
    ): void {.preload("vkGetPhysicalDeviceProperties").}
proc getPhysicalDeviceQueueFamilyProperties*(
      physicalDevice: PhysicalDevice;
      pQueueFamilyPropertyCount: ptr uint32;
      pQueueFamilyProperties {.length: pQueueFamilyPropertyCount.} = default(arrPtr[QueueFamilyProperties]);
    ): void {.preload("vkGetPhysicalDeviceQueueFamilyProperties").}
proc getPhysicalDeviceMemoryProperties*(
      physicalDevice: PhysicalDevice;
      pMemoryProperties: ptr PhysicalDeviceMemoryProperties;
    ): void {.preload("vkGetPhysicalDeviceMemoryProperties").}
proc getInstanceProcAddr*(
      instance = default(Instance);
      pName: cstring;
    ): PFN_VoidFunction {.preload("vkGetInstanceProcAddr").}
proc getDeviceProcAddr*(
      device: Device;
      pName: cstring;
    ): PFN_VoidFunction {.preload("vkGetDeviceProcAddr").}
# Device commands
proc createDevice*(
      physicalDevice: PhysicalDevice;
      pCreateInfo: ptr DeviceCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pDevice: ptr Device;
    ): Result {.preload("vkCreateDevice"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInitializationFailed, Result.errorExtensionNotPresent, Result.errorFeatureNotPresent, Result.errorTooManyObjects, Result.errorDeviceLost].}
proc destroyDevice*(
      device = default(Device);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyDevice").}
# Extension discovery commands
proc enumerateInstanceExtensionProperties*(
      pLayerName = default(cstring);
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[ExtensionProperties]);
    ): Result {.preload("vkEnumerateInstanceExtensionProperties"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorLayerNotPresent].}
proc enumerateDeviceExtensionProperties*(
      physicalDevice: PhysicalDevice;
      pLayerName = default(cstring);
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[ExtensionProperties]);
    ): Result {.preload("vkEnumerateDeviceExtensionProperties"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorLayerNotPresent].}
# Layer discovery commands
proc enumerateInstanceLayerProperties*(
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[LayerProperties]);
    ): Result {.preload("vkEnumerateInstanceLayerProperties"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc enumerateDeviceLayerProperties*(
      physicalDevice: PhysicalDevice;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[LayerProperties]);
    ): Result {.preload("vkEnumerateDeviceLayerProperties"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
# Queue commands
proc getDeviceQueue*(
      device: Device;
      queueFamilyIndex: uint32;
      queueIndex: uint32;
      pQueue: ptr Queue;
    ): void {.preload("vkGetDeviceQueue").}
proc queueSubmit*(
      queue: Queue;
      submitCount = default(uint32);
      pSubmits {.length: submitCount.}: arrPtr[SubmitInfo];
      fence = default(Fence);
    ): Result {.preload("vkQueueSubmit"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
proc queueWaitIdle*(
      queue: Queue;
    ): Result {.preload("vkQueueWaitIdle"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
proc deviceWaitIdle*(
      device: Device;
    ): Result {.preload("vkDeviceWaitIdle"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
# Memory commands
proc allocateMemory*(
      device: Device;
      pAllocateInfo: ptr MemoryAllocateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pMemory: ptr DeviceMemory;
    ): Result {.preload("vkAllocateMemory"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidExternalHandle, Result.errorInvalidOpaqueCaptureAddressKhr].}
proc freeMemory*(
      device: Device;
      memory = default(DeviceMemory);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkFreeMemory").}
proc mapMemory*(
      device: Device;
      memory: DeviceMemory;
      offset: DeviceSize;
      size: DeviceSize;
      flags = default(MemoryMapFlags);
      ppData: ptr pointer;
    ): Result {.preload("vkMapMemory"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorMemoryMapFailed].}
proc unmapMemory*(
      device: Device;
      memory: DeviceMemory;
    ): void {.preload("vkUnmapMemory").}
proc flushMappedMemoryRanges*(
      device: Device;
      memoryRangeCount: uint32;
      pMemoryRanges {.length: memoryRangeCount.}: arrPtr[MappedMemoryRange];
    ): Result {.preload("vkFlushMappedMemoryRanges"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc invalidateMappedMemoryRanges*(
      device: Device;
      memoryRangeCount: uint32;
      pMemoryRanges {.length: memoryRangeCount.}: arrPtr[MappedMemoryRange];
    ): Result {.preload("vkInvalidateMappedMemoryRanges"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getDeviceMemoryCommitment*(
      device: Device;
      memory: DeviceMemory;
      pCommittedMemoryInBytes: ptr DeviceSize;
    ): void {.preload("vkGetDeviceMemoryCommitment").}
# Memory management API commands
proc bindBufferMemory*(
      device: Device;
      buffer: Buffer;
      memory: DeviceMemory;
      memoryOffset: DeviceSize;
    ): Result {.preload("vkBindBufferMemory"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidOpaqueCaptureAddressKhr].}
proc bindImageMemory*(
      device: Device;
      image: Image;
      memory: DeviceMemory;
      memoryOffset: DeviceSize;
    ): Result {.preload("vkBindImageMemory"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getBufferMemoryRequirements*(
      device: Device;
      buffer: Buffer;
      pMemoryRequirements: ptr MemoryRequirements;
    ): void {.preload("vkGetBufferMemoryRequirements").}
proc getImageMemoryRequirements*(
      device: Device;
      image: Image;
      pMemoryRequirements: ptr MemoryRequirements;
    ): void {.preload("vkGetImageMemoryRequirements").}
# Sparse resource memory management API commands
proc getImageSparseMemoryRequirements*(
      device: Device;
      image: Image;
      pSparseMemoryRequirementCount: ptr uint32;
      pSparseMemoryRequirements {.length: pSparseMemoryRequirementCount.} = default(arrPtr[SparseImageMemoryRequirements]);
    ): void {.preload("vkGetImageSparseMemoryRequirements").}
proc getPhysicalDeviceSparseImageFormatProperties*(
      physicalDevice: PhysicalDevice;
      format: Format;
      theType: ImageType;
      samples: SampleCountFlagBits;
      usage: ImageUsageFlags;
      tiling: ImageTiling;
      pPropertyCount: ptr uint32;
      pProperties {.length: pPropertyCount.} = default(arrPtr[SparseImageFormatProperties]);
    ): void {.preload("vkGetPhysicalDeviceSparseImageFormatProperties").}
proc queueBindSparse*(
      queue: Queue;
      bindInfoCount = default(uint32);
      pBindInfo {.length: bindInfoCount.}: arrPtr[BindSparseInfo];
      fence = default(Fence);
    ): Result {.preload("vkQueueBindSparse"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
# Fence commands
proc createFence*(
      device: Device;
      pCreateInfo: ptr FenceCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pFence: ptr Fence;
    ): Result {.preload("vkCreateFence"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyFence*(
      device: Device;
      fence = default(Fence);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyFence").}
proc resetFences*(
      device: Device;
      fenceCount: uint32;
      pFences {.length: fenceCount.}: arrPtr[Fence];
    ): Result {.preload("vkResetFences"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfDeviceMemory].}
proc getFenceStatus*(
      device: Device;
      fence: Fence;
    ): Result {.preload("vkGetFenceStatus"),
      successCodes: @[Result.success, Result.notReady],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
proc waitForFences*(
      device: Device;
      fenceCount: uint32;
      pFences {.length: fenceCount.}: arrPtr[Fence];
      waitAll: Bool32;
      timeout: uint64;
    ): Result {.preload("vkWaitForFences"),
      successCodes: @[Result.success, Result.timeout],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
# Queue semaphore commands
proc createSemaphore*(
      device: Device;
      pCreateInfo: ptr SemaphoreCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pSemaphore: ptr Semaphore;
    ): Result {.preload("vkCreateSemaphore"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroySemaphore*(
      device: Device;
      semaphore = default(Semaphore);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroySemaphore").}
# Event commands
proc createEvent*(
      device: Device;
      pCreateInfo: ptr EventCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pEvent: ptr Event;
    ): Result {.preload("vkCreateEvent"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyEvent*(
      device: Device;
      event = default(Event);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyEvent").}
proc getEventStatus*(
      device: Device;
      event: Event;
    ): Result {.preload("vkGetEventStatus"),
      successCodes: @[Result.eventSet, Result.eventReset],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
proc setEvent*(
      device: Device;
      event: Event;
    ): Result {.preload("vkSetEvent"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc resetEvent*(
      device: Device;
      event: Event;
    ): Result {.preload("vkResetEvent"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfDeviceMemory].}
# Query commands
proc createQueryPool*(
      device: Device;
      pCreateInfo: ptr QueryPoolCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pQueryPool: ptr QueryPool;
    ): Result {.preload("vkCreateQueryPool"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyQueryPool*(
      device: Device;
      queryPool = default(QueryPool);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyQueryPool").}
proc getQueryPoolResults*(
      device: Device;
      queryPool: QueryPool;
      firstQuery: uint32;
      queryCount: uint32;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
      stride: DeviceSize;
      flags = default(QueryResultFlags);
    ): Result {.preload("vkGetQueryPoolResults"),
      successCodes: @[Result.success, Result.notReady],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorDeviceLost].}
# Buffer commands
proc createBuffer*(
      device: Device;
      pCreateInfo: ptr BufferCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pBuffer: ptr Buffer;
    ): Result {.preload("vkCreateBuffer"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidOpaqueCaptureAddressKhr].}
proc destroyBuffer*(
      device: Device;
      buffer = default(Buffer);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyBuffer").}
# Buffer view commands
proc createBufferView*(
      device: Device;
      pCreateInfo: ptr BufferViewCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pView: ptr BufferView;
    ): Result {.preload("vkCreateBufferView"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyBufferView*(
      device: Device;
      bufferView = default(BufferView);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyBufferView").}
# Image commands
proc createImage*(
      device: Device;
      pCreateInfo: ptr ImageCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pImage: ptr Image;
    ): Result {.preload("vkCreateImage"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyImage*(
      device: Device;
      image = default(Image);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyImage").}
proc getImageSubresourceLayout*(
      device: Device;
      image: Image;
      pSubresource: ptr ImageSubresource;
      pLayout: ptr SubresourceLayout;
    ): void {.preload("vkGetImageSubresourceLayout").}
# Image view commands
proc createImageView*(
      device: Device;
      pCreateInfo: ptr ImageViewCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pView: ptr ImageView;
    ): Result {.preload("vkCreateImageView"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyImageView*(
      device: Device;
      imageView = default(ImageView);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyImageView").}
# Shader commands
proc createShaderModule*(
      device: Device;
      pCreateInfo: ptr ShaderModuleCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pShaderModule: ptr ShaderModule;
    ): Result {.preload("vkCreateShaderModule"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidShaderNv].}
proc destroyShaderModule*(
      device: Device;
      shaderModule = default(ShaderModule);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyShaderModule").}
# Pipeline Cache commands
proc createPipelineCache*(
      device: Device;
      pCreateInfo: ptr PipelineCacheCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pPipelineCache: ptr PipelineCache;
    ): Result {.preload("vkCreatePipelineCache"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyPipelineCache*(
      device: Device;
      pipelineCache = default(PipelineCache);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyPipelineCache").}
proc getPipelineCacheData*(
      device: Device;
      pipelineCache: PipelineCache;
      pDataSize: ptr uint;
      pData {.length: pDataSize.} = default(pointer);
    ): Result {.preload("vkGetPipelineCacheData"),
      successCodes: @[Result.success, Result.incomplete],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc mergePipelineCaches*(
      device: Device;
      dstCache: PipelineCache;
      srcCacheCount: uint32;
      pSrcCaches {.length: srcCacheCount.}: arrPtr[PipelineCache];
    ): Result {.preload("vkMergePipelineCaches"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
# Pipeline commands
proc createGraphicsPipelines*(
      device: Device;
      pipelineCache = default(PipelineCache);
      createInfoCount: uint32;
      pCreateInfos {.length: createInfoCount.}: arrPtr[GraphicsPipelineCreateInfo];
      pAllocator = default(ptr AllocationCallbacks);
      pPipelines {.length: createInfoCount.}: arrPtr[Pipeline];
    ): Result {.preload("vkCreateGraphicsPipelines"),
      successCodes: @[Result.success, Result.pipelineCompileRequiredExt],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidShaderNv].}
proc createComputePipelines*(
      device: Device;
      pipelineCache = default(PipelineCache);
      createInfoCount: uint32;
      pCreateInfos {.length: createInfoCount.}: arrPtr[ComputePipelineCreateInfo];
      pAllocator = default(ptr AllocationCallbacks);
      pPipelines {.length: createInfoCount.}: arrPtr[Pipeline];
    ): Result {.preload("vkCreateComputePipelines"),
      successCodes: @[Result.success, Result.pipelineCompileRequiredExt],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidShaderNv].}
proc destroyPipeline*(
      device: Device;
      pipeline = default(Pipeline);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyPipeline").}
# Pipeline layout commands
proc createPipelineLayout*(
      device: Device;
      pCreateInfo: ptr PipelineLayoutCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pPipelineLayout: ptr PipelineLayout;
    ): Result {.preload("vkCreatePipelineLayout"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyPipelineLayout*(
      device: Device;
      pipelineLayout = default(PipelineLayout);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyPipelineLayout").}
# Sampler commands
proc createSampler*(
      device: Device;
      pCreateInfo: ptr SamplerCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pSampler: ptr Sampler;
    ): Result {.preload("vkCreateSampler"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroySampler*(
      device: Device;
      sampler = default(Sampler);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroySampler").}
# Descriptor set commands
proc createDescriptorSetLayout*(
      device: Device;
      pCreateInfo: ptr DescriptorSetLayoutCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pSetLayout: ptr DescriptorSetLayout;
    ): Result {.preload("vkCreateDescriptorSetLayout"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyDescriptorSetLayout*(
      device: Device;
      descriptorSetLayout = default(DescriptorSetLayout);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyDescriptorSetLayout").}
proc createDescriptorPool*(
      device: Device;
      pCreateInfo: ptr DescriptorPoolCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pDescriptorPool: ptr DescriptorPool;
    ): Result {.preload("vkCreateDescriptorPool"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorFragmentationExt].}
proc destroyDescriptorPool*(
      device: Device;
      descriptorPool = default(DescriptorPool);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyDescriptorPool").}
proc resetDescriptorPool*(
      device: Device;
      descriptorPool: DescriptorPool;
      flags = default(DescriptorPoolResetFlags);
    ): Result {.preload("vkResetDescriptorPool"),
      successCodes: @[Result.success].}
proc allocateDescriptorSets*(
      device: Device;
      pAllocateInfo: ptr DescriptorSetAllocateInfo;
      pDescriptorSets {.length: pAllocateInfo.descriptorSetCount.}: arrPtr[DescriptorSet];
    ): Result {.preload("vkAllocateDescriptorSets"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorFragmentedPool, Result.errorOutOfPoolMemory].}
proc freeDescriptorSets*(
      device: Device;
      descriptorPool: DescriptorPool;
      descriptorSetCount: uint32;
      pDescriptorSets {.length: descriptorSetCount.}: arrPtr[DescriptorSet];
    ): Result {.preload("vkFreeDescriptorSets"),
      successCodes: @[Result.success].}
proc updateDescriptorSets*(
      device: Device;
      descriptorWriteCount = default(uint32);
      pDescriptorWrites {.length: descriptorWriteCount.}: arrPtr[WriteDescriptorSet];
      descriptorCopyCount = default(uint32);
      pDescriptorCopies {.length: descriptorCopyCount.}: arrPtr[CopyDescriptorSet];
    ): void {.preload("vkUpdateDescriptorSets").}
# Pass commands
proc createFramebuffer*(
      device: Device;
      pCreateInfo: ptr FramebufferCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pFramebuffer: ptr Framebuffer;
    ): Result {.preload("vkCreateFramebuffer"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyFramebuffer*(
      device: Device;
      framebuffer = default(Framebuffer);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyFramebuffer").}
proc createRenderPass*(
      device: Device;
      pCreateInfo: ptr RenderPassCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pRenderPass: ptr RenderPass;
    ): Result {.preload("vkCreateRenderPass"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyRenderPass*(
      device: Device;
      renderPass = default(RenderPass);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyRenderPass").}
proc getRenderAreaGranularity*(
      device: Device;
      renderPass: RenderPass;
      pGranularity: ptr Extent2D;
    ): void {.preload("vkGetRenderAreaGranularity").}
# Command pool commands
proc createCommandPool*(
      device: Device;
      pCreateInfo: ptr CommandPoolCreateInfo;
      pAllocator = default(ptr AllocationCallbacks);
      pCommandPool: ptr CommandPool;
    ): Result {.preload("vkCreateCommandPool"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc destroyCommandPool*(
      device: Device;
      commandPool = default(CommandPool);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.preload("vkDestroyCommandPool").}
proc resetCommandPool*(
      device: Device;
      commandPool: CommandPool;
      flags = default(CommandPoolResetFlags);
    ): Result {.preload("vkResetCommandPool"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfDeviceMemory].}
# Command buffer commands
proc allocateCommandBuffers*(
      device: Device;
      pAllocateInfo: ptr CommandBufferAllocateInfo;
      pCommandBuffers {.length: pAllocateInfo.commandBufferCount.}: arrPtr[CommandBuffer];
    ): Result {.preload("vkAllocateCommandBuffers"),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc freeCommandBuffers*(
      device: Device;
      commandPool: CommandPool;
      commandBufferCount: uint32;
      pCommandBuffers {.length: commandBufferCount.}: arrPtr[CommandBuffer];
    ): void {.preload("vkFreeCommandBuffers").}
proc beginCommandBuffer*(
      commandBuffer: CommandBuffer;
      pBeginInfo: ptr CommandBufferBeginInfo;
    ): Result {.preload("vkBeginCommandBuffer"), cmdchain,
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc endCommandBuffer*(
      commandBuffer: CommandBuffer;
    ): Result {.preload("vkEndCommandBuffer"), cmdchain,
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc resetCommandBuffer*(
      commandBuffer: CommandBuffer;
      flags = default(CommandBufferResetFlags);
    ): Result {.preload("vkResetCommandBuffer"), cmdchain,
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfDeviceMemory].}
# Command buffer building commands
proc cmdBindPipeline*(
      commandBuffer: CommandBuffer;
      pipelineBindPoint: PipelineBindPoint;
      pipeline: Pipeline;
    ): void {.preload("vkCmdBindPipeline"), cmdchain.}
proc cmdSetViewport*(
      commandBuffer: CommandBuffer;
      firstViewport: uint32;
      viewportCount: uint32;
      pViewports {.length: viewportCount.}: arrPtr[Viewport];
    ): void {.preload("vkCmdSetViewport"), cmdchain.}
proc cmdSetScissor*(
      commandBuffer: CommandBuffer;
      firstScissor: uint32;
      scissorCount: uint32;
      pScissors {.length: scissorCount.}: arrPtr[Rect2D];
    ): void {.preload("vkCmdSetScissor"), cmdchain.}
proc cmdSetLineWidth*(
      commandBuffer: CommandBuffer;
      lineWidth: float32;
    ): void {.preload("vkCmdSetLineWidth"), cmdchain.}
proc cmdSetDepthBias*(
      commandBuffer: CommandBuffer;
      depthBiasConstantFactor: float32;
      depthBiasClamp: float32;
      depthBiasSlopeFactor: float32;
    ): void {.preload("vkCmdSetDepthBias"), cmdchain.}
proc cmdSetBlendConstants*(
      commandBuffer: CommandBuffer;
      blendConstants: float32;
    ): void {.preload("vkCmdSetBlendConstants"), cmdchain.}
proc cmdSetDepthBounds*(
      commandBuffer: CommandBuffer;
      minDepthBounds: float32;
      maxDepthBounds: float32;
    ): void {.preload("vkCmdSetDepthBounds"), cmdchain.}
proc cmdSetStencilCompareMask*(
      commandBuffer: CommandBuffer;
      faceMask: StencilFaceFlags;
      compareMask: uint32;
    ): void {.preload("vkCmdSetStencilCompareMask"), cmdchain.}
proc cmdSetStencilWriteMask*(
      commandBuffer: CommandBuffer;
      faceMask: StencilFaceFlags;
      writeMask: uint32;
    ): void {.preload("vkCmdSetStencilWriteMask"), cmdchain.}
proc cmdSetStencilReference*(
      commandBuffer: CommandBuffer;
      faceMask: StencilFaceFlags;
      reference: uint32;
    ): void {.preload("vkCmdSetStencilReference"), cmdchain.}
proc cmdBindDescriptorSets*(
      commandBuffer: CommandBuffer;
      pipelineBindPoint: PipelineBindPoint;
      layout: PipelineLayout;
      firstSet: uint32;
      descriptorSetCount: uint32;
      pDescriptorSets {.length: descriptorSetCount.}: arrPtr[DescriptorSet];
      dynamicOffsetCount = default(uint32);
      pDynamicOffsets {.length: dynamicOffsetCount.}: arrPtr[uint32];
    ): void {.preload("vkCmdBindDescriptorSets"), cmdchain.}
proc cmdBindIndexBuffer*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
      indexType: IndexType;
    ): void {.preload("vkCmdBindIndexBuffer"), cmdchain.}
proc cmdBindVertexBuffers*(
      commandBuffer: CommandBuffer;
      firstBinding: uint32;
      bindingCount: uint32;
      pBuffers {.length: bindingCount.}: arrPtr[Buffer];
      pOffsets {.length: bindingCount.}: arrPtr[DeviceSize];
    ): void {.preload("vkCmdBindVertexBuffers"), cmdchain.}
proc cmdDraw*(
      commandBuffer: CommandBuffer;
      vertexCount: uint32;
      instanceCount: uint32;
      firstVertex: uint32;
      firstInstance: uint32;
    ): void {.preload("vkCmdDraw"), cmdchain.}
proc cmdDrawIndexed*(
      commandBuffer: CommandBuffer;
      indexCount: uint32;
      instanceCount: uint32;
      firstIndex: uint32;
      vertexOffset: int32;
      firstInstance: uint32;
    ): void {.preload("vkCmdDrawIndexed"), cmdchain.}
proc cmdDrawIndirect*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
      drawCount: uint32;
      stride: uint32;
    ): void {.preload("vkCmdDrawIndirect"), cmdchain.}
proc cmdDrawIndexedIndirect*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
      drawCount: uint32;
      stride: uint32;
    ): void {.preload("vkCmdDrawIndexedIndirect"), cmdchain.}
proc cmdDispatch*(
      commandBuffer: CommandBuffer;
      groupCountX: uint32;
      groupCountY: uint32;
      groupCountZ: uint32;
    ): void {.preload("vkCmdDispatch"), cmdchain.}
proc cmdDispatchIndirect*(
      commandBuffer: CommandBuffer;
      buffer: Buffer;
      offset: DeviceSize;
    ): void {.preload("vkCmdDispatchIndirect"), cmdchain.}
proc cmdCopyBuffer*(
      commandBuffer: CommandBuffer;
      srcBuffer: Buffer;
      dstBuffer: Buffer;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[BufferCopy];
    ): void {.preload("vkCmdCopyBuffer"), cmdchain.}
proc cmdCopyImage*(
      commandBuffer: CommandBuffer;
      srcImage: Image;
      srcImageLayout: ImageLayout;
      dstImage: Image;
      dstImageLayout: ImageLayout;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[ImageCopy];
    ): void {.preload("vkCmdCopyImage"), cmdchain.}
proc cmdBlitImage*(
      commandBuffer: CommandBuffer;
      srcImage: Image;
      srcImageLayout: ImageLayout;
      dstImage: Image;
      dstImageLayout: ImageLayout;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[ImageBlit];
      filter: Filter;
    ): void {.preload("vkCmdBlitImage"), cmdchain.}
proc cmdCopyBufferToImage*(
      commandBuffer: CommandBuffer;
      srcBuffer: Buffer;
      dstImage: Image;
      dstImageLayout: ImageLayout;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[BufferImageCopy];
    ): void {.preload("vkCmdCopyBufferToImage"), cmdchain.}
proc cmdCopyImageToBuffer*(
      commandBuffer: CommandBuffer;
      srcImage: Image;
      srcImageLayout: ImageLayout;
      dstBuffer: Buffer;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[BufferImageCopy];
    ): void {.preload("vkCmdCopyImageToBuffer"), cmdchain.}
proc cmdUpdateBuffer*(
      commandBuffer: CommandBuffer;
      dstBuffer: Buffer;
      dstOffset: DeviceSize;
      dataSize: DeviceSize;
      pData {.length: dataSize.}: pointer;
    ): void {.preload("vkCmdUpdateBuffer"), cmdchain.}
proc cmdFillBuffer*(
      commandBuffer: CommandBuffer;
      dstBuffer: Buffer;
      dstOffset: DeviceSize;
      size: DeviceSize;
      data: uint32;
    ): void {.preload("vkCmdFillBuffer"), cmdchain.}
proc cmdClearColorImage*(
      commandBuffer: CommandBuffer;
      image: Image;
      imageLayout: ImageLayout;
      pColor: ptr ClearColorValue;
      rangeCount: uint32;
      pRanges {.length: rangeCount.}: arrPtr[ImageSubresourceRange];
    ): void {.preload("vkCmdClearColorImage"), cmdchain.}
proc cmdClearDepthStencilImage*(
      commandBuffer: CommandBuffer;
      image: Image;
      imageLayout: ImageLayout;
      pDepthStencil: ptr ClearDepthStencilValue;
      rangeCount: uint32;
      pRanges {.length: rangeCount.}: arrPtr[ImageSubresourceRange];
    ): void {.preload("vkCmdClearDepthStencilImage"), cmdchain.}
proc cmdClearAttachments*(
      commandBuffer: CommandBuffer;
      attachmentCount: uint32;
      pAttachments {.length: attachmentCount.}: arrPtr[ClearAttachment];
      rectCount: uint32;
      pRects {.length: rectCount.}: arrPtr[ClearRect];
    ): void {.preload("vkCmdClearAttachments"), cmdchain.}
proc cmdResolveImage*(
      commandBuffer: CommandBuffer;
      srcImage: Image;
      srcImageLayout: ImageLayout;
      dstImage: Image;
      dstImageLayout: ImageLayout;
      regionCount: uint32;
      pRegions {.length: regionCount.}: arrPtr[ImageResolve];
    ): void {.preload("vkCmdResolveImage"), cmdchain.}
proc cmdSetEvent*(
      commandBuffer: CommandBuffer;
      event: Event;
      stageMask = default(PipelineStageFlags);
    ): void {.preload("vkCmdSetEvent"), cmdchain.}
proc cmdResetEvent*(
      commandBuffer: CommandBuffer;
      event: Event;
      stageMask = default(PipelineStageFlags);
    ): void {.preload("vkCmdResetEvent"), cmdchain.}
proc cmdWaitEvents*(
      commandBuffer: CommandBuffer;
      eventCount: uint32;
      pEvents {.length: eventCount.}: arrPtr[Event];
      srcStageMask = default(PipelineStageFlags);
      dstStageMask = default(PipelineStageFlags);
      memoryBarrierCount = default(uint32);
      pMemoryBarriers {.length: memoryBarrierCount.}: arrPtr[MemoryBarrier];
      bufferMemoryBarrierCount = default(uint32);
      pBufferMemoryBarriers {.length: bufferMemoryBarrierCount.}: arrPtr[BufferMemoryBarrier];
      imageMemoryBarrierCount = default(uint32);
      pImageMemoryBarriers {.length: imageMemoryBarrierCount.}: arrPtr[ImageMemoryBarrier];
    ): void {.preload("vkCmdWaitEvents"), cmdchain.}
proc cmdPipelineBarrier*(
      commandBuffer: CommandBuffer;
      srcStageMask = default(PipelineStageFlags);
      dstStageMask = default(PipelineStageFlags);
      dependencyFlags = default(DependencyFlags);
      memoryBarrierCount = default(uint32);
      pMemoryBarriers {.length: memoryBarrierCount.}: arrPtr[MemoryBarrier];
      bufferMemoryBarrierCount = default(uint32);
      pBufferMemoryBarriers {.length: bufferMemoryBarrierCount.}: arrPtr[BufferMemoryBarrier];
      imageMemoryBarrierCount = default(uint32);
      pImageMemoryBarriers {.length: imageMemoryBarrierCount.}: arrPtr[ImageMemoryBarrier];
    ): void {.preload("vkCmdPipelineBarrier"), cmdchain.}
proc cmdBeginQuery*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      query: uint32;
      flags = default(QueryControlFlags);
    ): void {.preload("vkCmdBeginQuery"), cmdchain.}
proc cmdEndQuery*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      query: uint32;
    ): void {.preload("vkCmdEndQuery"), cmdchain.}
proc cmdResetQueryPool*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      firstQuery: uint32;
      queryCount: uint32;
    ): void {.preload("vkCmdResetQueryPool"), cmdchain.}
proc cmdWriteTimestamp*(
      commandBuffer: CommandBuffer;
      pipelineStage: PipelineStageFlagBits;
      queryPool: QueryPool;
      query: uint32;
    ): void {.preload("vkCmdWriteTimestamp"), cmdchain.}
proc cmdCopyQueryPoolResults*(
      commandBuffer: CommandBuffer;
      queryPool: QueryPool;
      firstQuery: uint32;
      queryCount: uint32;
      dstBuffer: Buffer;
      dstOffset: DeviceSize;
      stride: DeviceSize;
      flags = default(QueryResultFlags);
    ): void {.preload("vkCmdCopyQueryPoolResults"), cmdchain.}
proc cmdPushConstants*(
      commandBuffer: CommandBuffer;
      layout: PipelineLayout;
      stageFlags: ShaderStageFlags;
      offset: uint32;
      size: uint32;
      pValues {.length: size.}: pointer;
    ): void {.preload("vkCmdPushConstants"), cmdchain.}
proc cmdBeginRenderPass*(
      commandBuffer: CommandBuffer;
      pRenderPassBegin: ptr RenderPassBeginInfo;
      contents: SubpassContents;
    ): void {.preload("vkCmdBeginRenderPass"), cmdchain.}
proc cmdNextSubpass*(
      commandBuffer: CommandBuffer;
      contents: SubpassContents;
    ): void {.preload("vkCmdNextSubpass"), cmdchain.}
proc cmdEndRenderPass*(
      commandBuffer: CommandBuffer;
    ): void {.preload("vkCmdEndRenderPass"), cmdchain.}
proc cmdExecuteCommands*(
      commandBuffer: CommandBuffer;
      commandBufferCount: uint32;
      pCommandBuffers {.length: commandBufferCount.}: arrPtr[CommandBuffer];
    ): void {.preload("vkCmdExecuteCommands"), cmdchain.}

