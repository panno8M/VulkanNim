# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.

# VK_NV_ray_tracing

import ../tools
const
  # VK_NV_ray_tracing
  NvRayTracingSpecVersion* = 3
  NvRayTracingExtensionName* = "VK_NV_ray_tracing"


# VK_NV_ray_tracing
# =================
proc createAccelerationStructureNV*(
      device: Device;
      pCreateInfo: ptr AccelerationStructureCreateInfoNV;
      pAllocator = default(ptr AllocationCallbacks);
      pAccelerationStructure: ptr AccelerationStructureNV;
    ): Result {.lazyload("vkCreateAccelerationStructureNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory].}
proc destroyAccelerationStructureNV*(
      device: Device;
      accelerationStructure = default(AccelerationStructureNV);
      pAllocator = default(ptr AllocationCallbacks);
    ): void {.lazyload("vkDestroyAccelerationStructureNV", DeviceLevel).}
proc getAccelerationStructureMemoryRequirementsNV*(
      device: Device;
      pInfo: ptr AccelerationStructureMemoryRequirementsInfoNV;
      pMemoryRequirements: ptr MemoryRequirements2KHR;
    ): void {.lazyload("vkGetAccelerationStructureMemoryRequirementsNV", DeviceLevel).}
proc bindAccelerationStructureMemoryNV*(
      device: Device;
      bindInfoCount: uint32;
      pBindInfos {.length: bindInfoCount.}: arrPtr[BindAccelerationStructureMemoryInfoNV];
    ): Result {.lazyload("vkBindAccelerationStructureMemoryNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdBuildAccelerationStructureNV*(
      commandBuffer: CommandBuffer;
      pInfo: ptr AccelerationStructureInfoNV;
      instanceData = default(Buffer);
      instanceOffset: DeviceSize;
      update: Bool32;
      dst: AccelerationStructureNV;
      src = default(AccelerationStructureNV);
      scratch: Buffer;
      scratchOffset: DeviceSize;
    ): void {.lazyload("vkCmdBuildAccelerationStructureNV", DeviceLevel),
      queues: QueueFlags{compute}, cmdchain.}
proc cmdCopyAccelerationStructureNV*(
      commandBuffer: CommandBuffer;
      dst: AccelerationStructureNV;
      src: AccelerationStructureNV;
      mode: CopyAccelerationStructureModeKHR;
    ): void {.lazyload("vkCmdCopyAccelerationStructureNV", DeviceLevel),
      queues: QueueFlags{compute}, cmdchain.}
proc cmdTraceRaysNV*(
      commandBuffer: CommandBuffer;
      raygenShaderBindingTableBuffer: Buffer;
      raygenShaderBindingOffset: DeviceSize;
      missShaderBindingTableBuffer = default(Buffer);
      missShaderBindingOffset: DeviceSize;
      missShaderBindingStride: DeviceSize;
      hitShaderBindingTableBuffer = default(Buffer);
      hitShaderBindingOffset: DeviceSize;
      hitShaderBindingStride: DeviceSize;
      callableShaderBindingTableBuffer = default(Buffer);
      callableShaderBindingOffset: DeviceSize;
      callableShaderBindingStride: DeviceSize;
      width: uint32;
      height: uint32;
      depth: uint32;
    ): void {.lazyload("vkCmdTraceRaysNV", DeviceLevel),
      queues: QueueFlags{compute}, cmdchain.}
proc createRayTracingPipelinesNV*(
      device: Device;
      pipelineCache = default(PipelineCache);
      createInfoCount: uint32;
      pCreateInfos {.length: createInfoCount.}: arrPtr[RayTracingPipelineCreateInfoNV];
      pAllocator = default(ptr AllocationCallbacks);
      pPipelines {.length: createInfoCount.}: arrPtr[Pipeline];
    ): Result {.lazyload("vkCreateRayTracingPipelinesNV", DeviceLevel),
      successCodes: @[Result.success, Result.pipelineCompileRequiredExt],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory, Result.errorInvalidShaderNv].}
template getRayTracingShaderGroupHandlesNV* = getRayTracingShaderGroupHandlesKHR
proc getAccelerationStructureHandleNV*(
      device: Device;
      accelerationStructure: AccelerationStructureNV;
      dataSize: uint;
      pData {.length: dataSize.}: pointer;
    ): Result {.lazyload("vkGetAccelerationStructureHandleNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc cmdWriteAccelerationStructuresPropertiesNV*(
      commandBuffer: CommandBuffer;
      accelerationStructureCount: uint32;
      pAccelerationStructures {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureNV];
      queryType: QueryType;
      queryPool: QueryPool;
      firstQuery: uint32;
    ): void {.lazyload("vkCmdWriteAccelerationStructuresPropertiesNV", DeviceLevel),
      queues: QueueFlags{compute}, cmdchain.}
proc compileDeferredNV*(
      device: Device;
      pipeline: Pipeline;
      shader: uint32;
    ): Result {.lazyload("vkCompileDeferredNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}


proc loadAllVK_NV_ray_tracing*(instance: Instance) = instance.loadCommands:
  createAccelerationStructureNV
  destroyAccelerationStructureNV
  getAccelerationStructureMemoryRequirementsNV
  bindAccelerationStructureMemoryNV
  cmdBuildAccelerationStructureNV
  cmdCopyAccelerationStructureNV
  cmdTraceRaysNV
  createRayTracingPipelinesNV
  getAccelerationStructureHandleNV
  cmdWriteAccelerationStructuresPropertiesNV
  compileDeferredNV
proc loadVK_NV_ray_tracing*(device: Device) = device.loadCommands:
  createAccelerationStructureNV
  destroyAccelerationStructureNV
  getAccelerationStructureMemoryRequirementsNV
  bindAccelerationStructureMemoryNV
  cmdBuildAccelerationStructureNV
  cmdCopyAccelerationStructureNV
  cmdTraceRaysNV
  createRayTracingPipelinesNV
  getAccelerationStructureHandleNV
  cmdWriteAccelerationStructuresPropertiesNV
  compileDeferredNV