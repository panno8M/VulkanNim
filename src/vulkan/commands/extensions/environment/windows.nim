# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.

# VK_KHR_win32_surface
# VK_NV_external_memory_win32
# VK_NV_win32_keyed_mutex
# VK_KHR_external_memory_win32
# VK_KHR_win32_keyed_mutex
# VK_KHR_external_semaphore_win32
# VK_KHR_external_fence_win32

import ../../tools
const
  # VK_KHR_win32_surface
  KhrWin32SurfaceSpecVersion* = 6
  KhrWin32SurfaceExtensionName* = "VK_KHR_win32_surface"
  # VK_NV_external_memory_win32
  NvExternalMemoryWin32SpecVersion* = 1
  NvExternalMemoryWin32ExtensionName* = "VK_NV_external_memory_win32"
  # VK_NV_win32_keyed_mutex
  NvWin32KeyedMutexSpecVersion* = 2
  NvWin32KeyedMutexExtensionName* = "VK_NV_win32_keyed_mutex"
  # VK_KHR_external_memory_win32
  KhrExternalMemoryWin32SpecVersion* = 1
  KhrExternalMemoryWin32ExtensionName* = "VK_KHR_external_memory_win32"
  # VK_KHR_win32_keyed_mutex
  KhrWin32KeyedMutexSpecVersion* = 1
  KhrWin32KeyedMutexExtensionName* = "VK_KHR_win32_keyed_mutex"
  # VK_KHR_external_semaphore_win32
  KhrExternalSemaphoreWin32SpecVersion* = 1
  KhrExternalSemaphoreWin32ExtensionName* = "VK_KHR_external_semaphore_win32"
  # VK_KHR_external_fence_win32
  KhrExternalFenceWin32SpecVersion* = 1
  KhrExternalFenceWin32ExtensionName* = "VK_KHR_external_fence_win32"


# VK_KHR_win32_surface
# ====================
proc createWin32SurfaceKHR*(
      instance: Instance;
      pCreateInfo: ptr Win32SurfaceCreateInfoKHR;
      pAllocator = default(ptr AllocationCallbacks);
      pSurface: ptr SurfaceKHR;
    ): Result {.lazyload("vkCreateWin32SurfaceKHR", InstanceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorOutOfDeviceMemory].}
proc getPhysicalDeviceWin32PresentationSupportKHR*(
      physicalDevice: PhysicalDevice;
      queueFamilyIndex: uint32;
    ): Bool32 {.lazyload("vkGetPhysicalDeviceWin32PresentationSupportKHR", InstanceLevel).}

# VK_NV_external_memory_win32
# ===========================
proc getMemoryWin32HandleNV*(
      device: Device;
      memory: DeviceMemory;
      handleType: ExternalMemoryHandleTypeFlagsNV;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetMemoryWin32HandleNV", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_external_memory_win32
# ============================
proc getMemoryWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr MemoryGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetMemoryWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}
proc getMemoryWin32HandlePropertiesKHR*(
      device: Device;
      handleType: ExternalMemoryHandleTypeFlagBits;
      handle: Win32Handle;
      pMemoryWin32HandleProperties: ptr MemoryWin32HandlePropertiesKHR;
    ): Result {.lazyload("vkGetMemoryWin32HandlePropertiesKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}

# VK_KHR_external_semaphore_win32
# ===============================
proc importSemaphoreWin32HandleKHR*(
      device: Device;
      pImportSemaphoreWin32HandleInfo: ptr ImportSemaphoreWin32HandleInfoKHR;
    ): Result {.lazyload("vkImportSemaphoreWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getSemaphoreWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr SemaphoreGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetSemaphoreWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}

# VK_KHR_external_fence_win32
# ===========================
proc importFenceWin32HandleKHR*(
      device: Device;
      pImportFenceWin32HandleInfo: ptr ImportFenceWin32HandleInfoKHR;
    ): Result {.lazyload("vkImportFenceWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorOutOfHostMemory, Result.errorInvalidExternalHandle].}
proc getFenceWin32HandleKHR*(
      device: Device;
      pGetWin32HandleInfo: ptr FenceGetWin32HandleInfoKHR;
      pHandle: ptr Win32Handle;
    ): Result {.lazyload("vkGetFenceWin32HandleKHR", DeviceLevel),
      successCodes: @[Result.success],
      errorCodes: @[Result.errorTooManyObjects, Result.errorOutOfHostMemory].}


proc loadAllVK_KHR_win32_surface*(instance: Instance) = instance.loadCommands:
  createWin32SurfaceKHR
  getPhysicalDeviceWin32PresentationSupportKHR
proc loadAllVK_NV_external_memory_win32*(instance: Instance) = instance.loadCommands:
  getMemoryWin32HandleNV
proc loadAllVK_KHR_external_memory_win32*(instance: Instance) = instance.loadCommands:
  getMemoryWin32HandleKHR
  getMemoryWin32HandlePropertiesKHR
proc loadAllVK_KHR_external_semaphore_win32*(instance: Instance) = instance.loadCommands:
  importSemaphoreWin32HandleKHR
  getSemaphoreWin32HandleKHR
proc loadAllVK_KHR_external_fence_win32*(instance: Instance) = instance.loadCommands:
  importFenceWin32HandleKHR
  getFenceWin32HandleKHR
proc loadVK_KHR_win32_surface*(instance: Instance) = instance.loadCommands:
  createWin32SurfaceKHR
  getPhysicalDeviceWin32PresentationSupportKHR
proc loadVK_NV_external_memory_win32*(device: Device) = device.loadCommands:
  getMemoryWin32HandleNV
proc loadVK_KHR_external_memory_win32*(device: Device) = device.loadCommands:
  getMemoryWin32HandleKHR
  getMemoryWin32HandlePropertiesKHR
proc loadVK_KHR_external_semaphore_win32*(device: Device) = device.loadCommands:
  importSemaphoreWin32HandleKHR
  getSemaphoreWin32HandleKHR
proc loadVK_KHR_external_fence_win32*(device: Device) = device.loadCommands:
  importFenceWin32HandleKHR
  getFenceWin32HandleKHR