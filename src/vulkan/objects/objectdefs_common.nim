# This file is generated by the program.
# Note that any changes to this file will be reset by the execution of
# the generated program.
import tools
import temp_externalobjects
{.push byref.}
type
  # VERSION 1 0
  # ===========
  # Fundamental types used by many commands and structures
  Extent2D* = object
    width*: uint32
    height*: uint32
  Extent3D* = object
    width*: uint32
    height*: uint32
    depth*: uint32
  Offset2D* = object
    x*: int32
    y*: int32
  Offset3D* = object
    x*: int32
    y*: int32
    z*: int32
  Rect2D* = object
    offset*: Offset2D
    extent*: Extent2D
  # These types are part of the API, though not directly used in API commands or data structures
  BaseInStructure* = object
    sType*: StructureType
    pNext* {.optional.}: ptr BaseInStructure
  BaseOutStructure* = object
    sType*: StructureType
    pNext* {.optional.}: ptr BaseOutStructure
  BufferMemoryBarrier* = object
    sType* {.constant: (StructureType.bufferMemoryBarrier).}: StructureType
    pNext* {.optional.}: pointer
    srcAccessMask*: AccessFlags # Memory accesses from the source of the dependency to synchronize
    dstAccessMask*: AccessFlags # Memory accesses from the destination of the dependency to synchronize
    srcQueueFamilyIndex*: uint32 # Queue family to transition ownership from
    dstQueueFamilyIndex*: uint32 # Queue family to transition ownership to
    buffer*: Buffer # Buffer to sync
    offset*: DeviceSize # Offset within the buffer to sync
    size*: DeviceSize # Amount of bytes to sync
  DispatchIndirectCommand* = object
    x*: uint32
    y*: uint32
    z*: uint32
  DrawIndexedIndirectCommand* = object
    indexCount*: uint32
    instanceCount*: uint32
    firstIndex*: uint32
    vertexOffset*: int32
    firstInstance*: uint32
  DrawIndirectCommand* = object
    vertexCount*: uint32
    instanceCount*: uint32
    firstVertex*: uint32
    firstInstance*: uint32
  ImageMemoryBarrier* = object
    sType* {.constant: (StructureType.imageMemoryBarrier).}: StructureType
    pNext* {.optional.}: pointer
    srcAccessMask*: AccessFlags # Memory accesses from the source of the dependency to synchronize
    dstAccessMask*: AccessFlags # Memory accesses from the destination of the dependency to synchronize
    oldLayout*: ImageLayout # Current layout of the image
    newLayout*: ImageLayout # New layout to transition the image to
    srcQueueFamilyIndex*: uint32 # Queue family to transition ownership from
    dstQueueFamilyIndex*: uint32 # Queue family to transition ownership to
    image*: Image # Image to sync
    subresourceRange*: ImageSubresourceRange # Subresource range to sync
  MemoryBarrier* = object
    sType* {.constant: (StructureType.memoryBarrier).}: StructureType
    pNext* {.optional.}: pointer
    srcAccessMask* {.optional.}: AccessFlags # Memory accesses from the source of the dependency to synchronize
    dstAccessMask* {.optional.}: AccessFlags # Memory accesses from the destination of the dependency to synchronize
  # The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.
  PipelineCacheHeaderVersionOne* = object
    headerSize*: uint32
    headerVersion*: PipelineCacheHeaderVersion
    vendorID*: uint32
    deviceID*: uint32
    pipelineCacheUUID*: array[UuidSize, uint8]
  # Device initialization
  PFN_AllocationFunction* = proc(
      pUserData: pointer;
      size: uint;
      alignment: uint;
      allocationScope: SystemAllocationScope;
    ): pointer {.cdecl.}
  PFN_FreeFunction* = proc(
      pUserData: pointer;
      pMemory: pointer;
    ): void {.cdecl.}
  PFN_InternalAllocationNotification* = proc(
      pUserData: pointer;
      size: uint;
      allocationType: InternalAllocationType;
      allocationScope: SystemAllocationScope;
    ): void {.cdecl.}
  PFN_InternalFreeNotification* = proc(
      pUserData: pointer;
      size: uint;
      allocationType: InternalAllocationType;
      allocationScope: SystemAllocationScope;
    ): void {.cdecl.}
  PFN_ReallocationFunction* = proc(
      pUserData: pointer;
      pOriginal: pointer;
      size: uint;
      alignment: uint;
      allocationScope: SystemAllocationScope;
    ): pointer {.cdecl.}
  PFN_VoidFunction* = proc(): void {.cdecl.}
  AllocationCallbacks* = object
    pUserData* {.optional.}: pointer
    pfnAllocation*: PFN_AllocationFunction
    pfnReallocation*: PFN_ReallocationFunction
    pfnFree*: PFN_FreeFunction
    pfnInternalAllocation* {.optional.}: PFN_InternalAllocationNotification
    pfnInternalFree* {.optional.}: PFN_InternalFreeNotification
  ApplicationInfo* = object
    sType* {.constant: (StructureType.applicationInfo).}: StructureType
    pNext* {.optional.}: pointer
    pApplicationName* {.optional.}: cstring
    applicationVersion*: uint32
    pEngineName* {.optional.}: cstring
    engineVersion*: uint32
    apiVersion*: ApiVersion
  FormatProperties* = object
    linearTilingFeatures* {.optional.}: FormatFeatureFlags # Format features in case of linear tiling
    optimalTilingFeatures* {.optional.}: FormatFeatureFlags # Format features in case of optimal tiling
    bufferFeatures* {.optional.}: FormatFeatureFlags # Format features supported by buffers
  ImageFormatProperties* = object
    maxExtent*: Extent3D # max image dimensions for this resource type
    maxMipLevels*: uint32 # max number of mipmap levels for this resource type
    maxArrayLayers*: uint32 # max array size for this resource type
    sampleCounts* {.optional.}: SampleCountFlags # supported sample counts for this resource type
    maxResourceSize*: DeviceSize # max size (in bytes) of this resource type
  InstanceCreateInfo* = object
    sType* {.constant: (StructureType.instanceCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: InstanceCreateFlags
    pApplicationInfo* {.optional.}: ptr ApplicationInfo
    enabledLayerCount* {.optional.}: uint32
    ppEnabledLayerNames* {.length: enabledLayerCount.}: cstringArray # Ordered list of layer names to be enabled
    enabledExtensionCount* {.optional.}: uint32
    ppEnabledExtensionNames* {.length: enabledExtensionCount.}: cstringArray # Extension names to be enabled
  MemoryHeap* = object
    size*: DeviceSize # Available memory in the heap
    flags* {.optional.}: MemoryHeapFlags # Flags for the heap
  MemoryType* = object
    propertyFlags* {.optional.}: MemoryPropertyFlags # Memory properties of this memory type
    heapIndex*: uint32 # Index of the memory heap allocations of this memory type are taken from
  PhysicalDeviceFeatures* = object
    robustBufferAccess*: Bool32 # out of bounds buffer accesses are well defined
    fullDrawIndexUint32*: Bool32 # full 32-bit range of indices for indexed draw calls
    imageCubeArray*: Bool32 # image views which are arrays of cube maps
    independentBlend*: Bool32 # blending operations are controlled per-attachment
    geometryShader*: Bool32 # geometry stage
    tessellationShader*: Bool32 # tessellation control and evaluation stage
    sampleRateShading*: Bool32 # per-sample shading and interpolation
    dualSrcBlend*: Bool32 # blend operations which take two sources
    logicOp*: Bool32 # logic operations
    multiDrawIndirect*: Bool32 # multi draw indirect
    drawIndirectFirstInstance*: Bool32 # indirect drawing can use non-zero firstInstance
    depthClamp*: Bool32 # depth clamping
    depthBiasClamp*: Bool32 # depth bias clamping
    fillModeNonSolid*: Bool32 # point and wireframe fill modes
    depthBounds*: Bool32 # depth bounds test
    wideLines*: Bool32 # lines with width greater than 1
    largePoints*: Bool32 # points with size greater than 1
    alphaToOne*: Bool32 # the fragment alpha component can be forced to maximum representable alpha value
    multiViewport*: Bool32 # viewport arrays
    samplerAnisotropy*: Bool32 # anisotropic sampler filtering
    textureCompressionETC2*: Bool32 # ETC texture compression formats
    textureCompressionASTC_LDR*: Bool32 # ASTC LDR texture compression formats
    textureCompressionBC*: Bool32 # BC1-7 texture compressed formats
    occlusionQueryPrecise*: Bool32 # precise occlusion queries returning actual sample counts
    pipelineStatisticsQuery*: Bool32 # pipeline statistics query
    vertexPipelineStoresAndAtomics*: Bool32 # stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    fragmentStoresAndAtomics*: Bool32 # stores and atomic ops on storage buffers and images are supported in the fragment stage
    shaderTessellationAndGeometryPointSize*: Bool32 # tessellation and geometry stages can export point size
    shaderImageGatherExtended*: Bool32 # image gather with run-time values and independent offsets
    shaderStorageImageExtendedFormats*: Bool32 # the extended set of formats can be used for storage images
    shaderStorageImageMultisample*: Bool32 # multisample images can be used for storage images
    shaderStorageImageReadWithoutFormat*: Bool32 # read from storage image does not require format qualifier
    shaderStorageImageWriteWithoutFormat*: Bool32 # write to storage image does not require format qualifier
    shaderUniformBufferArrayDynamicIndexing*: Bool32 # arrays of uniform buffers can be accessed with dynamically uniform indices
    shaderSampledImageArrayDynamicIndexing*: Bool32 # arrays of sampled images can be accessed with dynamically uniform indices
    shaderStorageBufferArrayDynamicIndexing*: Bool32 # arrays of storage buffers can be accessed with dynamically uniform indices
    shaderStorageImageArrayDynamicIndexing*: Bool32 # arrays of storage images can be accessed with dynamically uniform indices
    shaderClipDistance*: Bool32 # clip distance in shaders
    shaderCullDistance*: Bool32 # cull distance in shaders
    shaderFloat64*: Bool32 # 64-bit floats (doubles) in shaders
    shaderInt64*: Bool32 # 64-bit integers in shaders
    shaderInt16*: Bool32 # 16-bit integers in shaders
    shaderResourceResidency*: Bool32 # shader can use texture operations that return resource residency information (requires sparseNonResident support)
    shaderResourceMinLod*: Bool32 # shader can use texture operations that specify minimum resource LOD
    sparseBinding*: Bool32 # Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    sparseResidencyBuffer*: Bool32 # Sparse resources support: GPU can access partially resident buffers 
    sparseResidencyImage2D*: Bool32 # Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images 
    sparseResidencyImage3D*: Bool32 # Sparse resources support: GPU can access partially resident 3D images 
    sparseResidency2Samples*: Bool32 # Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    sparseResidency4Samples*: Bool32 # Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    sparseResidency8Samples*: Bool32 # Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    sparseResidency16Samples*: Bool32 # Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    sparseResidencyAliased*: Bool32 # Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    variableMultisampleRate*: Bool32 # multisample rate must be the same for all pipelines in a subpass
    inheritedQueries*: Bool32 # Queries may be inherited from primary to secondary command buffers
  # resource maximum sizes
  PhysicalDeviceLimits* = object
    maxImageDimension1D*: uint32 # max 1D image dimension
    maxImageDimension2D*: uint32 # max 2D image dimension
    maxImageDimension3D*: uint32 # max 3D image dimension
    maxImageDimensionCube*: uint32 # max cubemap image dimension
    maxImageArrayLayers*: uint32 # max layers for image arrays
    maxTexelBufferElements*: uint32 # max texel buffer size (fstexels)
    maxUniformBufferRange*: uint32 # max uniform buffer range (bytes)
    maxStorageBufferRange*: uint32 # max storage buffer range (bytes)
    maxPushConstantsSize*: uint32 # max size of the push constants pool (bytes)
    maxMemoryAllocationCount*: uint32 # max number of device memory allocations supported
    maxSamplerAllocationCount*: uint32 # max number of samplers that can be allocated on a device
    bufferImageGranularity*: DeviceSize # Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    sparseAddressSpaceSize*: DeviceSize # Total address space available for sparse allocations (bytes)
    maxBoundDescriptorSets*: uint32 # max number of descriptors sets that can be bound to a pipeline
    maxPerStageDescriptorSamplers*: uint32 # max number of samplers allowed per-stage in a descriptor set
    maxPerStageDescriptorUniformBuffers*: uint32 # max number of uniform buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageBuffers*: uint32 # max number of storage buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorSampledImages*: uint32 # max number of sampled images allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageImages*: uint32 # max number of storage images allowed per-stage in a descriptor set
    maxPerStageDescriptorInputAttachments*: uint32 # max number of input attachments allowed per-stage in a descriptor set
    maxPerStageResources*: uint32 # max number of resources allowed by a single stage
    maxDescriptorSetSamplers*: uint32 # max number of samplers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffers*: uint32 # max number of uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffersDynamic*: uint32 # max number of dynamic uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffers*: uint32 # max number of storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffersDynamic*: uint32 # max number of dynamic storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetSampledImages*: uint32 # max number of sampled images allowed in all stages in a descriptor set
    maxDescriptorSetStorageImages*: uint32 # max number of storage images allowed in all stages in a descriptor set
    maxDescriptorSetInputAttachments*: uint32 # max number of input attachments allowed in all stages in a descriptor set
    maxVertexInputAttributes*: uint32 # max number of vertex input attribute slots
    maxVertexInputBindings*: uint32 # max number of vertex input binding slots
    maxVertexInputAttributeOffset*: uint32 # max vertex input attribute offset added to vertex buffer offset
    maxVertexInputBindingStride*: uint32 # max vertex input binding stride
    maxVertexOutputComponents*: uint32 # max number of output components written by vertex shader
    maxTessellationGenerationLevel*: uint32 # max level supported by tessellation primitive generator
    maxTessellationPatchSize*: uint32 # max patch size (vertices)
    maxTessellationControlPerVertexInputComponents*: uint32 # max number of input components per-vertex in TCS
    maxTessellationControlPerVertexOutputComponents*: uint32 # max number of output components per-vertex in TCS
    maxTessellationControlPerPatchOutputComponents*: uint32 # max number of output components per-patch in TCS
    maxTessellationControlTotalOutputComponents*: uint32 # max total number of per-vertex and per-patch output components in TCS
    maxTessellationEvaluationInputComponents*: uint32 # max number of input components per vertex in TES
    maxTessellationEvaluationOutputComponents*: uint32 # max number of output components per vertex in TES
    maxGeometryShaderInvocations*: uint32 # max invocation count supported in geometry shader
    maxGeometryInputComponents*: uint32 # max number of input components read in geometry stage
    maxGeometryOutputComponents*: uint32 # max number of output components written in geometry stage
    maxGeometryOutputVertices*: uint32 # max number of vertices that can be emitted in geometry stage
    maxGeometryTotalOutputComponents*: uint32 # max total number of components (all vertices) written in geometry stage
    maxFragmentInputComponents*: uint32 # max number of input components read in fragment stage
    maxFragmentOutputAttachments*: uint32 # max number of output attachments written in fragment stage
    maxFragmentDualSrcAttachments*: uint32 # max number of output attachments written when using dual source blending
    maxFragmentCombinedOutputResources*: uint32 # max total number of storage buffers, storage images and output buffers
    maxComputeSharedMemorySize*: uint32 # max total storage size of work group local storage (bytes)
    maxComputeWorkGroupCount*: array[3, uint32] # max num of compute work groups that may be dispatched by a single command (x,y,z)
    maxComputeWorkGroupInvocations*: uint32 # max total compute invocations in a single local work group
    maxComputeWorkGroupSize*: array[3, uint32] # max local size of a compute work group (x,y,z)
    subPixelPrecisionBits*: uint32 # number bits of subpixel precision in screen x and y
    subTexelPrecisionBits*: uint32 # number bits of precision for selecting texel weights
    mipmapPrecisionBits*: uint32 # number bits of precision for selecting mipmap weights
    maxDrawIndexedIndexValue*: uint32 # max index value for indexed draw calls (for 32-bit indices)
    maxDrawIndirectCount*: uint32 # max draw count for indirect drawing calls
    maxSamplerLodBias*: float32 # max absolute sampler LOD bias
    maxSamplerAnisotropy*: float32 # max degree of sampler anisotropy
    maxViewports*: uint32 # max number of active viewports
    maxViewportDimensions*: array[2, uint32] # max viewport dimensions (x,y)
    viewportBoundsRange*: array[2, float32] # viewport bounds range (min,max)
    viewportSubPixelBits*: uint32 # number bits of subpixel precision for viewport
    minMemoryMapAlignment*: uint # min required alignment of pointers returned by MapMemory (bytes)
    minTexelBufferOffsetAlignment*: DeviceSize # min required alignment for texel buffer offsets (bytes) 
    minUniformBufferOffsetAlignment*: DeviceSize # min required alignment for uniform buffer sizes and offsets (bytes)
    minStorageBufferOffsetAlignment*: DeviceSize # min required alignment for storage buffer offsets (bytes)
    minTexelOffset*: int32 # min texel offset for OpTextureSampleOffset
    maxTexelOffset*: uint32 # max texel offset for OpTextureSampleOffset
    minTexelGatherOffset*: int32 # min texel offset for OpTextureGatherOffset
    maxTexelGatherOffset*: uint32 # max texel offset for OpTextureGatherOffset
    minInterpolationOffset*: float32 # furthest negative offset for interpolateAtOffset
    maxInterpolationOffset*: float32 # furthest positive offset for interpolateAtOffset
    subPixelInterpolationOffsetBits*: uint32 # number of subpixel bits for interpolateAtOffset
    maxFramebufferWidth*: uint32 # max width for a framebuffer
    maxFramebufferHeight*: uint32 # max height for a framebuffer
    maxFramebufferLayers*: uint32 # max layer count for a layered framebuffer
    framebufferColorSampleCounts* {.optional.}: SampleCountFlags # supported color sample counts for a framebuffer
    framebufferDepthSampleCounts* {.optional.}: SampleCountFlags # supported depth sample counts for a framebuffer
    framebufferStencilSampleCounts* {.optional.}: SampleCountFlags # supported stencil sample counts for a framebuffer
    framebufferNoAttachmentsSampleCounts* {.optional.}: SampleCountFlags # supported sample counts for a subpass which uses no attachments
    maxColorAttachments*: uint32 # max number of color attachments per subpass
    sampledImageColorSampleCounts* {.optional.}: SampleCountFlags # supported color sample counts for a non-integer sampled image
    sampledImageIntegerSampleCounts* {.optional.}: SampleCountFlags # supported sample counts for an integer image
    sampledImageDepthSampleCounts* {.optional.}: SampleCountFlags # supported depth sample counts for a sampled image
    sampledImageStencilSampleCounts* {.optional.}: SampleCountFlags # supported stencil sample counts for a sampled image
    storageImageSampleCounts* {.optional.}: SampleCountFlags # supported sample counts for a storage image
    maxSampleMaskWords*: uint32 # max number of sample mask words
    timestampComputeAndGraphics*: Bool32 # timestamps on graphics and compute queues
    timestampPeriod*: float32 # number of nanoseconds it takes for timestamp query value to increment by 1
    maxClipDistances*: uint32 # max number of clip distances
    maxCullDistances*: uint32 # max number of cull distances
    maxCombinedClipAndCullDistances*: uint32 # max combined number of user clipping
    discreteQueuePriorities*: uint32 # distinct queue priorities available 
    pointSizeRange*: array[2, float32] # range (min,max) of supported point sizes
    lineWidthRange*: array[2, float32] # range (min,max) of supported line widths
    pointSizeGranularity*: float32 # granularity of supported point sizes
    lineWidthGranularity*: float32 # granularity of supported line widths
    strictLines*: Bool32 # line rasterization follows preferred rules
    standardSampleLocations*: Bool32 # supports standard sample locations for all supported sample counts
    optimalBufferCopyOffsetAlignment*: DeviceSize # optimal offset of buffer copies
    optimalBufferCopyRowPitchAlignment*: DeviceSize # optimal pitch of buffer copies
    nonCoherentAtomSize*: DeviceSize # minimum size and alignment for non-coherent host-mapped device memory access
  PhysicalDeviceMemoryProperties* = object
    memoryTypeCount*: uint32
    memoryTypes*: array[MaxMemoryTypes, MemoryType]
    memoryHeapCount*: uint32
    memoryHeaps*: array[MaxMemoryHeaps, MemoryHeap]
  PhysicalDeviceProperties* = object
    apiVersion*: ApiVersion
    driverVersion*: uint32
    vendorID*: uint32
    deviceID*: uint32
    deviceType*: PhysicalDeviceType
    deviceName*: array[MaxPhysicalDeviceNameSize, char]
    pipelineCacheUUID*: array[UuidSize, uint8]
    limits*: PhysicalDeviceLimits
    sparseProperties*: PhysicalDeviceSparseProperties
  PhysicalDeviceSparseProperties* = object
    residencyStandard2DBlockShape*: Bool32 # Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DMultisampleBlockShape*: Bool32 # Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard3DBlockShape*: Bool32 # Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyAlignedMipSize*: Bool32 # Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    residencyNonResidentStrict*: Bool32 # Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
  QueueFamilyProperties* = object
    queueFlags* {.optional.}: QueueFlags # Queue flags
    queueCount*: uint32
    timestampValidBits*: uint32
    minImageTransferGranularity*: Extent3D # Minimum alignment requirement for image transfers
  # Device commands
  DeviceCreateInfo* = object
    sType* {.constant: (StructureType.deviceCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DeviceCreateFlags
    queueCreateInfoCount*: uint32
    pQueueCreateInfos* {.length: queueCreateInfoCount.}: arrPtr[DeviceQueueCreateInfo]
    enabledLayerCount* {.optional.}: uint32
    ppEnabledLayerNames* {.length: enabledLayerCount.}: cstringArray # Ordered list of layer names to be enabled
    enabledExtensionCount* {.optional.}: uint32
    ppEnabledExtensionNames* {.length: enabledExtensionCount.}: cstringArray
    pEnabledFeatures* {.optional.}: ptr PhysicalDeviceFeatures
  DeviceQueueCreateInfo* = object
    sType* {.constant: (StructureType.deviceQueueCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DeviceQueueCreateFlags
    queueFamilyIndex*: uint32
    queueCount*: uint32
    pQueuePriorities* {.length: queueCount.}: arrPtr[float32]
  # Extension discovery commands
  ExtensionProperties* = object
    extensionName*: array[MaxExtensionNameSize, char] # extension name
    specVersion*: uint32 # version of the extension specification implemented
  # Layer discovery commands
  LayerProperties* = object
    layerName*: array[MaxExtensionNameSize, char] # layer name
    specVersion*: uint32 # version of the layer specification implemented
    implementationVersion*: uint32 # build or release version of the layer's library
    description*: array[MaxDescriptionSize, char] # Free-form description of the layer
  # Queue commands
  SubmitInfo* = object
    sType* {.constant: (StructureType.submitInfo).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreCount* {.optional.}: uint32
    pWaitSemaphores* {.length: waitSemaphoreCount.}: arrPtr[Semaphore]
    pWaitDstStageMask* {.length: waitSemaphoreCount.}: arrPtr[PipelineStageFlags]
    commandBufferCount* {.optional.}: uint32
    pCommandBuffers* {.length: commandBufferCount.}: arrPtr[CommandBuffer]
    signalSemaphoreCount* {.optional.}: uint32
    pSignalSemaphores* {.length: signalSemaphoreCount.}: arrPtr[Semaphore]
  # Memory commands
  MappedMemoryRange* = object
    sType* {.constant: (StructureType.mappedMemoryRange).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory # Mapped memory object
    offset*: DeviceSize # Offset within the memory object where the range starts
    size*: DeviceSize # Size of the range within the memory object
  MemoryAllocateInfo* = object
    sType* {.constant: (StructureType.memoryAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    allocationSize*: DeviceSize # Size of memory allocation
    memoryTypeIndex*: uint32 # Index of the of the memory type to allocate from
  # Memory management API commands
  MemoryRequirements* = object
    size*: DeviceSize # Specified in bytes
    alignment*: DeviceSize # Specified in bytes
    memoryTypeBits*: uint32 # Bitmask of the allowed memory type indices into memoryTypes[] for this object
  # Sparse resource memory management API commands
  BindSparseInfo* = object
    sType* {.constant: (StructureType.bindSparseInfo).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreCount* {.optional.}: uint32
    pWaitSemaphores* {.length: waitSemaphoreCount.}: arrPtr[Semaphore]
    bufferBindCount* {.optional.}: uint32
    pBufferBinds* {.length: bufferBindCount.}: arrPtr[SparseBufferMemoryBindInfo]
    imageOpaqueBindCount* {.optional.}: uint32
    pImageOpaqueBinds* {.length: imageOpaqueBindCount.}: arrPtr[SparseImageOpaqueMemoryBindInfo]
    imageBindCount* {.optional.}: uint32
    pImageBinds* {.length: imageBindCount.}: arrPtr[SparseImageMemoryBindInfo]
    signalSemaphoreCount* {.optional.}: uint32
    pSignalSemaphores* {.length: signalSemaphoreCount.}: arrPtr[Semaphore]
  ImageSubresource* = object
    aspectMask*: ImageAspectFlags
    mipLevel*: uint32
    arrayLayer*: uint32
  SparseBufferMemoryBindInfo* = object
    buffer*: Buffer
    bindCount*: uint32
    pBinds* {.length: bindCount.}: arrPtr[SparseMemoryBind]
  SparseImageFormatProperties* = object
    aspectMask* {.optional.}: ImageAspectFlags
    imageGranularity*: Extent3D
    flags* {.optional.}: SparseImageFormatFlags
  SparseImageMemoryBind* = object
    subresource*: ImageSubresource
    offset*: Offset3D
    extent*: Extent3D
    memory* {.optional.}: DeviceMemory
    memoryOffset*: DeviceSize # Specified in bytes
    flags* {.optional.}: SparseMemoryBindFlags
  SparseImageMemoryBindInfo* = object
    image*: Image
    bindCount*: uint32
    pBinds* {.length: bindCount.}: arrPtr[SparseImageMemoryBind]
  SparseImageMemoryRequirements* = object
    formatProperties*: SparseImageFormatProperties
    imageMipTailFirstLod*: uint32
    imageMipTailSize*: DeviceSize # Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailOffset*: DeviceSize # Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailStride*: DeviceSize # Specified in bytes, must be a multiple of sparse block size in bytes / alignment
  SparseImageOpaqueMemoryBindInfo* = object
    image*: Image
    bindCount*: uint32
    pBinds* {.length: bindCount.}: arrPtr[SparseMemoryBind]
  SparseMemoryBind* = object
    resourceOffset*: DeviceSize # Specified in bytes
    size*: DeviceSize # Specified in bytes
    memory* {.optional.}: DeviceMemory
    memoryOffset*: DeviceSize # Specified in bytes
    flags* {.optional.}: SparseMemoryBindFlags
  # Fence commands
  FenceCreateInfo* = object
    sType* {.constant: (StructureType.fenceCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: FenceCreateFlags # Fence creation flags
  # Queue semaphore commands
  SemaphoreCreateInfo* = object
    sType* {.constant: (StructureType.semaphoreCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SemaphoreCreateFlags # Semaphore creation flags
  # Event commands
  EventCreateInfo* = object
    sType* {.constant: (StructureType.eventCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: EventCreateFlags # Event creation flags
  # Query commands
  QueryPoolCreateInfo* = object
    sType* {.constant: (StructureType.queryPoolCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: QueryPoolCreateFlags
    queryType*: QueryType
    queryCount*: uint32
    pipelineStatistics* {.optional.}: QueryPipelineStatisticFlags # Optional
  # Buffer commands
  BufferCreateInfo* = object
    sType* {.constant: (StructureType.bufferCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: BufferCreateFlags # Buffer creation flags
    size*: DeviceSize # Specified in bytes
    usage*: BufferUsageFlags # Buffer usage flags
    sharingMode*: SharingMode
    queueFamilyIndexCount* {.optional.}: uint32
    pQueueFamilyIndices* {.length: queueFamilyIndexCount.}: arrPtr[uint32]
  # Buffer view commands
  BufferViewCreateInfo* = object
    sType* {.constant: (StructureType.bufferViewCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: BufferViewCreateFlags
    buffer*: Buffer
    format*: Format # Optionally specifies format of elements
    offset*: DeviceSize # Specified in bytes
    range*: DeviceSize # View size specified in bytes
  # Image commands
  ImageCreateInfo* = object
    sType* {.constant: (StructureType.imageCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ImageCreateFlags # Image creation flags
    imageType*: ImageType
    format*: Format
    extent*: Extent3D
    mipLevels*: uint32
    arrayLayers*: uint32
    samples*: SampleCountFlagBits
    tiling*: ImageTiling
    usage*: ImageUsageFlags # Image usage flags
    sharingMode*: SharingMode # Cross-queue-family sharing mode
    queueFamilyIndexCount* {.optional.}: uint32 # Number of queue families to share across
    pQueueFamilyIndices* {.length: queueFamilyIndexCount.}: arrPtr[uint32] # Array of queue family indices to share across
    initialLayout*: ImageLayout # Initial image layout for all subresources
  SubresourceLayout* = object
    offset*: DeviceSize # Specified in bytes
    size*: DeviceSize # Specified in bytes
    rowPitch*: DeviceSize # Specified in bytes
    arrayPitch*: DeviceSize # Specified in bytes
    depthPitch*: DeviceSize # Specified in bytes
  # Image view commands
  ComponentMapping* = object
    r*: ComponentSwizzle
    g*: ComponentSwizzle
    b*: ComponentSwizzle
    a*: ComponentSwizzle
  ImageSubresourceRange* = object
    aspectMask*: ImageAspectFlags
    baseMipLevel*: uint32
    levelCount*: uint32
    baseArrayLayer*: uint32
    layerCount*: uint32
  ImageViewCreateInfo* = object
    sType* {.constant: (StructureType.imageViewCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ImageViewCreateFlags
    image*: Image
    viewType*: ImageViewType
    format*: Format
    components*: ComponentMapping
    subresourceRange*: ImageSubresourceRange
  # Shader commands
  ShaderModuleCreateInfo* = object
    sType* {.constant: (StructureType.shaderModuleCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ShaderModuleCreateFlags
    codeSize*: uint # Specified in bytes
    pCode* {.length: codeSize / 4.}: arrPtr[uint32] # Binary code of size codeSize
  # Pipeline Cache commands
  PipelineCacheCreateInfo* = object
    sType* {.constant: (StructureType.pipelineCacheCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCacheCreateFlags
    initialDataSize* {.optional.}: uint # Size of initial data to populate cache, in bytes
    pInitialData* {.length: initialDataSize.}: pointer # Initial data to populate cache
  # Pipeline commands
  ComputePipelineCreateInfo* = object
    sType* {.constant: (StructureType.computePipelineCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCreateFlags # Pipeline creation flags
    stage*: PipelineShaderStageCreateInfo
    layout*: PipelineLayout # Interface layout of the pipeline
    basePipelineHandle* {.optional.}: Pipeline # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex*: int32 # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  GraphicsPipelineCreateInfo* = object
    sType* {.constant: (StructureType.graphicsPipelineCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCreateFlags # Pipeline creation flags
    stageCount*: uint32
    pStages* {.length: stageCount.}: arrPtr[PipelineShaderStageCreateInfo] # One entry for each active shader stage
    pVertexInputState* {.optional.}: ptr PipelineVertexInputStateCreateInfo
    pInputAssemblyState* {.optional.}: ptr PipelineInputAssemblyStateCreateInfo
    pTessellationState* {.optional.}: ptr PipelineTessellationStateCreateInfo
    pViewportState* {.optional.}: ptr PipelineViewportStateCreateInfo
    pRasterizationState*: ptr PipelineRasterizationStateCreateInfo
    pMultisampleState* {.optional.}: ptr PipelineMultisampleStateCreateInfo
    pDepthStencilState* {.optional.}: ptr PipelineDepthStencilStateCreateInfo
    pColorBlendState* {.optional.}: ptr PipelineColorBlendStateCreateInfo
    pDynamicState* {.optional.}: ptr PipelineDynamicStateCreateInfo
    layout*: PipelineLayout # Interface layout of the pipeline
    renderPass* {.optional.}: RenderPass
    subpass*: uint32
    basePipelineHandle* {.optional.}: Pipeline # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex*: int32 # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  PipelineColorBlendAttachmentState* = object
    blendEnable*: Bool32
    srcColorBlendFactor*: BlendFactor
    dstColorBlendFactor*: BlendFactor
    colorBlendOp*: BlendOp
    srcAlphaBlendFactor*: BlendFactor
    dstAlphaBlendFactor*: BlendFactor
    alphaBlendOp*: BlendOp
    colorWriteMask* {.optional.}: ColorComponentFlags
  PipelineColorBlendStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineColorBlendStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineColorBlendStateCreateFlags
    logicOpEnable*: Bool32
    logicOp*: LogicOp
    attachmentCount* {.optional.}: uint32 # # of pAttachments
    pAttachments* {.length: attachmentCount.}: arrPtr[PipelineColorBlendAttachmentState]
    blendConstants*: array[4, float32]
  PipelineDepthStencilStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineDepthStencilStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineDepthStencilStateCreateFlags
    depthTestEnable*: Bool32
    depthWriteEnable*: Bool32
    depthCompareOp*: CompareOp
    depthBoundsTestEnable*: Bool32 # optional (depth_bounds_test)
    stencilTestEnable*: Bool32
    front*: StencilOpState
    back*: StencilOpState
    minDepthBounds*: float32
    maxDepthBounds*: float32
  PipelineDynamicStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineDynamicStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineDynamicStateCreateFlags
    dynamicStateCount* {.optional.}: uint32
    pDynamicStates* {.length: dynamicStateCount.}: arrPtr[DynamicState]
  PipelineInputAssemblyStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineInputAssemblyStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineInputAssemblyStateCreateFlags
    topology*: PrimitiveTopology
    primitiveRestartEnable*: Bool32
  PipelineMultisampleStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineMultisampleStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineMultisampleStateCreateFlags
    rasterizationSamples*: SampleCountFlagBits # Number of samples used for rasterization
    sampleShadingEnable*: Bool32 # optional (GL45)
    minSampleShading*: float32 # optional (GL45)
    pSampleMask* {.optional, length: (rasterizationSamples + 31) / 32.}: arrPtr[SampleMask] # Array of sampleMask words
    alphaToCoverageEnable*: Bool32
    alphaToOneEnable*: Bool32
  PipelineRasterizationStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineRasterizationStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineRasterizationStateCreateFlags
    depthClampEnable*: Bool32
    rasterizerDiscardEnable*: Bool32
    polygonMode*: PolygonMode # optional (GL45)
    cullMode* {.optional.}: CullModeFlags
    frontFace*: FrontFace
    depthBiasEnable*: Bool32
    depthBiasConstantFactor*: float32
    depthBiasClamp*: float32
    depthBiasSlopeFactor*: float32
    lineWidth*: float32
  PipelineShaderStageCreateInfo* = object
    sType* {.constant: (StructureType.pipelineShaderStageCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineShaderStageCreateFlags
    stage*: ShaderStageFlagBits # Shader stage
    module*: ShaderModule # Module containing entry point
    pName*: cstring # Null-terminated entry point name
    pSpecializationInfo* {.optional.}: ptr SpecializationInfo
  PipelineTessellationStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineTessellationStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineTessellationStateCreateFlags
    patchControlPoints*: uint32
  PipelineVertexInputStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineVertexInputStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineVertexInputStateCreateFlags
    vertexBindingDescriptionCount* {.optional.}: uint32 # number of bindings
    pVertexBindingDescriptions* {.length: vertexBindingDescriptionCount.}: arrPtr[VertexInputBindingDescription]
    vertexAttributeDescriptionCount* {.optional.}: uint32 # number of attributes
    pVertexAttributeDescriptions* {.length: vertexAttributeDescriptionCount.}: arrPtr[VertexInputAttributeDescription]
  PipelineViewportStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineViewportStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineViewportStateCreateFlags
    viewportCount* {.optional.}: uint32
    pViewports* {.optional, length: viewportCount.}: arrPtr[Viewport]
    scissorCount* {.optional.}: uint32
    pScissors* {.optional, length: scissorCount.}: arrPtr[Rect2D]
  SpecializationInfo* = object
    mapEntryCount* {.optional.}: uint32 # Number of entries in the map
    pMapEntries* {.length: mapEntryCount.}: arrPtr[SpecializationMapEntry] # Array of map entries
    dataSize* {.optional.}: uint # Size in bytes of pData
    pData* {.length: dataSize.}: pointer # Pointer to SpecConstant data
  SpecializationMapEntry* = object
    constantID*: uint32 # The SpecConstant ID specified in the BIL
    offset*: uint32 # Offset of the value in the data block
    size*: uint # Size in bytes of the SpecConstant
  StencilOpState* = object
    failOp*: StencilOp
    passOp*: StencilOp
    depthFailOp*: StencilOp
    compareOp*: CompareOp
    compareMask*: uint32
    writeMask*: uint32
    reference*: uint32
  VertexInputAttributeDescription* = object
    location*: uint32 # location of the shader vertex attrib
    binding*: uint32 # Vertex buffer binding id
    format*: Format # format of source data
    offset*: uint32 # Offset of first element in bytes from base of vertex
  VertexInputBindingDescription* = object
    binding*: uint32 # Vertex buffer binding id
    stride*: uint32 # Distance between vertices in bytes (0 = no advancement)
    inputRate*: VertexInputRate # The rate at which the vertex data is consumed
  Viewport* = object
    x*: float32
    y*: float32
    width*: float32
    height*: float32
    minDepth*: float32
    maxDepth*: float32
  # Pipeline layout commands
  PipelineLayoutCreateInfo* = object
    sType* {.constant: (StructureType.pipelineLayoutCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineLayoutCreateFlags
    setLayoutCount* {.optional.}: uint32 # Number of descriptor sets interfaced by the pipeline
    pSetLayouts* {.length: setLayoutCount.}: arrPtr[DescriptorSetLayout] # Array of setCount number of descriptor set layout objects defining the layout of the
    pushConstantRangeCount* {.optional.}: uint32 # Number of push-constant ranges used by the pipeline
    pPushConstantRanges* {.length: pushConstantRangeCount.}: arrPtr[PushConstantRange] # Array of pushConstantRangeCount number of ranges used by various shader stages
  PushConstantRange* = object
    stageFlags*: ShaderStageFlags # Which stages use the range
    offset*: uint32 # Start of the range, in bytes
    size*: uint32 # Size of the range, in bytes
  # Sampler commands
  SamplerCreateInfo* = object
    sType* {.constant: (StructureType.samplerCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SamplerCreateFlags
    magFilter*: Filter # Filter mode for magnification
    minFilter*: Filter # Filter mode for minifiation
    mipmapMode*: SamplerMipmapMode # Mipmap selection mode
    addressModeU*: SamplerAddressMode
    addressModeV*: SamplerAddressMode
    addressModeW*: SamplerAddressMode
    mipLodBias*: float32
    anisotropyEnable*: Bool32
    maxAnisotropy*: float32
    compareEnable*: Bool32
    compareOp*: CompareOp
    minLod*: float32
    maxLod*: float32
    borderColor*: BorderColor
    unnormalizedCoordinates*: Bool32
  # Descriptor set commands
  CopyDescriptorSet* = object
    sType* {.constant: (StructureType.copyDescriptorSet).}: StructureType
    pNext* {.optional.}: pointer
    srcSet*: DescriptorSet # Source descriptor set
    srcBinding*: uint32 # Binding within the source descriptor set to copy from
    srcArrayElement*: uint32 # Array element within the source binding to copy from
    dstSet*: DescriptorSet # Destination descriptor set
    dstBinding*: uint32 # Binding within the destination descriptor set to copy to
    dstArrayElement*: uint32 # Array element within the destination binding to copy to
    descriptorCount*: uint32 # Number of descriptors to write (determines the size of the array pointed by pDescriptors)
  DescriptorBufferInfo* = object
    buffer* {.optional.}: Buffer # Buffer used for this descriptor slot.
    offset*: DeviceSize # Base offset from buffer start in bytes to update in the descriptor set.
    range*: DeviceSize # Size in bytes of the buffer resource for this descriptor update.
  DescriptorImageInfo* = object
    sampler*: Sampler # Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    imageView*: ImageView # Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    imageLayout*: ImageLayout # Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
  DescriptorPoolCreateInfo* = object
    sType* {.constant: (StructureType.descriptorPoolCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DescriptorPoolCreateFlags
    maxSets*: uint32
    poolSizeCount*: uint32
    pPoolSizes* {.length: poolSizeCount.}: arrPtr[DescriptorPoolSize]
  DescriptorPoolSize* = object
    theType*: DescriptorType
    descriptorCount*: uint32
  DescriptorSetAllocateInfo* = object
    sType* {.constant: (StructureType.descriptorSetAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    descriptorPool*: DescriptorPool
    descriptorSetCount*: uint32
    pSetLayouts* {.length: descriptorSetCount.}: arrPtr[DescriptorSetLayout]
  DescriptorSetLayoutBinding* = object
    binding*: uint32 # Binding number for this entry
    descriptorType*: DescriptorType # Type of the descriptors in this binding
    descriptorCount* {.optional.}: uint32 # Number of descriptors in this binding
    stageFlags*: ShaderStageFlags # Shader stages this binding is visible to
    pImmutableSamplers* {.optional, length: descriptorCount.}: arrPtr[Sampler] # Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
  DescriptorSetLayoutCreateInfo* = object
    sType* {.constant: (StructureType.descriptorSetLayoutCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DescriptorSetLayoutCreateFlags
    bindingCount* {.optional.}: uint32 # Number of bindings in the descriptor set layout
    pBindings* {.length: bindingCount.}: arrPtr[DescriptorSetLayoutBinding] # Array of descriptor set layout bindings
  WriteDescriptorSet* = object
    sType* {.constant: (StructureType.writeDescriptorSet).}: StructureType
    pNext* {.optional.}: pointer
    dstSet*: DescriptorSet # Destination descriptor set
    dstBinding*: uint32 # Binding within the destination descriptor set to write
    dstArrayElement*: uint32 # Array element within the destination binding to write
    descriptorCount*: uint32 # Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorType*: DescriptorType # Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    pImageInfo* {.length: descriptorCount.}: arrPtr[DescriptorImageInfo] # Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pBufferInfo* {.length: descriptorCount.}: arrPtr[DescriptorBufferInfo] # Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pTexelBufferView* {.length: descriptorCount.}: arrPtr[BufferView] # Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
  # Pass commands
  AttachmentDescription* = object
    flags* {.optional.}: AttachmentDescriptionFlags
    format*: Format
    samples*: SampleCountFlagBits
    loadOp*: AttachmentLoadOp # Load operation for color or depth data
    storeOp*: AttachmentStoreOp # Store operation for color or depth data
    stencilLoadOp*: AttachmentLoadOp # Load operation for stencil data
    stencilStoreOp*: AttachmentStoreOp # Store operation for stencil data
    initialLayout*: ImageLayout
    finalLayout*: ImageLayout
  AttachmentReference* = object
    attachment*: uint32
    layout*: ImageLayout
  FramebufferCreateInfo* = object
    sType* {.constant: (StructureType.framebufferCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: FramebufferCreateFlags
    renderPass*: RenderPass
    attachmentCount* {.optional.}: uint32
    pAttachments* {.length: attachmentCount.}: arrPtr[ImageView]
    width*: uint32
    height*: uint32
    layers*: uint32
  RenderPassCreateInfo* = object
    sType* {.constant: (StructureType.renderPassCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: RenderPassCreateFlags
    attachmentCount* {.optional.}: uint32
    pAttachments* {.length: attachmentCount.}: arrPtr[AttachmentDescription]
    subpassCount*: uint32
    pSubpasses* {.length: subpassCount.}: arrPtr[SubpassDescription]
    dependencyCount* {.optional.}: uint32
    pDependencies* {.length: dependencyCount.}: arrPtr[SubpassDependency]
  SubpassDependency* = object
    srcSubpass*: uint32
    dstSubpass*: uint32
    srcStageMask* {.optional.}: PipelineStageFlags
    dstStageMask* {.optional.}: PipelineStageFlags
    srcAccessMask* {.optional.}: AccessFlags # Memory accesses from the source of the dependency to synchronize
    dstAccessMask* {.optional.}: AccessFlags # Memory accesses from the destination of the dependency to synchronize
    dependencyFlags* {.optional.}: DependencyFlags
  SubpassDescription* = object
    flags* {.optional.}: SubpassDescriptionFlags
    pipelineBindPoint*: PipelineBindPoint # Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    inputAttachmentCount* {.optional.}: uint32
    pInputAttachments* {.length: inputAttachmentCount.}: arrPtr[AttachmentReference]
    colorAttachmentCount* {.optional.}: uint32
    pColorAttachments* {.length: colorAttachmentCount.}: arrPtr[AttachmentReference]
    pResolveAttachments* {.optional, length: colorAttachmentCount.}: arrPtr[AttachmentReference]
    pDepthStencilAttachment* {.optional.}: ptr AttachmentReference
    preserveAttachmentCount* {.optional.}: uint32
    pPreserveAttachments* {.length: preserveAttachmentCount.}: arrPtr[uint32]
  # Command pool commands
  CommandPoolCreateInfo* = object
    sType* {.constant: (StructureType.commandPoolCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: CommandPoolCreateFlags # Command pool creation flags
    queueFamilyIndex*: uint32
  # Command buffer commands
  CommandBufferAllocateInfo* = object
    sType* {.constant: (StructureType.commandBufferAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    commandPool*: CommandPool
    level*: CommandBufferLevel
    commandBufferCount*: uint32
  CommandBufferBeginInfo* = object
    sType* {.constant: (StructureType.commandBufferBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: CommandBufferUsageFlags # Command buffer usage flags
    pInheritanceInfo* {.optional.}: ptr CommandBufferInheritanceInfo # Pointer to inheritance info for secondary command buffers
  CommandBufferInheritanceInfo* = object
    sType* {.constant: (StructureType.commandBufferInheritanceInfo).}: StructureType
    pNext* {.optional.}: pointer
    renderPass* {.optional.}: RenderPass # Render pass for secondary command buffers
    subpass*: uint32
    framebuffer* {.optional.}: Framebuffer # Framebuffer for secondary command buffers
    occlusionQueryEnable*: Bool32 # Whether this secondary command buffer may be executed during an occlusion query
    queryFlags* {.optional.}: QueryControlFlags # Query flags used by this secondary command buffer, if executed during an occlusion query
    pipelineStatistics* {.optional.}: QueryPipelineStatisticFlags # Pipeline statistics that may be counted for this secondary command buffer
  # Command buffer building commands
  BufferCopy* = object
    srcOffset*: DeviceSize # Specified in bytes
    dstOffset*: DeviceSize # Specified in bytes
    size*: DeviceSize # Specified in bytes
  BufferImageCopy* = object
    bufferOffset*: DeviceSize # Specified in bytes
    bufferRowLength*: uint32 # Specified in texels
    bufferImageHeight*: uint32
    imageSubresource*: ImageSubresourceLayers
    imageOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    imageExtent*: Extent3D # Specified in pixels for both compressed and uncompressed images
  ClearAttachment* = object
    aspectMask*: ImageAspectFlags
    colorAttachment*: uint32
    clearValue*: ClearValue
  ClearColorValue* {.union.} = object
    float32*: array[4, float32]
    int32*: array[4, int32]
    uint32*: array[4, uint32]
  ClearDepthStencilValue* = object
    depth*: float32
    stencil*: uint32
  ClearRect* = object
    rect*: Rect2D
    baseArrayLayer*: uint32
    layerCount*: uint32
  ClearValue* {.union.} = object
    color*: ClearColorValue
    depthStencil*: ClearDepthStencilValue
  ImageBlit* = object
    srcSubresource*: ImageSubresourceLayers
    srcOffsets*: array[2, Offset3D] # Specified in pixels for both compressed and uncompressed images
    dstSubresource*: ImageSubresourceLayers
    dstOffsets*: array[2, Offset3D] # Specified in pixels for both compressed and uncompressed images
  ImageCopy* = object
    srcSubresource*: ImageSubresourceLayers
    srcOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    dstSubresource*: ImageSubresourceLayers
    dstOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    extent*: Extent3D # Specified in pixels for both compressed and uncompressed images
  ImageResolve* = object
    srcSubresource*: ImageSubresourceLayers
    srcOffset*: Offset3D
    dstSubresource*: ImageSubresourceLayers
    dstOffset*: Offset3D
    extent*: Extent3D
  ImageSubresourceLayers* = object
    aspectMask*: ImageAspectFlags
    mipLevel*: uint32
    baseArrayLayer*: uint32
    layerCount*: uint32
  RenderPassBeginInfo* = object
    sType* {.constant: (StructureType.renderPassBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    renderPass*: RenderPass
    framebuffer*: Framebuffer
    renderArea*: Rect2D
    clearValueCount* {.optional.}: uint32
    pClearValues* {.length: clearValueCount.}: arrPtr[ClearValue]
  # VERSION 1 1
  # ===========
  # Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95
  PhysicalDeviceSubgroupProperties* = object
    sType* {.constant: (StructureType.physicalDeviceSubgroupProperties).}: StructureType
    pNext* {.optional.}: pointer
    subgroupSize*: uint32 # The size of a subgroup for this queue.
    supportedStages*: ShaderStageFlags # Bitfield of what shader stages support subgroup operations
    supportedOperations*: SubgroupFeatureFlags # Bitfield of what subgroup operations are supported.
    quadOperationsInAllStages*: Bool32 # Flag to specify whether quad operations are available in all stages.
  # Promoted from VK_KHR_bind_memory2
  BindBufferMemoryInfo* = object
    sType* {.constant: (StructureType.bindBufferMemoryInfo).}: StructureType
    pNext* {.optional.}: pointer
    buffer*: Buffer
    memory*: DeviceMemory
    memoryOffset*: DeviceSize
  BindImageMemoryInfo* = object
    sType* {.constant: (StructureType.bindImageMemoryInfo).}: StructureType
    pNext* {.optional.}: pointer
    image*: Image
    memory*: DeviceMemory
    memoryOffset*: DeviceSize
  # Promoted from VK_KHR_16bit_storage
  PhysicalDevice16BitStorageFeatures* = object
    sType* {.constant: (StructureType.physicalDevice16bitStorageFeatures).}: StructureType
    pNext* {.optional.}: pointer
    storageBuffer16BitAccess*: Bool32 # 16-bit integer/floating-point variables supported in BufferBlock
    uniformAndStorageBuffer16BitAccess*: Bool32 # 16-bit integer/floating-point variables supported in BufferBlock and Block
    storagePushConstant16*: Bool32 # 16-bit integer/floating-point variables supported in PushConstant
    storageInputOutput16*: Bool32 # 16-bit integer/floating-point variables supported in shader inputs and outputs
  # Promoted from VK_KHR_dedicated_allocation
  MemoryDedicatedRequirements* = object
    sType* {.constant: (StructureType.memoryDedicatedRequirements).}: StructureType
    pNext* {.optional.}: pointer
    prefersDedicatedAllocation*: Bool32
    requiresDedicatedAllocation*: Bool32
  MemoryDedicatedAllocateInfo* = object
    sType* {.constant: (StructureType.memoryDedicatedAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    image* {.optional.}: Image # Image that this allocation will be bound to
    buffer* {.optional.}: Buffer # Buffer that this allocation will be bound to
  # Promoted from VK_KHR_device_group
  MemoryAllocateFlagsInfo* = object
    sType* {.constant: (StructureType.memoryAllocateFlagsInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: MemoryAllocateFlags
    deviceMask*: uint32
  DeviceGroupRenderPassBeginInfo* = object
    sType* {.constant: (StructureType.deviceGroupRenderPassBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    deviceMask*: uint32
    deviceRenderAreaCount* {.optional.}: uint32
    pDeviceRenderAreas* {.length: deviceRenderAreaCount.}: arrPtr[Rect2D]
  DeviceGroupCommandBufferBeginInfo* = object
    sType* {.constant: (StructureType.deviceGroupCommandBufferBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    deviceMask*: uint32
  DeviceGroupSubmitInfo* = object
    sType* {.constant: (StructureType.deviceGroupSubmitInfo).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreCount* {.optional.}: uint32
    pWaitSemaphoreDeviceIndices* {.length: waitSemaphoreCount.}: arrPtr[uint32]
    commandBufferCount* {.optional.}: uint32
    pCommandBufferDeviceMasks* {.length: commandBufferCount.}: arrPtr[uint32]
    signalSemaphoreCount* {.optional.}: uint32
    pSignalSemaphoreDeviceIndices* {.length: signalSemaphoreCount.}: arrPtr[uint32]
  DeviceGroupBindSparseInfo* = object
    sType* {.constant: (StructureType.deviceGroupBindSparseInfo).}: StructureType
    pNext* {.optional.}: pointer
    resourceDeviceIndex*: uint32
    memoryDeviceIndex*: uint32
  # Promoted from VK_KHR_device_group + VK_KHR_bind_memory2
  BindBufferMemoryDeviceGroupInfo* = object
    sType* {.constant: (StructureType.bindBufferMemoryDeviceGroupInfo).}: StructureType
    pNext* {.optional.}: pointer
    deviceIndexCount* {.optional.}: uint32
    pDeviceIndices* {.length: deviceIndexCount.}: arrPtr[uint32]
  BindImageMemoryDeviceGroupInfo* = object
    sType* {.constant: (StructureType.bindImageMemoryDeviceGroupInfo).}: StructureType
    pNext* {.optional.}: pointer
    deviceIndexCount* {.optional.}: uint32
    pDeviceIndices* {.length: deviceIndexCount.}: arrPtr[uint32]
    splitInstanceBindRegionCount* {.optional.}: uint32
    pSplitInstanceBindRegions* {.length: splitInstanceBindRegionCount.}: arrPtr[Rect2D]
  # Promoted from VK_KHR_device_group_creation
  PhysicalDeviceGroupProperties* = object
    sType* {.constant: (StructureType.physicalDeviceGroupProperties).}: StructureType
    pNext* {.optional.}: pointer
    physicalDeviceCount*: uint32
    physicalDevices*: array[MaxDeviceGroupSize, PhysicalDevice]
    subsetAllocation*: Bool32
  DeviceGroupDeviceCreateInfo* = object
    sType* {.constant: (StructureType.deviceGroupDeviceCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    physicalDeviceCount* {.optional.}: uint32
    pPhysicalDevices* {.length: physicalDeviceCount.}: arrPtr[PhysicalDevice]
  # Promoted from VK_KHR_get_memory_requirements2
  BufferMemoryRequirementsInfo2* = object
    sType* {.constant: (StructureType.bufferMemoryRequirementsInfo2).}: StructureType
    pNext* {.optional.}: pointer
    buffer*: Buffer
  ImageMemoryRequirementsInfo2* = object
    sType* {.constant: (StructureType.imageMemoryRequirementsInfo2).}: StructureType
    pNext* {.optional.}: pointer
    image*: Image
  ImageSparseMemoryRequirementsInfo2* = object
    sType* {.constant: (StructureType.imageSparseMemoryRequirementsInfo2).}: StructureType
    pNext* {.optional.}: pointer
    image*: Image
  MemoryRequirements2* = object
    sType* {.constant: (StructureType.memoryRequirements2).}: StructureType
    pNext* {.optional.}: pointer
    memoryRequirements*: MemoryRequirements
  SparseImageMemoryRequirements2* = object
    sType* {.constant: (StructureType.sparseImageMemoryRequirements2).}: StructureType
    pNext* {.optional.}: pointer
    memoryRequirements*: SparseImageMemoryRequirements
  # Promoted from VK_KHR_get_physical_device_properties2
  PhysicalDeviceFeatures2* = object
    sType* {.constant: (StructureType.physicalDeviceFeatures2).}: StructureType
    pNext* {.optional.}: pointer
    features*: PhysicalDeviceFeatures
  PhysicalDeviceProperties2* = object
    sType* {.constant: (StructureType.physicalDeviceProperties2).}: StructureType
    pNext* {.optional.}: pointer
    properties*: PhysicalDeviceProperties
  FormatProperties2* = object
    sType* {.constant: (StructureType.formatProperties2).}: StructureType
    pNext* {.optional.}: pointer
    formatProperties*: FormatProperties
  ImageFormatProperties2* = object
    sType* {.constant: (StructureType.imageFormatProperties2).}: StructureType
    pNext* {.optional.}: pointer
    imageFormatProperties*: ImageFormatProperties
  PhysicalDeviceImageFormatInfo2* = object
    sType* {.constant: (StructureType.physicalDeviceImageFormatInfo2).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
    theType*: ImageType
    tiling*: ImageTiling
    usage*: ImageUsageFlags
    flags* {.optional.}: ImageCreateFlags
  QueueFamilyProperties2* = object
    sType* {.constant: (StructureType.queueFamilyProperties2).}: StructureType
    pNext* {.optional.}: pointer
    queueFamilyProperties*: QueueFamilyProperties
  PhysicalDeviceMemoryProperties2* = object
    sType* {.constant: (StructureType.physicalDeviceMemoryProperties2).}: StructureType
    pNext* {.optional.}: pointer
    memoryProperties*: PhysicalDeviceMemoryProperties
  SparseImageFormatProperties2* = object
    sType* {.constant: (StructureType.sparseImageFormatProperties2).}: StructureType
    pNext* {.optional.}: pointer
    properties*: SparseImageFormatProperties
  PhysicalDeviceSparseImageFormatInfo2* = object
    sType* {.constant: (StructureType.physicalDeviceSparseImageFormatInfo2).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
    theType*: ImageType
    samples*: SampleCountFlagBits
    usage*: ImageUsageFlags
    tiling*: ImageTiling
  # Promoted from VK_KHR_maintenance2
  PhysicalDevicePointClippingProperties* = object
    sType* {.constant: (StructureType.physicalDevicePointClippingProperties).}: StructureType
    pNext* {.optional.}: pointer
    pointClippingBehavior*: PointClippingBehavior
  RenderPassInputAttachmentAspectCreateInfo* = object
    sType* {.constant: (StructureType.renderPassInputAttachmentAspectCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    aspectReferenceCount*: uint32
    pAspectReferences* {.length: aspectReferenceCount.}: arrPtr[InputAttachmentAspectReference]
  InputAttachmentAspectReference* = object
    subpass*: uint32
    inputAttachmentIndex*: uint32
    aspectMask*: ImageAspectFlags
  ImageViewUsageCreateInfo* = object
    sType* {.constant: (StructureType.imageViewUsageCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    usage*: ImageUsageFlags
  PipelineTessellationDomainOriginStateCreateInfo* = object
    sType* {.constant: (StructureType.pipelineTessellationDomainOriginStateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    domainOrigin*: TessellationDomainOrigin
  # Promoted from VK_KHR_multiview
  RenderPassMultiviewCreateInfo* = object
    sType* {.constant: (StructureType.renderPassMultiviewCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    subpassCount* {.optional.}: uint32
    pViewMasks* {.length: subpassCount.}: arrPtr[uint32]
    dependencyCount* {.optional.}: uint32
    pViewOffsets* {.length: dependencyCount.}: arrPtr[int32]
    correlationMaskCount* {.optional.}: uint32
    pCorrelationMasks* {.length: correlationMaskCount.}: arrPtr[uint32]
  PhysicalDeviceMultiviewFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceMultiviewFeatures).}: StructureType
    pNext* {.optional.}: pointer
    multiview*: Bool32 # Multiple views in a renderpass
    multiviewGeometryShader*: Bool32 # Multiple views in a renderpass w/ geometry shader
    multiviewTessellationShader*: Bool32 # Multiple views in a renderpass w/ tessellation shader
  PhysicalDeviceMultiviewProperties* = object
    sType* {.constant: (StructureType.physicalDeviceMultiviewProperties).}: StructureType
    pNext* {.optional.}: pointer
    maxMultiviewViewCount*: uint32 # max number of views in a subpass
    maxMultiviewInstanceIndex*: uint32 # max instance index for a draw in a multiview subpass
  # Promoted from VK_KHR_variable_pointers
  PhysicalDeviceVariablePointerFeatures* = object
  PhysicalDeviceVariablePointersFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceVariablePointersFeatures).}: StructureType
    pNext* {.optional.}: pointer
    variablePointersStorageBuffer*: Bool32
    variablePointers*: Bool32
  # Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they were not actually promoted from an extension.
  PhysicalDeviceProtectedMemoryFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceProtectedMemoryFeatures).}: StructureType
    pNext* {.optional.}: pointer
    protectedMemory*: Bool32
  PhysicalDeviceProtectedMemoryProperties* = object
    sType* {.constant: (StructureType.physicalDeviceProtectedMemoryProperties).}: StructureType
    pNext* {.optional.}: pointer
    protectedNoFault*: Bool32
  DeviceQueueInfo2* = object
    sType* {.constant: (StructureType.deviceQueueInfo2).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DeviceQueueCreateFlags
    queueFamilyIndex*: uint32
    queueIndex*: uint32
  ProtectedSubmitInfo* = object
    sType* {.constant: (StructureType.protectedSubmitInfo).}: StructureType
    pNext* {.optional.}: pointer
    protectedSubmit*: Bool32 # Submit protected command buffers
  # Promoted from VK_KHR_sampler_ycbcr_conversion
  SamplerYcbcrConversionCreateInfo* = object
    sType* {.constant: (StructureType.samplerYcbcrConversionCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
    ycbcrModel*: SamplerYcbcrModelConversion
    ycbcrRange*: SamplerYcbcrRange
    components*: ComponentMapping
    xChromaOffset*: ChromaLocation
    yChromaOffset*: ChromaLocation
    chromaFilter*: Filter
    forceExplicitReconstruction*: Bool32
  SamplerYcbcrConversionInfo* = object
    sType* {.constant: (StructureType.samplerYcbcrConversionInfo).}: StructureType
    pNext* {.optional.}: pointer
    conversion*: SamplerYcbcrConversion
  BindImagePlaneMemoryInfo* = object
    sType* {.constant: (StructureType.bindImagePlaneMemoryInfo).}: StructureType
    pNext* {.optional.}: pointer
    planeAspect*: ImageAspectFlagBits
  ImagePlaneMemoryRequirementsInfo* = object
    sType* {.constant: (StructureType.imagePlaneMemoryRequirementsInfo).}: StructureType
    pNext* {.optional.}: pointer
    planeAspect*: ImageAspectFlagBits
  PhysicalDeviceSamplerYcbcrConversionFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceSamplerYcbcrConversionFeatures).}: StructureType
    pNext* {.optional.}: pointer
    samplerYcbcrConversion*: Bool32 # Sampler color conversion supported
  SamplerYcbcrConversionImageFormatProperties* = object
    sType* {.constant: (StructureType.samplerYcbcrConversionImageFormatProperties).}: StructureType
    pNext* {.optional.}: pointer
    combinedImageSamplerDescriptorCount*: uint32
  # Promoted from VK_KHR_descriptor_update_template
  DescriptorUpdateTemplateEntry* = object
    dstBinding*: uint32 # Binding within the destination descriptor set to write
    dstArrayElement*: uint32 # Array element within the destination binding to write
    descriptorCount*: uint32 # Number of descriptors to write
    descriptorType*: DescriptorType # Descriptor type to write
    offset*: uint # Offset into pData where the descriptors to update are stored
    stride*: uint # Stride between two descriptors in pData when writing more than one descriptor
  DescriptorUpdateTemplateCreateInfo* = object
    sType* {.constant: (StructureType.descriptorUpdateTemplateCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DescriptorUpdateTemplateCreateFlags
    descriptorUpdateEntryCount*: uint32 # Number of descriptor update entries to use for the update template
    pDescriptorUpdateEntries* {.length: descriptorUpdateEntryCount.}: arrPtr[DescriptorUpdateTemplateEntry] # Descriptor update entries for the template
    templateType*: DescriptorUpdateTemplateType
    descriptorSetLayout*: DescriptorSetLayout
    pipelineBindPoint*: PipelineBindPoint
    pipelineLayout*: PipelineLayout # If used for push descriptors, this is the only allowed layout
    set*: uint32
  # Promoted from VK_KHR_external_memory_capabilities
  ExternalMemoryProperties* = object
    externalMemoryFeatures*: ExternalMemoryFeatureFlags
    exportFromImportedHandleTypes* {.optional.}: ExternalMemoryHandleTypeFlags
    compatibleHandleTypes*: ExternalMemoryHandleTypeFlags
  PhysicalDeviceExternalImageFormatInfo* = object
    sType* {.constant: (StructureType.physicalDeviceExternalImageFormatInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleType* {.optional.}: ExternalMemoryHandleTypeFlagBits
  ExternalImageFormatProperties* = object
    sType* {.constant: (StructureType.externalImageFormatProperties).}: StructureType
    pNext* {.optional.}: pointer
    externalMemoryProperties*: ExternalMemoryProperties
  PhysicalDeviceExternalBufferInfo* = object
    sType* {.constant: (StructureType.physicalDeviceExternalBufferInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: BufferCreateFlags
    usage*: BufferUsageFlags
    handleType*: ExternalMemoryHandleTypeFlagBits
  ExternalBufferProperties* = object
    sType* {.constant: (StructureType.externalBufferProperties).}: StructureType
    pNext* {.optional.}: pointer
    externalMemoryProperties*: ExternalMemoryProperties
  PhysicalDeviceIDProperties* = object
    sType* {.constant: (StructureType.physicalDeviceIdProperties).}: StructureType
    pNext* {.optional.}: pointer
    deviceUUID*: array[UuidSize, uint8]
    driverUUID*: array[UuidSize, uint8]
    deviceLUID*: array[LuidSize, uint8]
    deviceNodeMask*: uint32
    deviceLUIDValid*: Bool32
  # Promoted from VK_KHR_external_memory
  ExternalMemoryImageCreateInfo* = object
    sType* {.constant: (StructureType.externalMemoryImageCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalMemoryHandleTypeFlags
  ExternalMemoryBufferCreateInfo* = object
    sType* {.constant: (StructureType.externalMemoryBufferCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalMemoryHandleTypeFlags
  ExportMemoryAllocateInfo* = object
    sType* {.constant: (StructureType.exportMemoryAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalMemoryHandleTypeFlags
  # Promoted from VK_KHR_external_fence_capabilities
  PhysicalDeviceExternalFenceInfo* = object
    sType* {.constant: (StructureType.physicalDeviceExternalFenceInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleType*: ExternalFenceHandleTypeFlagBits
  ExternalFenceProperties* = object
    sType* {.constant: (StructureType.externalFenceProperties).}: StructureType
    pNext* {.optional.}: pointer
    exportFromImportedHandleTypes*: ExternalFenceHandleTypeFlags
    compatibleHandleTypes*: ExternalFenceHandleTypeFlags
    externalFenceFeatures* {.optional.}: ExternalFenceFeatureFlags
  # Promoted from VK_KHR_external_fence
  ExportFenceCreateInfo* = object
    sType* {.constant: (StructureType.exportFenceCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalFenceHandleTypeFlags
  # Promoted from VK_KHR_external_semaphore
  ExportSemaphoreCreateInfo* = object
    sType* {.constant: (StructureType.exportSemaphoreCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalSemaphoreHandleTypeFlags
  # Promoted from VK_KHR_external_semaphore_capabilities
  PhysicalDeviceExternalSemaphoreInfo* = object
    sType* {.constant: (StructureType.physicalDeviceExternalSemaphoreInfo).}: StructureType
    pNext* {.optional.}: pointer
    handleType*: ExternalSemaphoreHandleTypeFlagBits
  ExternalSemaphoreProperties* = object
    sType* {.constant: (StructureType.externalSemaphoreProperties).}: StructureType
    pNext* {.optional.}: pointer
    exportFromImportedHandleTypes*: ExternalSemaphoreHandleTypeFlags
    compatibleHandleTypes*: ExternalSemaphoreHandleTypeFlags
    externalSemaphoreFeatures* {.optional.}: ExternalSemaphoreFeatureFlags
  # Promoted from VK_KHR_maintenance3
  PhysicalDeviceMaintenance3Properties* = object
    sType* {.constant: (StructureType.physicalDeviceMaintenance3Properties).}: StructureType
    pNext* {.optional.}: pointer
    maxPerSetDescriptors*: uint32
    maxMemoryAllocationSize*: DeviceSize
  DescriptorSetLayoutSupport* = object
    sType* {.constant: (StructureType.descriptorSetLayoutSupport).}: StructureType
    pNext* {.optional.}: pointer
    supported*: Bool32
  # Promoted from VK_KHR_shader_draw_parameters, with a feature support query added
  PhysicalDeviceShaderDrawParameterFeatures* = object
  PhysicalDeviceShaderDrawParametersFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceShaderDrawParametersFeatures).}: StructureType
    pNext* {.optional.}: pointer
    shaderDrawParameters*: Bool32
  # VERSION 1 2
  # ===========
  PhysicalDeviceVulkan11Features* = object
    sType* {.constant: (StructureType.physicalDeviceVulkan11Features).}: StructureType
    pNext* {.optional.}: pointer
    storageBuffer16BitAccess*: Bool32 # 16-bit integer/floating-point variables supported in BufferBlock
    uniformAndStorageBuffer16BitAccess*: Bool32 # 16-bit integer/floating-point variables supported in BufferBlock and Block
    storagePushConstant16*: Bool32 # 16-bit integer/floating-point variables supported in PushConstant
    storageInputOutput16*: Bool32 # 16-bit integer/floating-point variables supported in shader inputs and outputs
    multiview*: Bool32 # Multiple views in a renderpass
    multiviewGeometryShader*: Bool32 # Multiple views in a renderpass w/ geometry shader
    multiviewTessellationShader*: Bool32 # Multiple views in a renderpass w/ tessellation shader
    variablePointersStorageBuffer*: Bool32
    variablePointers*: Bool32
    protectedMemory*: Bool32
    samplerYcbcrConversion*: Bool32 # Sampler color conversion supported
    shaderDrawParameters*: Bool32
  PhysicalDeviceVulkan11Properties* = object
    sType* {.constant: (StructureType.physicalDeviceVulkan11Properties).}: StructureType
    pNext* {.optional.}: pointer
    deviceUUID*: array[UuidSize, uint8]
    driverUUID*: array[UuidSize, uint8]
    deviceLUID*: array[LuidSize, uint8]
    deviceNodeMask*: uint32
    deviceLUIDValid*: Bool32
    subgroupSize*: uint32 # The size of a subgroup for this queue.
    subgroupSupportedStages*: ShaderStageFlags # Bitfield of what shader stages support subgroup operations
    subgroupSupportedOperations*: SubgroupFeatureFlags # Bitfield of what subgroup operations are supported.
    subgroupQuadOperationsInAllStages*: Bool32 # Flag to specify whether quad operations are available in all stages.
    pointClippingBehavior*: PointClippingBehavior
    maxMultiviewViewCount*: uint32 # max number of views in a subpass
    maxMultiviewInstanceIndex*: uint32 # max instance index for a draw in a multiview subpass
    protectedNoFault*: Bool32
    maxPerSetDescriptors*: uint32
    maxMemoryAllocationSize*: DeviceSize
  PhysicalDeviceVulkan12Features* = object
    sType* {.constant: (StructureType.physicalDeviceVulkan12Features).}: StructureType
    pNext* {.optional.}: pointer
    samplerMirrorClampToEdge*: Bool32
    drawIndirectCount*: Bool32
    storageBuffer8BitAccess*: Bool32 # 8-bit integer variables supported in StorageBuffer
    uniformAndStorageBuffer8BitAccess*: Bool32 # 8-bit integer variables supported in StorageBuffer and Uniform
    storagePushConstant8*: Bool32 # 8-bit integer variables supported in PushConstant
    shaderBufferInt64Atomics*: Bool32
    shaderSharedInt64Atomics*: Bool32
    shaderFloat16*: Bool32 # 16-bit floats (halfs) in shaders
    shaderInt8*: Bool32 # 8-bit integers in shaders
    descriptorIndexing*: Bool32
    shaderInputAttachmentArrayDynamicIndexing*: Bool32
    shaderUniformTexelBufferArrayDynamicIndexing*: Bool32
    shaderStorageTexelBufferArrayDynamicIndexing*: Bool32
    shaderUniformBufferArrayNonUniformIndexing*: Bool32
    shaderSampledImageArrayNonUniformIndexing*: Bool32
    shaderStorageBufferArrayNonUniformIndexing*: Bool32
    shaderStorageImageArrayNonUniformIndexing*: Bool32
    shaderInputAttachmentArrayNonUniformIndexing*: Bool32
    shaderUniformTexelBufferArrayNonUniformIndexing*: Bool32
    shaderStorageTexelBufferArrayNonUniformIndexing*: Bool32
    descriptorBindingUniformBufferUpdateAfterBind*: Bool32
    descriptorBindingSampledImageUpdateAfterBind*: Bool32
    descriptorBindingStorageImageUpdateAfterBind*: Bool32
    descriptorBindingStorageBufferUpdateAfterBind*: Bool32
    descriptorBindingUniformTexelBufferUpdateAfterBind*: Bool32
    descriptorBindingStorageTexelBufferUpdateAfterBind*: Bool32
    descriptorBindingUpdateUnusedWhilePending*: Bool32
    descriptorBindingPartiallyBound*: Bool32
    descriptorBindingVariableDescriptorCount*: Bool32
    runtimeDescriptorArray*: Bool32
    samplerFilterMinmax*: Bool32
    scalarBlockLayout*: Bool32
    imagelessFramebuffer*: Bool32
    uniformBufferStandardLayout*: Bool32
    shaderSubgroupExtendedTypes*: Bool32
    separateDepthStencilLayouts*: Bool32
    hostQueryReset*: Bool32
    timelineSemaphore*: Bool32
    bufferDeviceAddress*: Bool32
    bufferDeviceAddressCaptureReplay*: Bool32
    bufferDeviceAddressMultiDevice*: Bool32
    vulkanMemoryModel*: Bool32
    vulkanMemoryModelDeviceScope*: Bool32
    vulkanMemoryModelAvailabilityVisibilityChains*: Bool32
    shaderOutputViewportIndex*: Bool32
    shaderOutputLayer*: Bool32
    subgroupBroadcastDynamicId*: Bool32
  PhysicalDeviceVulkan12Properties* = object
    sType* {.constant: (StructureType.physicalDeviceVulkan12Properties).}: StructureType
    pNext* {.optional.}: pointer
    driverID*: DriverId
    driverName*: array[MaxDriverNameSize, char]
    driverInfo*: array[MaxDriverInfoSize, char]
    conformanceVersion*: ConformanceVersion
    denormBehaviorIndependence*: ShaderFloatControlsIndependence
    roundingModeIndependence*: ShaderFloatControlsIndependence
    shaderSignedZeroInfNanPreserveFloat16*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderDenormPreserveFloat16*: Bool32 # An implementation can preserve  denormals
    shaderDenormPreserveFloat32*: Bool32 # An implementation can preserve  denormals
    shaderDenormPreserveFloat64*: Bool32 # An implementation can preserve  denormals
    shaderDenormFlushToZeroFloat16*: Bool32 # An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32*: Bool32 # An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64*: Bool32 # An implementation can flush to zero  denormals
    shaderRoundingModeRTEFloat16*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTEFloat32*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTEFloat64*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTZFloat16*: Bool32 # An implementation can support RTZ
    shaderRoundingModeRTZFloat32*: Bool32 # An implementation can support RTZ
    shaderRoundingModeRTZFloat64*: Bool32 # An implementation can support RTZ
    maxUpdateAfterBindDescriptorsInAllPools*: uint32
    shaderUniformBufferArrayNonUniformIndexingNative*: Bool32
    shaderSampledImageArrayNonUniformIndexingNative*: Bool32
    shaderStorageBufferArrayNonUniformIndexingNative*: Bool32
    shaderStorageImageArrayNonUniformIndexingNative*: Bool32
    shaderInputAttachmentArrayNonUniformIndexingNative*: Bool32
    robustBufferAccessUpdateAfterBind*: Bool32
    quadDivergentImplicitLod*: Bool32
    maxPerStageDescriptorUpdateAfterBindSamplers*: uint32
    maxPerStageDescriptorUpdateAfterBindUniformBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindSampledImages*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageImages*: uint32
    maxPerStageDescriptorUpdateAfterBindInputAttachments*: uint32
    maxPerStageUpdateAfterBindResources*: uint32
    maxDescriptorSetUpdateAfterBindSamplers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffers*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindSampledImages*: uint32
    maxDescriptorSetUpdateAfterBindStorageImages*: uint32
    maxDescriptorSetUpdateAfterBindInputAttachments*: uint32
    supportedDepthResolveModes*: ResolveModeFlags # supported depth resolve modes
    supportedStencilResolveModes*: ResolveModeFlags # supported stencil resolve modes
    independentResolveNone*: Bool32 # depth and stencil resolve modes can be set independently if one of them is none
    independentResolve*: Bool32 # depth and stencil resolve modes can be set independently
    filterMinmaxSingleComponentFormats*: Bool32
    filterMinmaxImageComponentMapping*: Bool32
    maxTimelineSemaphoreValueDifference*: uint64
    framebufferIntegerColorSampleCounts* {.optional.}: SampleCountFlags
  # Promoted from VK_KHR_image_format_list (extension 148)
  ImageFormatListCreateInfo* = object
    sType* {.constant: (StructureType.imageFormatListCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    viewFormatCount* {.optional.}: uint32
    pViewFormats* {.length: viewFormatCount.}: arrPtr[Format]
  # Promoted from VK_KHR_create_renderpass2 (extension 110)
  RenderPassCreateInfo2* = object
    sType* {.constant: (StructureType.renderPassCreateInfo2).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: RenderPassCreateFlags
    attachmentCount* {.optional.}: uint32
    pAttachments* {.length: attachmentCount.}: arrPtr[AttachmentDescription2]
    subpassCount*: uint32
    pSubpasses* {.length: subpassCount.}: arrPtr[SubpassDescription2]
    dependencyCount* {.optional.}: uint32
    pDependencies* {.length: dependencyCount.}: arrPtr[SubpassDependency2]
    correlatedViewMaskCount* {.optional.}: uint32
    pCorrelatedViewMasks* {.length: correlatedViewMaskCount.}: arrPtr[uint32]
  AttachmentDescription2* = object
    sType* {.constant: (StructureType.attachmentDescription2).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: AttachmentDescriptionFlags
    format*: Format
    samples*: SampleCountFlagBits
    loadOp*: AttachmentLoadOp # Load operation for color or depth data
    storeOp*: AttachmentStoreOp # Store operation for color or depth data
    stencilLoadOp*: AttachmentLoadOp # Load operation for stencil data
    stencilStoreOp*: AttachmentStoreOp # Store operation for stencil data
    initialLayout*: ImageLayout
    finalLayout*: ImageLayout
  AttachmentReference2* = object
    sType* {.constant: (StructureType.attachmentReference2).}: StructureType
    pNext* {.optional.}: pointer
    attachment*: uint32
    layout*: ImageLayout
    aspectMask*: ImageAspectFlags
  SubpassDescription2* = object
    sType* {.constant: (StructureType.subpassDescription2).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SubpassDescriptionFlags
    pipelineBindPoint*: PipelineBindPoint
    viewMask*: uint32
    inputAttachmentCount* {.optional.}: uint32
    pInputAttachments* {.length: inputAttachmentCount.}: arrPtr[AttachmentReference2]
    colorAttachmentCount* {.optional.}: uint32
    pColorAttachments* {.length: colorAttachmentCount.}: arrPtr[AttachmentReference2]
    pResolveAttachments* {.optional, length: colorAttachmentCount.}: arrPtr[AttachmentReference2]
    pDepthStencilAttachment* {.optional.}: ptr AttachmentReference2
    preserveAttachmentCount* {.optional.}: uint32
    pPreserveAttachments* {.length: preserveAttachmentCount.}: arrPtr[uint32]
  SubpassDependency2* = object
    sType* {.constant: (StructureType.subpassDependency2).}: StructureType
    pNext* {.optional.}: pointer
    srcSubpass*: uint32
    dstSubpass*: uint32
    srcStageMask* {.optional.}: PipelineStageFlags
    dstStageMask* {.optional.}: PipelineStageFlags
    srcAccessMask* {.optional.}: AccessFlags
    dstAccessMask* {.optional.}: AccessFlags
    dependencyFlags* {.optional.}: DependencyFlags
    viewOffset*: int32
  SubpassBeginInfo* = object
    sType* {.constant: (StructureType.subpassBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    contents*: SubpassContents
  SubpassEndInfo* = object
    sType* {.constant: (StructureType.subpassEndInfo).}: StructureType
    pNext* {.optional.}: pointer
  # Promoted from VK_KHR_8bit_storage (extension 178)
  PhysicalDevice8BitStorageFeatures* = object
    sType* {.constant: (StructureType.physicalDevice8bitStorageFeatures).}: StructureType
    pNext* {.optional.}: pointer
    storageBuffer8BitAccess*: Bool32 # 8-bit integer variables supported in StorageBuffer
    uniformAndStorageBuffer8BitAccess*: Bool32 # 8-bit integer variables supported in StorageBuffer and Uniform
    storagePushConstant8*: Bool32 # 8-bit integer variables supported in PushConstant
  # Promoted from VK_KHR_driver_properties (extension 197)
  ConformanceVersion* = object
    major*: uint8
    minor*: uint8
    subminor*: uint8
    patch*: uint8
  PhysicalDeviceDriverProperties* = object
    sType* {.constant: (StructureType.physicalDeviceDriverProperties).}: StructureType
    pNext* {.optional.}: pointer
    driverID*: DriverId
    driverName*: array[MaxDriverNameSize, char]
    driverInfo*: array[MaxDriverInfoSize, char]
    conformanceVersion*: ConformanceVersion
  # Promoted from VK_KHR_shader_atomic_int64 (extension 181)
  PhysicalDeviceShaderAtomicInt64Features* = object
    sType* {.constant: (StructureType.physicalDeviceShaderAtomicInt64Features).}: StructureType
    pNext* {.optional.}: pointer
    shaderBufferInt64Atomics*: Bool32
    shaderSharedInt64Atomics*: Bool32
  # Promoted from VK_KHR_shader_float16_int8 (extension 83)
  PhysicalDeviceShaderFloat16Int8Features* = object
    sType* {.constant: (StructureType.physicalDeviceShaderFloat16Int8Features).}: StructureType
    pNext* {.optional.}: pointer
    shaderFloat16*: Bool32 # 16-bit floats (halfs) in shaders
    shaderInt8*: Bool32 # 8-bit integers in shaders
  # Promoted from VK_KHR_shader_float_controls (extension 198)
  PhysicalDeviceFloatControlsProperties* = object
    sType* {.constant: (StructureType.physicalDeviceFloatControlsProperties).}: StructureType
    pNext* {.optional.}: pointer
    denormBehaviorIndependence*: ShaderFloatControlsIndependence
    roundingModeIndependence*: ShaderFloatControlsIndependence
    shaderSignedZeroInfNanPreserveFloat16*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64*: Bool32 # An implementation can preserve signed zero, nan, inf
    shaderDenormPreserveFloat16*: Bool32 # An implementation can preserve  denormals
    shaderDenormPreserveFloat32*: Bool32 # An implementation can preserve  denormals
    shaderDenormPreserveFloat64*: Bool32 # An implementation can preserve  denormals
    shaderDenormFlushToZeroFloat16*: Bool32 # An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32*: Bool32 # An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64*: Bool32 # An implementation can flush to zero  denormals
    shaderRoundingModeRTEFloat16*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTEFloat32*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTEFloat64*: Bool32 # An implementation can support RTE
    shaderRoundingModeRTZFloat16*: Bool32 # An implementation can support RTZ
    shaderRoundingModeRTZFloat32*: Bool32 # An implementation can support RTZ
    shaderRoundingModeRTZFloat64*: Bool32 # An implementation can support RTZ
  # Promoted from VK_EXT_descriptor_indexing (extension 162)
  DescriptorSetLayoutBindingFlagsCreateInfo* = object
    sType* {.constant: (StructureType.descriptorSetLayoutBindingFlagsCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    bindingCount* {.optional.}: uint32
    pBindingFlags* {.length: bindingCount.}: arrPtr[DescriptorBindingFlags]
  PhysicalDeviceDescriptorIndexingFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceDescriptorIndexingFeatures).}: StructureType
    pNext* {.optional.}: pointer
    shaderInputAttachmentArrayDynamicIndexing*: Bool32
    shaderUniformTexelBufferArrayDynamicIndexing*: Bool32
    shaderStorageTexelBufferArrayDynamicIndexing*: Bool32
    shaderUniformBufferArrayNonUniformIndexing*: Bool32
    shaderSampledImageArrayNonUniformIndexing*: Bool32
    shaderStorageBufferArrayNonUniformIndexing*: Bool32
    shaderStorageImageArrayNonUniformIndexing*: Bool32
    shaderInputAttachmentArrayNonUniformIndexing*: Bool32
    shaderUniformTexelBufferArrayNonUniformIndexing*: Bool32
    shaderStorageTexelBufferArrayNonUniformIndexing*: Bool32
    descriptorBindingUniformBufferUpdateAfterBind*: Bool32
    descriptorBindingSampledImageUpdateAfterBind*: Bool32
    descriptorBindingStorageImageUpdateAfterBind*: Bool32
    descriptorBindingStorageBufferUpdateAfterBind*: Bool32
    descriptorBindingUniformTexelBufferUpdateAfterBind*: Bool32
    descriptorBindingStorageTexelBufferUpdateAfterBind*: Bool32
    descriptorBindingUpdateUnusedWhilePending*: Bool32
    descriptorBindingPartiallyBound*: Bool32
    descriptorBindingVariableDescriptorCount*: Bool32
    runtimeDescriptorArray*: Bool32
  PhysicalDeviceDescriptorIndexingProperties* = object
    sType* {.constant: (StructureType.physicalDeviceDescriptorIndexingProperties).}: StructureType
    pNext* {.optional.}: pointer
    maxUpdateAfterBindDescriptorsInAllPools*: uint32
    shaderUniformBufferArrayNonUniformIndexingNative*: Bool32
    shaderSampledImageArrayNonUniformIndexingNative*: Bool32
    shaderStorageBufferArrayNonUniformIndexingNative*: Bool32
    shaderStorageImageArrayNonUniformIndexingNative*: Bool32
    shaderInputAttachmentArrayNonUniformIndexingNative*: Bool32
    robustBufferAccessUpdateAfterBind*: Bool32
    quadDivergentImplicitLod*: Bool32
    maxPerStageDescriptorUpdateAfterBindSamplers*: uint32
    maxPerStageDescriptorUpdateAfterBindUniformBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindSampledImages*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageImages*: uint32
    maxPerStageDescriptorUpdateAfterBindInputAttachments*: uint32
    maxPerStageUpdateAfterBindResources*: uint32
    maxDescriptorSetUpdateAfterBindSamplers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffers*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindSampledImages*: uint32
    maxDescriptorSetUpdateAfterBindStorageImages*: uint32
    maxDescriptorSetUpdateAfterBindInputAttachments*: uint32
  DescriptorSetVariableDescriptorCountAllocateInfo* = object
    sType* {.constant: (StructureType.descriptorSetVariableDescriptorCountAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    descriptorSetCount* {.optional.}: uint32
    pDescriptorCounts* {.length: descriptorSetCount.}: arrPtr[uint32]
  DescriptorSetVariableDescriptorCountLayoutSupport* = object
    sType* {.constant: (StructureType.descriptorSetVariableDescriptorCountLayoutSupport).}: StructureType
    pNext* {.optional.}: pointer
    maxVariableDescriptorCount*: uint32
  # Promoted from VK_KHR_depth_stencil_resolve (extension 200)
  SubpassDescriptionDepthStencilResolve* = object
    sType* {.constant: (StructureType.subpassDescriptionDepthStencilResolve).}: StructureType
    pNext* {.optional.}: pointer
    depthResolveMode*: ResolveModeFlagBits # depth resolve mode
    stencilResolveMode*: ResolveModeFlagBits # stencil resolve mode
    pDepthStencilResolveAttachment* {.optional.}: ptr AttachmentReference2 # depth/stencil resolve attachment
  PhysicalDeviceDepthStencilResolveProperties* = object
    sType* {.constant: (StructureType.physicalDeviceDepthStencilResolveProperties).}: StructureType
    pNext* {.optional.}: pointer
    supportedDepthResolveModes*: ResolveModeFlags # supported depth resolve modes
    supportedStencilResolveModes*: ResolveModeFlags # supported stencil resolve modes
    independentResolveNone*: Bool32 # depth and stencil resolve modes can be set independently if one of them is none
    independentResolve*: Bool32 # depth and stencil resolve modes can be set independently
  # Promoted from VK_EXT_scalar_block_layout (extension 222))
  PhysicalDeviceScalarBlockLayoutFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceScalarBlockLayoutFeatures).}: StructureType
    pNext* {.optional.}: pointer
    scalarBlockLayout*: Bool32
  # Promoted from VK_EXT_separate_stencil_usage (extension 247)
  ImageStencilUsageCreateInfo* = object
    sType* {.constant: (StructureType.imageStencilUsageCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    stencilUsage*: ImageUsageFlags
  # Promoted from VK_EXT_sampler_filter_minmax (extension 131)
  SamplerReductionModeCreateInfo* = object
    sType* {.constant: (StructureType.samplerReductionModeCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    reductionMode*: SamplerReductionMode
  PhysicalDeviceSamplerFilterMinmaxProperties* = object
    sType* {.constant: (StructureType.physicalDeviceSamplerFilterMinmaxProperties).}: StructureType
    pNext* {.optional.}: pointer
    filterMinmaxSingleComponentFormats*: Bool32
    filterMinmaxImageComponentMapping*: Bool32
  # Promoted from VK_KHR_vulkan_memory_model (extension 212)
  PhysicalDeviceVulkanMemoryModelFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceVulkanMemoryModelFeatures).}: StructureType
    pNext* {.optional.}: pointer
    vulkanMemoryModel*: Bool32
    vulkanMemoryModelDeviceScope*: Bool32
    vulkanMemoryModelAvailabilityVisibilityChains*: Bool32
  # Promoted from VK_KHR_imageless_framebuffer (extension 109)
  PhysicalDeviceImagelessFramebufferFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceImagelessFramebufferFeatures).}: StructureType
    pNext* {.optional.}: pointer
    imagelessFramebuffer*: Bool32
  FramebufferAttachmentsCreateInfo* = object
    sType* {.constant: (StructureType.framebufferAttachmentsCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    attachmentImageInfoCount* {.optional.}: uint32
    pAttachmentImageInfos* {.length: attachmentImageInfoCount.}: arrPtr[FramebufferAttachmentImageInfo]
  FramebufferAttachmentImageInfo* = object
    sType* {.constant: (StructureType.framebufferAttachmentImageInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ImageCreateFlags # Image creation flags
    usage*: ImageUsageFlags # Image usage flags
    width*: uint32
    height*: uint32
    layerCount*: uint32
    viewFormatCount* {.optional.}: uint32
    pViewFormats* {.length: viewFormatCount.}: arrPtr[Format]
  RenderPassAttachmentBeginInfo* = object
    sType* {.constant: (StructureType.renderPassAttachmentBeginInfo).}: StructureType
    pNext* {.optional.}: pointer
    attachmentCount* {.optional.}: uint32
    pAttachments* {.length: attachmentCount.}: arrPtr[ImageView]
  # Promoted from VK_KHR_uniform_buffer_standard_layout (extension 254)
  PhysicalDeviceUniformBufferStandardLayoutFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceUniformBufferStandardLayoutFeatures).}: StructureType
    pNext* {.optional.}: pointer
    uniformBufferStandardLayout*: Bool32
  # Promoted from VK_KHR_shader_subgroup_extended_types (extension 176)
  PhysicalDeviceShaderSubgroupExtendedTypesFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceShaderSubgroupExtendedTypesFeatures).}: StructureType
    pNext* {.optional.}: pointer
    shaderSubgroupExtendedTypes*: Bool32 # Flag to specify whether subgroup operations with extended types are supported
  # Promoted from VK_KHR_separate_depth_stencil_layouts (extension 242)
  PhysicalDeviceSeparateDepthStencilLayoutsFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceSeparateDepthStencilLayoutsFeatures).}: StructureType
    pNext* {.optional.}: pointer
    separateDepthStencilLayouts*: Bool32
  AttachmentReferenceStencilLayout* = object
    sType* {.constant: (StructureType.attachmentReferenceStencilLayout).}: StructureType
    pNext* {.optional.}: pointer
    stencilLayout*: ImageLayout
  AttachmentDescriptionStencilLayout* = object
    sType* {.constant: (StructureType.attachmentDescriptionStencilLayout).}: StructureType
    pNext* {.optional.}: pointer
    stencilInitialLayout*: ImageLayout
    stencilFinalLayout*: ImageLayout
  # Promoted from VK_EXT_host_query_reset (extension 262)
  PhysicalDeviceHostQueryResetFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceHostQueryResetFeatures).}: StructureType
    pNext* {.optional.}: pointer
    hostQueryReset*: Bool32
  # Promoted from VK_KHR_timeline_semaphore (extension 208)
  PhysicalDeviceTimelineSemaphoreFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceTimelineSemaphoreFeatures).}: StructureType
    pNext* {.optional.}: pointer
    timelineSemaphore*: Bool32
  PhysicalDeviceTimelineSemaphoreProperties* = object
    sType* {.constant: (StructureType.physicalDeviceTimelineSemaphoreProperties).}: StructureType
    pNext* {.optional.}: pointer
    maxTimelineSemaphoreValueDifference*: uint64
  SemaphoreTypeCreateInfo* = object
    sType* {.constant: (StructureType.semaphoreTypeCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    semaphoreType*: SemaphoreType
    initialValue*: uint64
  TimelineSemaphoreSubmitInfo* = object
    sType* {.constant: (StructureType.timelineSemaphoreSubmitInfo).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreValueCount* {.optional.}: uint32
    pWaitSemaphoreValues* {.optional, length: waitSemaphoreValueCount.}: arrPtr[uint64]
    signalSemaphoreValueCount* {.optional.}: uint32
    pSignalSemaphoreValues* {.optional, length: signalSemaphoreValueCount.}: arrPtr[uint64]
  SemaphoreWaitInfo* = object
    sType* {.constant: (StructureType.semaphoreWaitInfo).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SemaphoreWaitFlags
    semaphoreCount*: uint32
    pSemaphores* {.length: semaphoreCount.}: arrPtr[Semaphore]
    pValues* {.length: semaphoreCount.}: arrPtr[uint64]
  SemaphoreSignalInfo* = object
    sType* {.constant: (StructureType.semaphoreSignalInfo).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    value*: uint64
  # Promoted from VK_KHR_buffer_device_address (extension 258)
  PhysicalDeviceBufferDeviceAddressFeatures* = object
    sType* {.constant: (StructureType.physicalDeviceBufferDeviceAddressFeatures).}: StructureType
    pNext* {.optional.}: pointer
    bufferDeviceAddress*: Bool32
    bufferDeviceAddressCaptureReplay*: Bool32
    bufferDeviceAddressMultiDevice*: Bool32
  BufferDeviceAddressInfo* = object
    sType* {.constant: (StructureType.bufferDeviceAddressInfo).}: StructureType
    pNext* {.optional.}: pointer
    buffer*: Buffer
  BufferOpaqueCaptureAddressCreateInfo* = object
    sType* {.constant: (StructureType.bufferOpaqueCaptureAddressCreateInfo).}: StructureType
    pNext* {.optional.}: pointer
    opaqueCaptureAddress*: uint64
  MemoryOpaqueCaptureAddressAllocateInfo* = object
    sType* {.constant: (StructureType.memoryOpaqueCaptureAddressAllocateInfo).}: StructureType
    pNext* {.optional.}: pointer
    opaqueCaptureAddress*: uint64
  DeviceMemoryOpaqueCaptureAddressInfo* = object
    sType* {.constant: (StructureType.deviceMemoryOpaqueCaptureAddressInfo).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
  # KHR surface
  # ===========
  SurfaceCapabilitiesKHR* = object
    minImageCount*: uint32 # Supported minimum number of images for the surface
    maxImageCount*: uint32 # Supported maximum number of images for the surface, 0 for unlimited
    currentExtent*: Extent2D # Current image width and height for the surface, (0, 0) if undefined
    minImageExtent*: Extent2D # Supported minimum image width and height for the surface
    maxImageExtent*: Extent2D # Supported maximum image width and height for the surface
    maxImageArrayLayers*: uint32 # Supported maximum number of image layers for the surface
    supportedTransforms*: SurfaceTransformFlagsKHR # 1 or more bits representing the transforms supported
    currentTransform*: SurfaceTransformFlagBitsKHR # The surface's current transform relative to the device's natural orientation
    supportedCompositeAlpha*: CompositeAlphaFlagsKHR # 1 or more bits representing the alpha compositing modes supported
    supportedUsageFlags*: ImageUsageFlags # Supported image usage flags for the surface
  SurfaceFormatKHR* = object
    format*: Format # Supported pair of rendering format
    colorSpace*: ColorSpaceKHR # and color space for the surface
  # KHR swapchain
  # =============
  SwapchainCreateInfoKHR* = object
    sType* {.constant: (StructureType.swapchainCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SwapchainCreateFlagsKHR
    surface*: SurfaceKHR # The swapchain's target surface
    minImageCount*: uint32 # Minimum number of presentation images the application needs
    imageFormat*: Format # Format of the presentation images
    imageColorSpace*: ColorSpaceKHR # Colorspace of the presentation images
    imageExtent*: Extent2D # Dimensions of the presentation images
    imageArrayLayers*: uint32 # Determines the number of views for multiview/stereo presentation
    imageUsage*: ImageUsageFlags # Bits indicating how the presentation images will be used
    imageSharingMode*: SharingMode # Sharing mode used for the presentation images
    queueFamilyIndexCount* {.optional.}: uint32 # Number of queue families having access to the images in case of concurrent sharing mode
    pQueueFamilyIndices* {.length: queueFamilyIndexCount.}: arrPtr[uint32] # Array of queue family indices having access to the images in case of concurrent sharing mode
    preTransform*: SurfaceTransformFlagBitsKHR # The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    compositeAlpha*: CompositeAlphaFlagBitsKHR # The alpha blending mode used when compositing this surface with other surfaces in the window system
    presentMode*: PresentModeKHR # Which presentation mode to use for presents on this swap chain
    clipped*: Bool32 # Specifies whether presentable images may be affected by window clip regions
    oldSwapchain* {.optional.}: SwapchainKHR # Existing swap chain to replace, if any
  PresentInfoKHR* = object
    sType* {.constant: (StructureType.presentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreCount* {.optional.}: uint32 # Number of semaphores to wait for before presenting
    pWaitSemaphores* {.length: waitSemaphoreCount.}: arrPtr[Semaphore] # Semaphores to wait for before presenting
    swapchainCount*: uint32 # Number of swapchains to present in this call
    pSwapchains* {.length: swapchainCount.}: arrPtr[SwapchainKHR] # Swapchains to present an image from
    pImageIndices* {.length: swapchainCount.}: arrPtr[uint32] # Indices of which presentable images to present
    pResults* {.optional, length: swapchainCount.}: arrPtr[Result] # Optional (i.e. if non-NULL) VkResult for each swapchain
  ImageSwapchainCreateInfoKHR* = object
    sType* {.constant: (StructureType.imageSwapchainCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchain* {.optional.}: SwapchainKHR
  BindImageMemorySwapchainInfoKHR* = object
    sType* {.constant: (StructureType.bindImageMemorySwapchainInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchain*: SwapchainKHR
    imageIndex*: uint32
  AcquireNextImageInfoKHR* = object
    sType* {.constant: (StructureType.acquireNextImageInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchain*: SwapchainKHR
    timeout*: uint64
    semaphore* {.optional.}: Semaphore
    fence* {.optional.}: Fence
    deviceMask*: uint32
  DeviceGroupPresentCapabilitiesKHR* = object
    sType* {.constant: (StructureType.deviceGroupPresentCapabilitiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    presentMask*: array[MaxDeviceGroupSize, uint32]
    modes*: DeviceGroupPresentModeFlagsKHR
  DeviceGroupPresentInfoKHR* = object
    sType* {.constant: (StructureType.deviceGroupPresentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchainCount* {.optional.}: uint32
    pDeviceMasks* {.length: swapchainCount.}: arrPtr[uint32]
    mode*: DeviceGroupPresentModeFlagBitsKHR
  DeviceGroupSwapchainCreateInfoKHR* = object
    sType* {.constant: (StructureType.deviceGroupSwapchainCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    modes*: DeviceGroupPresentModeFlagsKHR
  # KHR display
  # ===========
  DisplayModeCreateInfoKHR* = object
    sType* {.constant: (StructureType.displayModeCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DisplayModeCreateFlagsKHR
    parameters*: DisplayModeParametersKHR # The parameters this mode uses.
  DisplayModeParametersKHR* = object
    visibleRegion*: Extent2D # Visible scanout region.
    refreshRate*: uint32 # Number of times per second the display is updated.
  DisplayModePropertiesKHR* = object
    displayMode*: DisplayModeKHR # Handle of this display mode.
    parameters*: DisplayModeParametersKHR # The parameters this mode uses.
  DisplayPlaneCapabilitiesKHR* = object
    supportedAlpha* {.optional.}: DisplayPlaneAlphaFlagsKHR # Types of alpha blending supported, if any.
    minSrcPosition*: Offset2D # Does the plane have any position and extent restrictions?
    maxSrcPosition*: Offset2D
    minSrcExtent*: Extent2D
    maxSrcExtent*: Extent2D
    minDstPosition*: Offset2D
    maxDstPosition*: Offset2D
    minDstExtent*: Extent2D
    maxDstExtent*: Extent2D
  DisplayPlanePropertiesKHR* = object
    currentDisplay*: DisplayKHR # Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    currentStackIndex*: uint32 # Current z-order of the plane.
  DisplayPropertiesKHR* = object
    display*: DisplayKHR # Handle of the display object
    displayName*: cstring # Name of the display
    physicalDimensions*: Extent2D # In millimeters?
    physicalResolution*: Extent2D # Max resolution for CRT?
    supportedTransforms* {.optional.}: SurfaceTransformFlagsKHR # one or more bits from VkSurfaceTransformFlagsKHR
    planeReorderPossible*: Bool32 # VK_TRUE if the overlay plane's z-order can be changed on this display.
    persistentContent*: Bool32 # VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
  DisplaySurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.displaySurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DisplaySurfaceCreateFlagsKHR
    displayMode*: DisplayModeKHR # The mode to use when displaying this surface
    planeIndex*: uint32 # The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    planeStackIndex*: uint32 # The z-order of the plane.
    transform*: SurfaceTransformFlagBitsKHR # Transform to apply to the images as part of the scanout operation
    globalAlpha*: float32 # Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    alphaMode*: DisplayPlaneAlphaFlagBitsKHR # What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
    imageExtent*: Extent2D # size of the images to use with this surface
  # KHR display swapchain
  # =====================
  DisplayPresentInfoKHR* = object
    sType* {.constant: (StructureType.displayPresentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    srcRect*: Rect2D # Rectangle within the presentable image to read pixel data from when presenting to the display.
    dstRect*: Rect2D # Rectangle within the current display mode's visible region to display srcRectangle in.
    persistent*: Bool32 # For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
  # KHR xlib surface
  # ================
  XlibSurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.xlibSurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: XlibSurfaceCreateFlagsKHR
    dpy*: ptr Display
    window*: Window
  # KHR xcb surface
  # ===============
  XcbSurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.xcbSurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: XcbSurfaceCreateFlagsKHR
    connection*: ptr XcbConnection
    window*: XcbWindow
  # KHR wayland surface
  # ===================
  WaylandSurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.waylandSurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: WaylandSurfaceCreateFlagsKHR
    display*: ptr wl_display
    surface*: ptr wl_surface
  # KHR android surface
  # ===================
  AndroidSurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.androidSurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: AndroidSurfaceCreateFlagsKHR
    window*: ptr ANativeWindow
  # KHR win32 surface
  # =================
  Win32SurfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.win32SurfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: Win32SurfaceCreateFlagsKHR
    hinstance*: HINSTANCE
    hwnd*: HWND
  # ANDROID native buffer
  # =====================
  NativeBufferANDROID* = object
    sType* {.constant: (StructureType.nativeBufferAndroid).}: StructureType
    pNext* {.optional.}: pointer
    handle*: pointer
    stride*: int
    format*: int
    usage*: int
    usage2*: NativeBufferUsage2ANDROID
  SwapchainImageCreateInfoANDROID* = object
    sType* {.constant: (StructureType.swapchainImageCreateInfoAndroid).}: StructureType
    pNext* {.optional.}: pointer
    usage*: SwapchainImageUsageFlagsANDROID
  PhysicalDevicePresentationPropertiesANDROID* = object
    sType* {.constant: (StructureType.physicalDevicePresentationPropertiesAndroid).}: StructureType
    pNext* {.optional.}: pointer
    sharedImage*: Bool32
  NativeBufferUsage2ANDROID* = object
    consumer*: uint64
    producer*: uint64
  # EXT debug report
  # ================
  PFN_DebugReportCallbackEXT* = proc(
      flags: DebugReportFlagsEXT;
      objectType: DebugReportObjectTypeEXT;
      `object`: uint64;
      location: uint;
      messageCode: int32;
      pLayerPrefix: cstring;
      pMessage: cstring;
      pUserData: pointer;
    ): Bool32 {.cdecl.}
  DebugReportCallbackCreateInfoEXT* = object
    sType* {.constant: (StructureType.debugReportCallbackCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DebugReportFlagsEXT # Indicates which events call this callback
    pfnCallback*: PFN_DebugReportCallbackEXT # Function pointer of a callback function
    pUserData* {.optional.}: pointer # User data provided to callback function
  # AMD rasterization order
  # =======================
  PipelineRasterizationStateRasterizationOrderAMD* = object
    sType* {.constant: (StructureType.pipelineRasterizationStateRasterizationOrderAmd).}: StructureType
    pNext* {.optional.}: pointer
    rasterizationOrder*: RasterizationOrderAMD # Rasterization order to use for the pipeline
  # EXT debug marker
  # ================
  DebugMarkerObjectNameInfoEXT* = object
    sType* {.constant: (StructureType.debugMarkerObjectNameInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    objectType*: DebugReportObjectTypeEXT # The type of the object
    `object`*: uint64 # The handle of the object, cast to uint64_t
    pObjectName*: cstring # Name to apply to the object
  DebugMarkerObjectTagInfoEXT* = object
    sType* {.constant: (StructureType.debugMarkerObjectTagInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    objectType*: DebugReportObjectTypeEXT # The type of the object
    `object`*: uint64 # The handle of the object, cast to uint64_t
    tagName*: uint64 # The name of the tag to set on the object
    tagSize*: uint # The length in bytes of the tag data
    pTag* {.length: tagSize.}: pointer # Tag data to attach to the object
  DebugMarkerMarkerInfoEXT* = object
    sType* {.constant: (StructureType.debugMarkerMarkerInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pMarkerName*: cstring # Name of the debug marker
    color*: array[4, float32] # Optional color for debug marker
  # KHR video queue
  # ===============
  QueueFamilyQueryResultStatusProperties2KHR* = object
    sType* {.constant: (StructureType.queueFamilyQueryResultStatusProperties2Khr).}: StructureType
    pNext* {.optional.}: pointer
    supported*: Bool32
  VideoQueueFamilyProperties2KHR* = object
    sType* {.constant: (StructureType.videoQueueFamilyProperties2Khr).}: StructureType
    pNext* {.optional.}: pointer
    videoCodecOperations*: VideoCodecOperationFlagsKHR
  VideoProfileKHR* = object
    sType* {.constant: (StructureType.videoProfileKhr).}: StructureType
    pNext* {.optional.}: pointer
    videoCodecOperation*: VideoCodecOperationFlagBitsKHR
    chromaSubsampling*: VideoChromaSubsamplingFlagsKHR
    lumaBitDepth*: VideoComponentBitDepthFlagsKHR
    chromaBitDepth*: VideoComponentBitDepthFlagsKHR
  VideoProfilesKHR* = object
    sType* {.constant: (StructureType.videoProfilesKhr).}: StructureType
    pNext* {.optional.}: pointer
    profileCount*: uint32
    pProfiles*: ptr VideoProfileKHR
  VideoCapabilitiesKHR* = object
    sType* {.constant: (StructureType.videoCapabilitiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    capabilityFlags*: VideoCapabilityFlagsKHR
    minBitstreamBufferOffsetAlignment*: DeviceSize
    minBitstreamBufferSizeAlignment*: DeviceSize
    videoPictureExtentGranularity*: Extent2D
    minExtent*: Extent2D
    maxExtent*: Extent2D
    maxReferencePicturesSlotsCount*: uint32
    maxReferencePicturesActiveCount*: uint32
  PhysicalDeviceVideoFormatInfoKHR* = object
    sType* {.constant: (StructureType.physicalDeviceVideoFormatInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    imageUsage*: ImageUsageFlags
    pVideoProfiles*: ptr VideoProfilesKHR
  VideoFormatPropertiesKHR* = object
    sType* {.constant: (StructureType.videoFormatPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
  VideoPictureResourceKHR* = object
    sType* {.constant: (StructureType.videoPictureResourceKhr).}: StructureType
    pNext* {.optional.}: pointer
    codedOffset*: Offset2D # The offset to be used for the picture resource, currently only used in field mode
    codedExtent*: Extent2D # The extent to be used for the picture resource
    baseArrayLayer*: uint32 # TThe first array layer to be accessed for the Decode or Encode Operations
    imageViewBinding*: ImageView # The ImageView binding of the resource
  VideoReferenceSlotKHR* = object
    sType* {.constant: (StructureType.videoReferenceSlotKhr).}: StructureType
    pNext* {.optional.}: pointer
    slotIndex*: int8 # The reference slot index
    pPictureResource*: ptr VideoPictureResourceKHR # The reference picture resource
  VideoGetMemoryPropertiesKHR* = object
    sType* {.constant: (StructureType.videoGetMemoryPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    memoryBindIndex*: uint32
    pMemoryRequirements*: ptr MemoryRequirements2
  VideoBindMemoryKHR* = object
    sType* {.constant: (StructureType.videoBindMemoryKhr).}: StructureType
    pNext* {.optional.}: pointer
    memoryBindIndex*: uint32
    memory*: DeviceMemory
    memoryOffset*: DeviceSize
    memorySize*: DeviceSize
  VideoSessionCreateInfoKHR* = object
    sType* {.constant: (StructureType.videoSessionCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    queueFamilyIndex*: uint32
    flags* {.optional.}: VideoSessionCreateFlagsKHR
    pVideoProfile*: ptr VideoProfileKHR
    pictureFormat*: Format
    maxCodedExtent*: Extent2D
    referencePicturesFormat*: Format
    maxReferencePicturesSlotsCount*: uint32
    maxReferencePicturesActiveCount*: uint32
  VideoSessionParametersCreateInfoKHR* = object
    sType* {.constant: (StructureType.videoSessionParametersCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    videoSessionParametersTemplate* {.optional.}: VideoSessionParametersKHR
    videoSession*: VideoSessionKHR
  VideoSessionParametersUpdateInfoKHR* = object
    sType* {.constant: (StructureType.videoSessionParametersUpdateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    updateSequenceCount*: uint32
  VideoBeginCodingInfoKHR* = object
    sType* {.constant: (StructureType.videoBeginCodingInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: VideoBeginCodingFlagsKHR
    codecQualityPreset*: VideoCodingQualityPresetFlagsKHR
    videoSession*: VideoSessionKHR
    videoSessionParameters* {.optional.}: VideoSessionParametersKHR
    referenceSlotCount* {.optional.}: uint32
    pReferenceSlots* {.length: referenceSlotCount.}: arrPtr[VideoReferenceSlotKHR]
  VideoEndCodingInfoKHR* = object
    sType* {.constant: (StructureType.videoEndCodingInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: VideoEndCodingFlagsKHR
  VideoCodingControlInfoKHR* = object
    sType* {.constant: (StructureType.videoCodingControlInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: VideoCodingControlFlagsKHR
  # KHR video decode queue
  # ======================
  VideoDecodeInfoKHR* = object
    sType* {.constant: (StructureType.videoDecodeInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: VideoDecodeFlagsKHR
    codedOffset*: Offset2D
    codedExtent*: Extent2D
    srcBuffer*: Buffer
    srcBufferOffset*: DeviceSize
    srcBufferRange*: DeviceSize
    dstPictureResource*: VideoPictureResourceKHR
    pSetupReferenceSlot*: ptr VideoReferenceSlotKHR
    referenceSlotCount* {.optional.}: uint32
    pReferenceSlots* {.length: referenceSlotCount.}: arrPtr[VideoReferenceSlotKHR]
  # NV dedicated allocation
  # =======================
  DedicatedAllocationImageCreateInfoNV* = object
    sType* {.constant: (StructureType.dedicatedAllocationImageCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    dedicatedAllocation*: Bool32 # Whether this image uses a dedicated allocation
  DedicatedAllocationBufferCreateInfoNV* = object
    sType* {.constant: (StructureType.dedicatedAllocationBufferCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    dedicatedAllocation*: Bool32 # Whether this buffer uses a dedicated allocation
  DedicatedAllocationMemoryAllocateInfoNV* = object
    sType* {.constant: (StructureType.dedicatedAllocationMemoryAllocateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    image* {.optional.}: Image # Image that this allocation will be bound to
    buffer* {.optional.}: Buffer # Buffer that this allocation will be bound to
  # EXT transform feedback
  # ======================
  PhysicalDeviceTransformFeedbackFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceTransformFeedbackFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    transformFeedback*: Bool32
    geometryStreams*: Bool32
  PhysicalDeviceTransformFeedbackPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceTransformFeedbackPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxTransformFeedbackStreams*: uint32
    maxTransformFeedbackBuffers*: uint32
    maxTransformFeedbackBufferSize*: DeviceSize
    maxTransformFeedbackStreamDataSize*: uint32
    maxTransformFeedbackBufferDataSize*: uint32
    maxTransformFeedbackBufferDataStride*: uint32
    transformFeedbackQueries*: Bool32
    transformFeedbackStreamsLinesTriangles*: Bool32
    transformFeedbackRasterizationStreamSelect*: Bool32
    transformFeedbackDraw*: Bool32
  PipelineRasterizationStateStreamCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineRasterizationStateStreamCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineRasterizationStateStreamCreateFlagsEXT
    rasterizationStream*: uint32
  # NVX binary import
  # =================
  CuModuleCreateInfoNVX* = object
    sType* {.constant: (StructureType.cuModuleCreateInfoNvx).}: StructureType
    pNext* {.optional.}: pointer
    dataSize*: uint
    pData* {.length: dataSize.}: pointer
  CuFunctionCreateInfoNVX* = object
    sType* {.constant: (StructureType.cuFunctionCreateInfoNvx).}: StructureType
    pNext* {.optional.}: pointer
    module*: CuModuleNVX
    pName*: cstring
  CuLaunchInfoNVX* = object
    sType* {.constant: (StructureType.cuLaunchInfoNvx).}: StructureType
    pNext* {.optional.}: pointer
    function*: CuFunctionNVX
    gridDimX*: uint32
    gridDimY*: uint32
    gridDimZ*: uint32
    blockDimX*: uint32
    blockDimY*: uint32
    blockDimZ*: uint32
    sharedMemBytes*: uint32
    paramCount* {.optional.}: uint
    pParams* {.length: paramCount.}: arrPtr[pointer]
    extraCount* {.optional.}: uint
    pExtras* {.length: extraCount.}: arrPtr[pointer]
  # NVX image view handle
  # =====================
  ImageViewHandleInfoNVX* = object
    sType* {.constant: (StructureType.imageViewHandleInfoNvx).}: StructureType
    pNext* {.optional.}: pointer
    imageView*: ImageView
    descriptorType*: DescriptorType
    sampler* {.optional.}: Sampler
  ImageViewAddressPropertiesNVX* = object
    sType* {.constant: (StructureType.imageViewAddressPropertiesNvx).}: StructureType
    pNext* {.optional.}: pointer
    deviceAddress*: DeviceAddress
    size*: DeviceSize
  # EXT video encode h264
  # =====================
  VideoEncodeH264CapabilitiesEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264CapabilitiesExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoEncodeH264CapabilityFlagsEXT
    inputModeFlags*: VideoEncodeH264InputModeFlagsEXT
    outputModeFlags*: VideoEncodeH264OutputModeFlagsEXT
    minPictureSizeInMbs*: Extent2D
    maxPictureSizeInMbs*: Extent2D
    inputImageDataAlignment*: Extent2D
    maxNumL0ReferenceForP*: uint8
    maxNumL0ReferenceForB*: uint8
    maxNumL1Reference*: uint8
    qualityLevelCount*: uint8
    stdExtensionVersion*: ExtensionProperties
  VideoEncodeH264SessionCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264SessionCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoEncodeH264CreateFlagsEXT
    maxPictureSizeInMbs*: Extent2D
    pStdExtensionVersion*: ptr ExtensionProperties
  VideoEncodeH264SessionParametersCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264SessionParametersCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    maxSpsStdCount*: uint32
    maxPpsStdCount*: uint32
    pParametersAddInfo* {.optional.}: ptr VideoEncodeH264SessionParametersAddInfoEXT
  VideoEncodeH264SessionParametersAddInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264SessionParametersAddInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    spsStdCount*: uint32
    pSpsStd* {.optional, length: spsStdCount.}: arrPtr[StdVideoH264SequenceParameterSet]
    ppsStdCount*: uint32
    pPpsStd* {.optional, length: ppsStdCount.}: arrPtr[StdVideoH264PictureParameterSet] # List of Picture Parameters associated with the spsStd, above
  VideoEncodeH264VclFrameInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264VclFrameInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    refDefaultFinalList0EntryCount*: uint8
    pRefDefaultFinalList0Entries* {.length: refDefaultFinalList0EntryCount.}: arrPtr[VideoEncodeH264DpbSlotInfoEXT]
    refDefaultFinalList1EntryCount*: uint8
    pRefDefaultFinalList1Entries* {.length: refDefaultFinalList1EntryCount.}: arrPtr[VideoEncodeH264DpbSlotInfoEXT]
    naluSliceEntryCount*: uint32
    pNaluSliceEntries* {.length: naluSliceEntryCount.}: arrPtr[VideoEncodeH264NaluSliceEXT]
    pCurrentPictureInfo*: ptr VideoEncodeH264DpbSlotInfoEXT
  VideoEncodeH264EmitPictureParametersEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264EmitPictureParametersExt).}: StructureType
    pNext* {.optional.}: pointer
    spsId*: uint8
    emitSpsEnable*: Bool32
    ppsIdEntryCount*: uint32
    ppsIdEntries* {.length: ppsIdEntryCount.}: arrPtr[uint8]
  VideoEncodeH264DpbSlotInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264DpbSlotInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    slotIndex*: int8
    pStdPictureInfo*: ptr StdVideoEncodeH264PictureInfo
  VideoEncodeH264NaluSliceEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264NaluSliceExt).}: StructureType
    pNext* {.optional.}: pointer
    pSliceHeaderStd*: ptr StdVideoEncodeH264SliceHeader
    mbCount*: uint32
    refFinalList0EntryCount*: uint8
    pRefFinalList0Entries* {.length: refFinalList0EntryCount.}: arrPtr[VideoEncodeH264DpbSlotInfoEXT]
    refFinalList1EntryCount*: uint8
    pRefFinalList1Entries* {.length: refFinalList1EntryCount.}: arrPtr[VideoEncodeH264DpbSlotInfoEXT]
  VideoEncodeH264ProfileEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264ProfileExt).}: StructureType
    pNext* {.optional.}: pointer
    stdProfileIdc*: StdVideoH264ProfileIdc
  VideoEncodeH264RateControlInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264RateControlInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    gopFrameCount*: uint32
    idrPeriod*: uint32
    consecutiveBFrameCount*: uint32
    rateControlStructure*: VideoEncodeH264RateControlStructureFlagBitsEXT
    temporalLayerCount*: uint8
  VideoEncodeH264RateControlLayerInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH264RateControlLayerInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    temporalLayerId*: uint8
    useInitialRcQp*: Bool32
    initialRcQp*: VideoEncodeH264QpEXT
    useMinQp*: Bool32
    minQp*: VideoEncodeH264QpEXT
    useMaxQp*: Bool32
    maxQp*: VideoEncodeH264QpEXT
    useMaxFrameSize*: Bool32
    maxFrameSize*: VideoEncodeH264FrameSizeEXT
  VideoEncodeH264QpEXT* = object
    qpI*: int32
    qpP*: int32
    qpB*: int32
  VideoEncodeH264FrameSizeEXT* = object
    frameISize*: uint32
    framePSize*: uint32
    frameBSize*: uint32
  # EXT video encode h265
  # =====================
  VideoEncodeH265CapabilitiesEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265CapabilitiesExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoEncodeH265CapabilityFlagsEXT
    inputModeFlags*: VideoEncodeH265InputModeFlagsEXT
    outputModeFlags*: VideoEncodeH265OutputModeFlagsEXT
    ctbSizes*: VideoEncodeH265CtbSizeFlagsEXT
    inputImageDataAlignment*: Extent2D
    maxNumL0ReferenceForP*: uint8
    maxNumL0ReferenceForB*: uint8
    maxNumL1Reference*: uint8
    maxNumSubLayers*: uint8
    qualityLevelCount*: uint8
    stdExtensionVersion*: ExtensionProperties
  VideoEncodeH265SessionCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265SessionCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoEncodeH265CreateFlagsEXT
    pStdExtensionVersion*: ptr ExtensionProperties
  VideoEncodeH265SessionParametersCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265SessionParametersCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    maxVpsStdCount*: uint32
    maxSpsStdCount*: uint32
    maxPpsStdCount*: uint32
    pParametersAddInfo* {.optional.}: ptr VideoEncodeH265SessionParametersAddInfoEXT
  VideoEncodeH265SessionParametersAddInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265SessionParametersAddInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    vpsStdCount*: uint32
    pVpsStd* {.optional, length: vpsStdCount.}: arrPtr[StdVideoH265VideoParameterSet]
    spsStdCount*: uint32
    pSpsStd* {.optional, length: spsStdCount.}: arrPtr[StdVideoH265SequenceParameterSet]
    ppsStdCount*: uint32
    pPpsStd* {.optional, length: ppsStdCount.}: arrPtr[StdVideoH265PictureParameterSet] # List of Picture Parameters associated with the spsStd, above
  VideoEncodeH265VclFrameInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265VclFrameInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pReferenceFinalLists* {.optional.}: ptr VideoEncodeH265ReferenceListsEXT
    naluSliceEntryCount*: uint32
    pNaluSliceEntries* {.length: naluSliceEntryCount.}: arrPtr[VideoEncodeH265NaluSliceEXT]
    pCurrentPictureInfo*: ptr StdVideoEncodeH265PictureInfo
  VideoEncodeH265EmitPictureParametersEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265EmitPictureParametersExt).}: StructureType
    pNext* {.optional.}: pointer
    vpsId*: uint8
    spsId*: uint8
    emitVpsEnable*: Bool32
    emitSpsEnable*: Bool32
    ppsIdEntryCount* {.optional.}: uint32
    ppsIdEntries* {.length: ppsIdEntryCount.}: arrPtr[uint8]
  VideoEncodeH265DpbSlotInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265DpbSlotInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    slotIndex*: int8
    pStdReferenceInfo*: ptr StdVideoEncodeH265ReferenceInfo
  VideoEncodeH265NaluSliceEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265NaluSliceExt).}: StructureType
    pNext* {.optional.}: pointer
    ctbCount*: uint32
    pReferenceFinalLists* {.optional.}: ptr VideoEncodeH265ReferenceListsEXT
    pSliceHeaderStd*: ptr StdVideoEncodeH265SliceHeader
  VideoEncodeH265ProfileEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265ProfileExt).}: StructureType
    pNext* {.optional.}: pointer
    stdProfileIdc*: StdVideoH265ProfileIdc
  VideoEncodeH265ReferenceListsEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265ReferenceListsExt).}: StructureType
    pNext* {.optional.}: pointer
    referenceList0EntryCount* {.optional.}: uint8
    pReferenceList0Entries* {.length: referenceList0EntryCount.}: arrPtr[VideoEncodeH265DpbSlotInfoEXT]
    referenceList1EntryCount* {.optional.}: uint8
    pReferenceList1Entries* {.length: referenceList1EntryCount.}: arrPtr[VideoEncodeH265DpbSlotInfoEXT]
    pReferenceModifications*: ptr StdVideoEncodeH265ReferenceModifications
  VideoEncodeH265RateControlInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265RateControlInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    gopFrameCount*: uint32
    idrPeriod*: uint32
    consecutiveBFrameCount*: uint32
    rateControlStructure*: VideoEncodeH265RateControlStructureFlagBitsEXT
    subLayerCount*: uint8
  VideoEncodeH265RateControlLayerInfoEXT* = object
    sType* {.constant: (StructureType.videoEncodeH265RateControlLayerInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    temporalId*: uint8
    useInitialRcQp*: Bool32
    initialRcQp*: VideoEncodeH265QpEXT
    useMinQp*: Bool32
    minQp*: VideoEncodeH265QpEXT
    useMaxQp*: Bool32
    maxQp*: VideoEncodeH265QpEXT
    useMaxFrameSize*: Bool32
    maxFrameSize*: VideoEncodeH265FrameSizeEXT
  VideoEncodeH265QpEXT* = object
    qpI*: int32
    qpP*: int32
    qpB*: int32
  VideoEncodeH265FrameSizeEXT* = object
    frameISize*: uint32
    framePSize*: uint32
    frameBSize*: uint32
  # EXT video decode h264
  # =====================
  VideoDecodeH264ProfileEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264ProfileExt).}: StructureType
    pNext* {.optional.}: pointer
    stdProfileIdc*: StdVideoH264ProfileIdc
    pictureLayout*: VideoDecodeH264PictureLayoutFlagsEXT
  VideoDecodeH264CapabilitiesEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264CapabilitiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxLevel*: uint32
    fieldOffsetGranularity*: Offset2D
    stdExtensionVersion*: ExtensionProperties
  VideoDecodeH264SessionCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264SessionCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoDecodeH264CreateFlagsEXT
    pStdExtensionVersion*: ptr ExtensionProperties
  VideoDecodeH264SessionParametersCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264SessionParametersCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    maxSpsStdCount*: uint32
    maxPpsStdCount*: uint32
    pParametersAddInfo* {.optional.}: ptr VideoDecodeH264SessionParametersAddInfoEXT
  VideoDecodeH264SessionParametersAddInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264SessionParametersAddInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    spsStdCount*: uint32
    pSpsStd* {.optional, length: spsStdCount.}: arrPtr[StdVideoH264SequenceParameterSet]
    ppsStdCount*: uint32
    pPpsStd* {.optional, length: ppsStdCount.}: arrPtr[StdVideoH264PictureParameterSet] # List of Picture Parameters associated with the spsStd, above
  VideoDecodeH264PictureInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264PictureInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pStdPictureInfo*: ptr StdVideoDecodeH264PictureInfo
    slicesCount*: uint32
    pSlicesDataOffsets* {.length: slicesCount.}: arrPtr[uint32]
  VideoDecodeH264MvcEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264MvcExt).}: StructureType
    pNext* {.optional.}: pointer
    pStdMvc*: ptr StdVideoDecodeH264Mvc
  VideoDecodeH264DpbSlotInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH264DpbSlotInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pStdReferenceInfo*: ptr StdVideoDecodeH264ReferenceInfo
  # AMD texture gather bias lod
  # ===========================
  TextureLODGatherFormatPropertiesAMD* = object
    sType* {.constant: (StructureType.textureLodGatherFormatPropertiesAmd).}: StructureType
    pNext* {.optional.}: pointer
    supportsTextureGatherLODBiasAMD*: Bool32
  # AMD shader info
  # ===============
  ShaderResourceUsageAMD* = object
    numUsedVgprs*: uint32
    numUsedSgprs*: uint32
    ldsSizePerLocalWorkGroup*: uint32
    ldsUsageSizeInBytes*: uint
    scratchMemUsageInBytes*: uint
  ShaderStatisticsInfoAMD* = object
    shaderStageMask*: ShaderStageFlags
    resourceUsage*: ShaderResourceUsageAMD
    numPhysicalVgprs*: uint32
    numPhysicalSgprs*: uint32
    numAvailableVgprs*: uint32
    numAvailableSgprs*: uint32
    computeWorkGroupSize*: array[3, uint32]
  # KHR dynamic rendering
  # =====================
  RenderingInfoKHR* = object
    sType* {.constant: (StructureType.renderingInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: RenderingFlagsKHR
    renderArea*: Rect2D
    layerCount*: uint32
    viewMask*: uint32
    colorAttachmentCount* {.optional.}: uint32
    pColorAttachments* {.length: colorAttachmentCount.}: arrPtr[RenderingAttachmentInfoKHR]
    pDepthAttachment* {.optional.}: ptr RenderingAttachmentInfoKHR
    pStencilAttachment* {.optional.}: ptr RenderingAttachmentInfoKHR
  RenderingAttachmentInfoKHR* = object
    sType* {.constant: (StructureType.renderingAttachmentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    imageView* {.optional.}: ImageView
    imageLayout*: ImageLayout
    resolveMode* {.optional.}: ResolveModeFlagBits
    resolveImageView* {.optional.}: ImageView
    resolveImageLayout*: ImageLayout
    loadOp*: AttachmentLoadOp
    storeOp*: AttachmentStoreOp
    clearValue*: ClearValue
  PipelineRenderingCreateInfoKHR* = object
    sType* {.constant: (StructureType.pipelineRenderingCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    viewMask*: uint32
    colorAttachmentCount* {.optional.}: uint32
    pColorAttachmentFormats* {.length: colorAttachmentCount.}: arrPtr[Format]
    depthAttachmentFormat*: Format
    stencilAttachmentFormat*: Format
  PhysicalDeviceDynamicRenderingFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceDynamicRenderingFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    dynamicRendering*: Bool32
  CommandBufferInheritanceRenderingInfoKHR* = object
    sType* {.constant: (StructureType.commandBufferInheritanceRenderingInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: RenderingFlagsKHR
    viewMask*: uint32
    colorAttachmentCount* {.optional.}: uint32
    pColorAttachmentFormats* {.length: colorAttachmentCount.}: arrPtr[Format]
    depthAttachmentFormat*: Format
    stencilAttachmentFormat*: Format
    rasterizationSamples* {.optional.}: SampleCountFlagBits
  RenderingFragmentShadingRateAttachmentInfoKHR* = object
    sType* {.constant: (StructureType.renderingFragmentShadingRateAttachmentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    imageView* {.optional.}: ImageView
    imageLayout*: ImageLayout
    shadingRateAttachmentTexelSize*: Extent2D
  RenderingFragmentDensityMapAttachmentInfoEXT* = object
    sType* {.constant: (StructureType.renderingFragmentDensityMapAttachmentInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    imageView*: ImageView
    imageLayout*: ImageLayout
  AttachmentSampleCountInfoAMD* = object
    sType* {.constant: (StructureType.attachmentSampleCountInfoAmd).}: StructureType
    pNext* {.optional.}: pointer
    colorAttachmentCount*: uint32
    pColorAttachmentSamples* {.length: colorAttachmentCount.}: arrPtr[SampleCountFlagBits]
    depthStencilAttachmentSamples* {.optional.}: SampleCountFlagBits
  AttachmentSampleCountInfoNV* = object
  MultiviewPerViewAttributesInfoNVX* = object
    sType* {.constant: (StructureType.multiviewPerViewAttributesInfoNvx).}: StructureType
    pNext* {.optional.}: pointer
    perViewAttributes*: Bool32
    perViewAttributesPositionXOnly*: Bool32
  # GGP stream descriptor surface
  # =============================
  StreamDescriptorSurfaceCreateInfoGGP* = object
    sType* {.constant: (StructureType.streamDescriptorSurfaceCreateInfoGgp).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: StreamDescriptorSurfaceCreateFlagsGGP
    streamDescriptor*: GgpStreamDescriptor
  # NV corner sampled image
  # =======================
  PhysicalDeviceCornerSampledImageFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceCornerSampledImageFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    cornerSampledImage*: Bool32
  # KHR multiview
  # =============
  RenderPassMultiviewCreateInfoKHR* = object
  PhysicalDeviceMultiviewFeaturesKHR* = object
  PhysicalDeviceMultiviewPropertiesKHR* = object
  # NV external memory capabilities
  # ===============================
  ExternalImageFormatPropertiesNV* = object
    imageFormatProperties*: ImageFormatProperties
    externalMemoryFeatures* {.optional.}: ExternalMemoryFeatureFlagsNV
    exportFromImportedHandleTypes* {.optional.}: ExternalMemoryHandleTypeFlagsNV
    compatibleHandleTypes* {.optional.}: ExternalMemoryHandleTypeFlagsNV
  # NV external memory
  # ==================
  ExternalMemoryImageCreateInfoNV* = object
    sType* {.constant: (StructureType.externalMemoryImageCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalMemoryHandleTypeFlagsNV
  ExportMemoryAllocateInfoNV* = object
    sType* {.constant: (StructureType.exportMemoryAllocateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    handleTypes* {.optional.}: ExternalMemoryHandleTypeFlagsNV
  # NV external memory win32
  # ========================
  ImportMemoryWin32HandleInfoNV* = object
    sType* {.constant: (StructureType.importMemoryWin32HandleInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    handleType* {.optional.}: ExternalMemoryHandleTypeFlagsNV
    handle* {.optional.}: Win32Handle
  ExportMemoryWin32HandleInfoNV* = object
    sType* {.constant: (StructureType.exportMemoryWin32HandleInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    pAttributes* {.optional.}: ptr SECURITY_ATTRIBUTES
    dwAccess* {.optional.}: DWORD
  # NV win32 keyed mutex
  # ====================
  Win32KeyedMutexAcquireReleaseInfoNV* = object
    sType* {.constant: (StructureType.win32KeyedMutexAcquireReleaseInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    acquireCount* {.optional.}: uint32
    pAcquireSyncs* {.length: acquireCount.}: arrPtr[DeviceMemory]
    pAcquireKeys* {.length: acquireCount.}: arrPtr[uint64]
    pAcquireTimeoutMilliseconds* {.length: acquireCount.}: arrPtr[uint32]
    releaseCount* {.optional.}: uint32
    pReleaseSyncs* {.length: releaseCount.}: arrPtr[DeviceMemory]
    pReleaseKeys* {.length: releaseCount.}: arrPtr[uint64]
  # KHR get physical device properties2
  # ===================================
  PhysicalDeviceFeatures2KHR* = object
  PhysicalDeviceProperties2KHR* = object
  FormatProperties2KHR* = object
  ImageFormatProperties2KHR* = object
  PhysicalDeviceImageFormatInfo2KHR* = object
  QueueFamilyProperties2KHR* = object
  PhysicalDeviceMemoryProperties2KHR* = object
  SparseImageFormatProperties2KHR* = object
  PhysicalDeviceSparseImageFormatInfo2KHR* = object
  # KHR device group
  # ================
  MemoryAllocateFlagsInfoKHR* = object
  DeviceGroupRenderPassBeginInfoKHR* = object
  DeviceGroupCommandBufferBeginInfoKHR* = object
  DeviceGroupSubmitInfoKHR* = object
  DeviceGroupBindSparseInfoKHR* = object
  BindBufferMemoryDeviceGroupInfoKHR* = object
  BindImageMemoryDeviceGroupInfoKHR* = object
  # EXT validation flags
  # ====================
  ValidationFlagsEXT* = object
    sType* {.constant: (StructureType.validationFlagsExt).}: StructureType # Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    pNext* {.optional.}: pointer
    disabledValidationCheckCount*: uint32 # Number of validation checks to disable
    pDisabledValidationChecks* {.length: disabledValidationCheckCount.}: arrPtr[ValidationCheckEXT] # Validation checks to disable
  # NN vi surface
  # =============
  ViSurfaceCreateInfoNN* = object
    sType* {.constant: (StructureType.viSurfaceCreateInfoNn).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ViSurfaceCreateFlagsNN
    window*: pointer
  # EXT texture compression astc hdr
  # ================================
  PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceTextureCompressionAstcHdrFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    textureCompressionASTC_HDR*: Bool32
  # EXT astc decode mode
  # ====================
  ImageViewASTCDecodeModeEXT* = object
    sType* {.constant: (StructureType.imageViewAstcDecodeModeExt).}: StructureType
    pNext* {.optional.}: pointer
    decodeMode*: Format
  PhysicalDeviceASTCDecodeFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceAstcDecodeFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    decodeModeSharedExponent*: Bool32
  # KHR device group creation
  # =========================
  PhysicalDeviceGroupPropertiesKHR* = object
  DeviceGroupDeviceCreateInfoKHR* = object
  # KHR external memory capabilities
  # ================================
  ExternalMemoryPropertiesKHR* = object
  PhysicalDeviceExternalImageFormatInfoKHR* = object
  ExternalImageFormatPropertiesKHR* = object
  PhysicalDeviceExternalBufferInfoKHR* = object
  ExternalBufferPropertiesKHR* = object
  PhysicalDeviceIDPropertiesKHR* = object
  # KHR external memory
  # ===================
  ExternalMemoryImageCreateInfoKHR* = object
  ExternalMemoryBufferCreateInfoKHR* = object
  ExportMemoryAllocateInfoKHR* = object
  # KHR external memory win32
  # =========================
  ImportMemoryWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.importMemoryWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    handleType* {.optional.}: ExternalMemoryHandleTypeFlagBits
    handle* {.optional.}: Win32Handle
    name* {.optional.}: LPCWSTR
  ExportMemoryWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.exportMemoryWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pAttributes* {.optional.}: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR
  MemoryWin32HandlePropertiesKHR* = object
    sType* {.constant: (StructureType.memoryWin32HandlePropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    memoryTypeBits*: uint32
  MemoryGetWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.memoryGetWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
    handleType*: ExternalMemoryHandleTypeFlagBits
  # KHR external memory fd
  # ======================
  ImportMemoryFdInfoKHR* = object
    sType* {.constant: (StructureType.importMemoryFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    handleType* {.optional.}: ExternalMemoryHandleTypeFlagBits
    fd*: int
  MemoryFdPropertiesKHR* = object
    sType* {.constant: (StructureType.memoryFdPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    memoryTypeBits*: uint32
  MemoryGetFdInfoKHR* = object
    sType* {.constant: (StructureType.memoryGetFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
    handleType*: ExternalMemoryHandleTypeFlagBits
  # KHR win32 keyed mutex
  # =====================
  Win32KeyedMutexAcquireReleaseInfoKHR* = object
    sType* {.constant: (StructureType.win32KeyedMutexAcquireReleaseInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    acquireCount* {.optional.}: uint32
    pAcquireSyncs* {.length: acquireCount.}: arrPtr[DeviceMemory]
    pAcquireKeys* {.length: acquireCount.}: arrPtr[uint64]
    pAcquireTimeouts* {.length: acquireCount.}: arrPtr[uint32]
    releaseCount* {.optional.}: uint32
    pReleaseSyncs* {.length: releaseCount.}: arrPtr[DeviceMemory]
    pReleaseKeys* {.length: releaseCount.}: arrPtr[uint64]
  # KHR external semaphore capabilities
  # ===================================
  PhysicalDeviceExternalSemaphoreInfoKHR* = object
  ExternalSemaphorePropertiesKHR* = object
  # KHR external semaphore
  # ======================
  ExportSemaphoreCreateInfoKHR* = object
  # KHR external semaphore win32
  # ============================
  ImportSemaphoreWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.importSemaphoreWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    flags* {.optional.}: SemaphoreImportFlags
    handleType*: ExternalSemaphoreHandleTypeFlagBits
    handle* {.optional.}: Win32Handle
    name* {.optional.}: LPCWSTR
  ExportSemaphoreWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.exportSemaphoreWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pAttributes* {.optional.}: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR
  D3D12FenceSubmitInfoKHR* = object
    sType* {.constant: (StructureType.d3d12FenceSubmitInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    waitSemaphoreValuesCount* {.optional.}: uint32
    pWaitSemaphoreValues* {.optional, length: waitSemaphoreValuesCount.}: arrPtr[uint64]
    signalSemaphoreValuesCount* {.optional.}: uint32
    pSignalSemaphoreValues* {.optional, length: signalSemaphoreValuesCount.}: arrPtr[uint64]
  SemaphoreGetWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.semaphoreGetWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    handleType*: ExternalSemaphoreHandleTypeFlagBits
  # KHR external semaphore fd
  # =========================
  ImportSemaphoreFdInfoKHR* = object
    sType* {.constant: (StructureType.importSemaphoreFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    flags* {.optional.}: SemaphoreImportFlags
    handleType*: ExternalSemaphoreHandleTypeFlagBits
    fd*: int
  SemaphoreGetFdInfoKHR* = object
    sType* {.constant: (StructureType.semaphoreGetFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    handleType*: ExternalSemaphoreHandleTypeFlagBits
  # KHR push descriptor
  # ===================
  PhysicalDevicePushDescriptorPropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePushDescriptorPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    maxPushDescriptors*: uint32
  # EXT conditional rendering
  # =========================
  ConditionalRenderingBeginInfoEXT* = object
    sType* {.constant: (StructureType.conditionalRenderingBeginInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    buffer*: Buffer
    offset*: DeviceSize
    flags* {.optional.}: ConditionalRenderingFlagsEXT
  PhysicalDeviceConditionalRenderingFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceConditionalRenderingFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    conditionalRendering*: Bool32
    inheritedConditionalRendering*: Bool32
  CommandBufferInheritanceConditionalRenderingInfoEXT* = object
    sType* {.constant: (StructureType.commandBufferInheritanceConditionalRenderingInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    conditionalRenderingEnable*: Bool32 # Whether this secondary command buffer may be executed during an active conditional rendering
  # KHR shader float16 int8
  # =======================
  PhysicalDeviceShaderFloat16Int8FeaturesKHR* = object
  PhysicalDeviceFloat16Int8FeaturesKHR* = object
  # KHR 16bit storage
  # =================
  PhysicalDevice16BitStorageFeaturesKHR* = object
  # KHR incremental present
  # =======================
  PresentRegionsKHR* = object
    sType* {.constant: (StructureType.presentRegionsKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchainCount*: uint32 # Copy of VkPresentInfoKHR::swapchainCount
    pRegions* {.optional, length: swapchainCount.}: arrPtr[PresentRegionKHR] # The regions that have changed
  PresentRegionKHR* = object
    rectangleCount* {.optional.}: uint32 # Number of rectangles in pRectangles
    pRectangles* {.optional, length: rectangleCount.}: arrPtr[RectLayerKHR] # Array of rectangles that have changed in a swapchain's image(s)
  RectLayerKHR* = object
    offset*: Offset2D # upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    extent*: Extent2D # Dimensions of a rectangle that has not changed, in pixels of a presentation images
    layer*: uint32 # Layer of a swapchain's image(s), for stereoscopic-3D images
  # KHR descriptor update template
  # ==============================
  DescriptorUpdateTemplateEntryKHR* = object
  DescriptorUpdateTemplateCreateInfoKHR* = object
  # NV clip space w scaling
  # =======================
  ViewportWScalingNV* = object
    xcoeff*: float32
    ycoeff*: float32
  PipelineViewportWScalingStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineViewportWScalingStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    viewportWScalingEnable*: Bool32
    viewportCount*: uint32
    pViewportWScalings* {.optional, length: viewportCount.}: arrPtr[ViewportWScalingNV]
  # EXT display surface counter
  # ===========================
  SurfaceCapabilities2EXT* = object
    sType* {.constant: (StructureType.surfaceCapabilities2Ext).}: StructureType
    pNext* {.optional.}: pointer
    minImageCount*: uint32 # Supported minimum number of images for the surface
    maxImageCount*: uint32 # Supported maximum number of images for the surface, 0 for unlimited
    currentExtent*: Extent2D # Current image width and height for the surface, (0, 0) if undefined
    minImageExtent*: Extent2D # Supported minimum image width and height for the surface
    maxImageExtent*: Extent2D # Supported maximum image width and height for the surface
    maxImageArrayLayers*: uint32 # Supported maximum number of image layers for the surface
    supportedTransforms*: SurfaceTransformFlagsKHR # 1 or more bits representing the transforms supported
    currentTransform*: SurfaceTransformFlagBitsKHR # The surface's current transform relative to the device's natural orientation
    supportedCompositeAlpha*: CompositeAlphaFlagsKHR # 1 or more bits representing the alpha compositing modes supported
    supportedUsageFlags*: ImageUsageFlags # Supported image usage flags for the surface
    supportedSurfaceCounters* {.optional.}: SurfaceCounterFlagsEXT
  # EXT display control
  # ===================
  DisplayPowerInfoEXT* = object
    sType* {.constant: (StructureType.displayPowerInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    powerState*: DisplayPowerStateEXT
  DeviceEventInfoEXT* = object
    sType* {.constant: (StructureType.deviceEventInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    deviceEvent*: DeviceEventTypeEXT
  DisplayEventInfoEXT* = object
    sType* {.constant: (StructureType.displayEventInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    displayEvent*: DisplayEventTypeEXT
  SwapchainCounterCreateInfoEXT* = object
    sType* {.constant: (StructureType.swapchainCounterCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    surfaceCounters* {.optional.}: SurfaceCounterFlagsEXT
  # GOOGLE display timing
  # =====================
  RefreshCycleDurationGOOGLE* = object
    refreshDuration*: uint64 # Number of nanoseconds from the start of one refresh cycle to the next
  PastPresentationTimingGOOGLE* = object
    presentID*: uint32 # Application-provided identifier, previously given to vkQueuePresentKHR
    desiredPresentTime*: uint64 # Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    actualPresentTime*: uint64 # Time the image was actually displayed
    earliestPresentTime*: uint64 # Earliest time the image could have been displayed
    presentMargin*: uint64 # How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
  PresentTimesInfoGOOGLE* = object
    sType* {.constant: (StructureType.presentTimesInfoGoogle).}: StructureType
    pNext* {.optional.}: pointer
    swapchainCount*: uint32 # Copy of VkPresentInfoKHR::swapchainCount
    pTimes* {.optional, length: swapchainCount.}: arrPtr[PresentTimeGOOGLE] # The earliest times to present images
  PresentTimeGOOGLE* = object
    presentID*: uint32 # Application-provided identifier
    desiredPresentTime*: uint64 # Earliest time an image should be presented
  # NVX multiview per view attributes
  # =================================
  PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* = object
    sType* {.constant: (StructureType.physicalDeviceMultiviewPerViewAttributesPropertiesNvx).}: StructureType
    pNext* {.optional.}: pointer
    perViewPositionAllComponents*: Bool32
  # NV viewport swizzle
  # ===================
  ViewportSwizzleNV* = object
    x*: ViewportCoordinateSwizzleNV
    y*: ViewportCoordinateSwizzleNV
    z*: ViewportCoordinateSwizzleNV
    w*: ViewportCoordinateSwizzleNV
  PipelineViewportSwizzleStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineViewportSwizzleStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineViewportSwizzleStateCreateFlagsNV
    viewportCount*: uint32
    pViewportSwizzles* {.length: viewportCount.}: arrPtr[ViewportSwizzleNV]
  # EXT discard rectangles
  # ======================
  PhysicalDeviceDiscardRectanglePropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceDiscardRectanglePropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxDiscardRectangles*: uint32 # max number of active discard rectangles
  PipelineDiscardRectangleStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineDiscardRectangleStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineDiscardRectangleStateCreateFlagsEXT
    discardRectangleMode*: DiscardRectangleModeEXT
    discardRectangleCount* {.optional.}: uint32
    pDiscardRectangles* {.length: discardRectangleCount.}: arrPtr[Rect2D]
  # EXT conservative rasterization
  # ==============================
  PhysicalDeviceConservativeRasterizationPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceConservativeRasterizationPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    primitiveOverestimationSize*: float32 # The size in pixels the primitive is enlarged at each edge during conservative rasterization
    maxExtraPrimitiveOverestimationSize*: float32 # The maximum additional overestimation the client can specify in the pipeline state
    extraPrimitiveOverestimationSizeGranularity*: float32 # The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    primitiveUnderestimation*: Bool32 # true if the implementation supports conservative rasterization underestimation mode
    conservativePointAndLineRasterization*: Bool32 # true if conservative rasterization also applies to points and lines
    degenerateTrianglesRasterized*: Bool32 # true if degenerate triangles (those with zero area after snap) are rasterized
    degenerateLinesRasterized*: Bool32 # true if degenerate lines (those with zero length after snap) are rasterized
    fullyCoveredFragmentShaderInputVariable*: Bool32 # true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    conservativeRasterizationPostDepthCoverage*: Bool32 # true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
  PipelineRasterizationConservativeStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineRasterizationConservativeStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineRasterizationConservativeStateCreateFlagsEXT # Reserved
    conservativeRasterizationMode*: ConservativeRasterizationModeEXT # Conservative rasterization mode
    extraPrimitiveOverestimationSize*: float32 # Extra overestimation to add to the primitive
  # EXT depth clip enable
  # =====================
  PhysicalDeviceDepthClipEnableFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceDepthClipEnableFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    depthClipEnable*: Bool32
  PipelineRasterizationDepthClipStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineRasterizationDepthClipStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineRasterizationDepthClipStateCreateFlagsEXT # Reserved
    depthClipEnable*: Bool32
  # EXT hdr metadata
  # ================
  # Display primary in chromaticity coordinates
  HdrMetadataEXT* = object
    sType* {.constant: (StructureType.hdrMetadataExt).}: StructureType
    pNext* {.optional.}: pointer
    displayPrimaryRed*: XYColorEXT # Display primary's Red
    displayPrimaryGreen*: XYColorEXT # Display primary's Green
    displayPrimaryBlue*: XYColorEXT # Display primary's Blue
    whitePoint*: XYColorEXT # Display primary's Blue
    maxLuminance*: float32 # Display maximum luminance
    minLuminance*: float32 # Display minimum luminance
    maxContentLightLevel*: float32 # Content maximum luminance
    maxFrameAverageLightLevel*: float32
  XYColorEXT* = object
    x*: float32
    y*: float32
  # KHR imageless framebuffer
  # =========================
  PhysicalDeviceImagelessFramebufferFeaturesKHR* = object
  FramebufferAttachmentsCreateInfoKHR* = object
  FramebufferAttachmentImageInfoKHR* = object
  RenderPassAttachmentBeginInfoKHR* = object
  # KHR create renderpass2
  # ======================
  RenderPassCreateInfo2KHR* = object
  AttachmentDescription2KHR* = object
  AttachmentReference2KHR* = object
  SubpassDescription2KHR* = object
  SubpassDependency2KHR* = object
  SubpassBeginInfoKHR* = object
  SubpassEndInfoKHR* = object
  # KHR shared presentable image
  # ============================
  SharedPresentSurfaceCapabilitiesKHR* = object
    sType* {.constant: (StructureType.sharedPresentSurfaceCapabilitiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    sharedPresentSupportedUsageFlags* {.optional.}: ImageUsageFlags # Supported image usage flags if swapchain created using a shared present mode
  # KHR external fence capabilities
  # ===============================
  PhysicalDeviceExternalFenceInfoKHR* = object
  ExternalFencePropertiesKHR* = object
  # KHR external fence
  # ==================
  ExportFenceCreateInfoKHR* = object
  # KHR external fence win32
  # ========================
  ImportFenceWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.importFenceWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    fence*: Fence
    flags* {.optional.}: FenceImportFlags
    handleType*: ExternalFenceHandleTypeFlagBits
    handle* {.optional.}: Win32Handle
    name* {.optional.}: LPCWSTR
  ExportFenceWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.exportFenceWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pAttributes* {.optional.}: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR
  FenceGetWin32HandleInfoKHR* = object
    sType* {.constant: (StructureType.fenceGetWin32HandleInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    fence*: Fence
    handleType*: ExternalFenceHandleTypeFlagBits
  # KHR external fence fd
  # =====================
  ImportFenceFdInfoKHR* = object
    sType* {.constant: (StructureType.importFenceFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    fence*: Fence
    flags* {.optional.}: FenceImportFlags
    handleType*: ExternalFenceHandleTypeFlagBits
    fd*: int
  FenceGetFdInfoKHR* = object
    sType* {.constant: (StructureType.fenceGetFdInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    fence*: Fence
    handleType*: ExternalFenceHandleTypeFlagBits
  # KHR performance query
  # =====================
  PhysicalDevicePerformanceQueryFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePerformanceQueryFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    performanceCounterQueryPools*: Bool32 # performance counters supported in query pools
    performanceCounterMultipleQueryPools*: Bool32 # performance counters from multiple query pools can be accessed in the same primary command buffer
  PhysicalDevicePerformanceQueryPropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePerformanceQueryPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    allowCommandBufferQueryCopies*: Bool32 # Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
  PerformanceCounterKHR* = object
    sType* {.constant: (StructureType.performanceCounterKhr).}: StructureType
    pNext* {.optional.}: pointer
    unit*: PerformanceCounterUnitKHR
    scope*: PerformanceCounterScopeKHR
    storage*: PerformanceCounterStorageKHR
    uuid*: array[UuidSize, uint8]
  PerformanceCounterDescriptionKHR* = object
    sType* {.constant: (StructureType.performanceCounterDescriptionKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PerformanceCounterDescriptionFlagsKHR
    name*: array[MaxDescriptionSize, char]
    category*: array[MaxDescriptionSize, char]
    description*: array[MaxDescriptionSize, char]
  QueryPoolPerformanceCreateInfoKHR* = object
    sType* {.constant: (StructureType.queryPoolPerformanceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    queueFamilyIndex*: uint32
    counterIndexCount*: uint32
    pCounterIndices* {.length: counterIndexCount.}: arrPtr[uint32]
  PerformanceCounterResultKHR* {.union.} = object
    int32*: int32
    int64*: int64
    uint32*: uint32
    uint64*: uint64
    float32*: float32
    float64*: float64
  AcquireProfilingLockInfoKHR* = object
    sType* {.constant: (StructureType.acquireProfilingLockInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: AcquireProfilingLockFlagsKHR # Acquire profiling lock flags
    timeout*: uint64
  PerformanceQuerySubmitInfoKHR* = object
    sType* {.constant: (StructureType.performanceQuerySubmitInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    counterPassIndex*: uint32 # Index for which counter pass to submit
  # KHR maintenance2
  # ================
  PhysicalDevicePointClippingPropertiesKHR* = object
  RenderPassInputAttachmentAspectCreateInfoKHR* = object
  InputAttachmentAspectReferenceKHR* = object
  ImageViewUsageCreateInfoKHR* = object
  PipelineTessellationDomainOriginStateCreateInfoKHR* = object
  # KHR get surface capabilities2
  # =============================
  PhysicalDeviceSurfaceInfo2KHR* = object
    sType* {.constant: (StructureType.physicalDeviceSurfaceInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    surface* {.optional.}: SurfaceKHR
  SurfaceCapabilities2KHR* = object
    sType* {.constant: (StructureType.surfaceCapabilities2Khr).}: StructureType
    pNext* {.optional.}: pointer
    surfaceCapabilities*: SurfaceCapabilitiesKHR
  SurfaceFormat2KHR* = object
    sType* {.constant: (StructureType.surfaceFormat2Khr).}: StructureType
    pNext* {.optional.}: pointer
    surfaceFormat*: SurfaceFormatKHR
  # KHR variable pointers
  # =====================
  PhysicalDeviceVariablePointerFeaturesKHR* = object
  PhysicalDeviceVariablePointersFeaturesKHR* = object
  # KHR get display properties2
  # ===========================
  DisplayProperties2KHR* = object
    sType* {.constant: (StructureType.displayProperties2Khr).}: StructureType
    pNext* {.optional.}: pointer
    displayProperties*: DisplayPropertiesKHR
  DisplayPlaneProperties2KHR* = object
    sType* {.constant: (StructureType.displayPlaneProperties2Khr).}: StructureType
    pNext* {.optional.}: pointer
    displayPlaneProperties*: DisplayPlanePropertiesKHR
  DisplayModeProperties2KHR* = object
    sType* {.constant: (StructureType.displayModeProperties2Khr).}: StructureType
    pNext* {.optional.}: pointer
    displayModeProperties*: DisplayModePropertiesKHR
  DisplayPlaneInfo2KHR* = object
    sType* {.constant: (StructureType.displayPlaneInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    mode*: DisplayModeKHR
    planeIndex*: uint32
  DisplayPlaneCapabilities2KHR* = object
    sType* {.constant: (StructureType.displayPlaneCapabilities2Khr).}: StructureType
    pNext* {.optional.}: pointer
    capabilities*: DisplayPlaneCapabilitiesKHR
  # Mios surface
  # ============
  IOSSurfaceCreateInfoMVK* = object
    sType* {.constant: (StructureType.iosSurfaceCreateInfoM).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: IOSSurfaceCreateFlagsMVK
    pView*: pointer
  # Mmacos surface
  # ==============
  MacOSSurfaceCreateInfoMVK* = object
    sType* {.constant: (StructureType.macosSurfaceCreateInfoM).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: MacOSSurfaceCreateFlagsMVK
    pView*: pointer
  # KHR dedicated allocation
  # ========================
  MemoryDedicatedRequirementsKHR* = object
  MemoryDedicatedAllocateInfoKHR* = object
  # EXT debug utils
  # ===============
  PFN_DebugUtilsMessengerCallbackEXT* = proc(
      messageSeverity: DebugUtilsMessageSeverityFlagBitsEXT;
      messageTypes: DebugUtilsMessageTypeFlagsEXT;
      pCallbackData: ptr DebugUtilsMessengerCallbackDataEXT;
      pUserData: pointer;
    ): Bool32 {.cdecl.}
  DebugUtilsLabelEXT* = object
    sType* {.constant: (StructureType.debugUtilsLabelExt).}: StructureType
    pNext* {.optional.}: pointer
    pLabelName*: cstring
    color*: array[4, float32]
  DebugUtilsMessengerCallbackDataEXT* = object
    sType* {.constant: (StructureType.debugUtilsMessengerCallbackDataExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DebugUtilsMessengerCallbackDataFlagsEXT
    pMessageIdName* {.optional.}: cstring
    messageIdNumber*: int32
    pMessage*: cstring
    queueLabelCount* {.optional.}: uint32
    pQueueLabels* {.length: queueLabelCount.}: arrPtr[DebugUtilsLabelEXT]
    cmdBufLabelCount* {.optional.}: uint32
    pCmdBufLabels* {.length: cmdBufLabelCount.}: arrPtr[DebugUtilsLabelEXT]
    objectCount* {.optional.}: uint32
    pObjects* {.length: objectCount.}: arrPtr[DebugUtilsObjectNameInfoEXT]
  DebugUtilsMessengerCreateInfoEXT* = object
    sType* {.constant: (StructureType.debugUtilsMessengerCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DebugUtilsMessengerCreateFlagsEXT
    messageSeverity*: DebugUtilsMessageSeverityFlagsEXT
    messageType*: DebugUtilsMessageTypeFlagsEXT
    pfnUserCallback*: PFN_DebugUtilsMessengerCallbackEXT
    pUserData* {.optional.}: pointer
  DebugUtilsObjectNameInfoEXT* = object
    sType* {.constant: (StructureType.debugUtilsObjectNameInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    objectType*: ObjectType
    objectHandle*: uint64
    pObjectName* {.optional.}: cstring
  DebugUtilsObjectTagInfoEXT* = object
    sType* {.constant: (StructureType.debugUtilsObjectTagInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    objectType*: ObjectType
    objectHandle*: uint64
    tagName*: uint64
    tagSize*: uint
    pTag* {.length: tagSize.}: pointer
  # ANDROID external memory android hardware buffer
  # ===============================================
  AndroidHardwareBufferUsageANDROID* = object
    sType* {.constant: (StructureType.androidHardwareBufferUsageAndroid).}: StructureType
    pNext* {.optional.}: pointer
    androidHardwareBufferUsage*: uint64
  AndroidHardwareBufferPropertiesANDROID* = object
    sType* {.constant: (StructureType.androidHardwareBufferPropertiesAndroid).}: StructureType
    pNext* {.optional.}: pointer
    allocationSize*: DeviceSize
    memoryTypeBits*: uint32
  AndroidHardwareBufferFormatPropertiesANDROID* = object
    sType* {.constant: (StructureType.androidHardwareBufferFormatPropertiesAndroid).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
    externalFormat*: uint64
    formatFeatures*: FormatFeatureFlags
    samplerYcbcrConversionComponents*: ComponentMapping
    suggestedYcbcrModel*: SamplerYcbcrModelConversion
    suggestedYcbcrRange*: SamplerYcbcrRange
    suggestedXChromaOffset*: ChromaLocation
    suggestedYChromaOffset*: ChromaLocation
  ImportAndroidHardwareBufferInfoANDROID* = object
    sType* {.constant: (StructureType.importAndroidHardwareBufferInfoAndroid).}: StructureType
    pNext* {.optional.}: pointer
    buffer*: ptr AHardwareBuffer
  MemoryGetAndroidHardwareBufferInfoANDROID* = object
    sType* {.constant: (StructureType.memoryGetAndroidHardwareBufferInfoAndroid).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
  ExternalFormatANDROID* = object
    sType* {.constant: (StructureType.externalFormatAndroid).}: StructureType
    pNext* {.optional.}: pointer
    externalFormat*: uint64
  AndroidHardwareBufferFormatProperties2ANDROID* = object
    sType* {.constant: (StructureType.androidHardwareBufferFormatProperties2Android).}: StructureType
    pNext* {.optional.}: pointer
    format*: Format
    externalFormat*: uint64
    formatFeatures*: FormatFeatureFlags2KHR
    samplerYcbcrConversionComponents*: ComponentMapping
    suggestedYcbcrModel*: SamplerYcbcrModelConversion
    suggestedYcbcrRange*: SamplerYcbcrRange
    suggestedXChromaOffset*: ChromaLocation
    suggestedYChromaOffset*: ChromaLocation
  # EXT sampler filter minmax
  # =========================
  SamplerReductionModeCreateInfoEXT* = object
  PhysicalDeviceSamplerFilterMinmaxPropertiesEXT* = object
  # EXT inline uniform block
  # ========================
  PhysicalDeviceInlineUniformBlockFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceInlineUniformBlockFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    inlineUniformBlock*: Bool32
    descriptorBindingInlineUniformBlockUpdateAfterBind*: Bool32
  PhysicalDeviceInlineUniformBlockPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceInlineUniformBlockPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxInlineUniformBlockSize*: uint32
    maxPerStageDescriptorInlineUniformBlocks*: uint32
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks*: uint32
    maxDescriptorSetInlineUniformBlocks*: uint32
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks*: uint32
  WriteDescriptorSetInlineUniformBlockEXT* = object
    sType* {.constant: (StructureType.writeDescriptorSetInlineUniformBlockExt).}: StructureType
    pNext* {.optional.}: pointer
    dataSize*: uint32
    pData* {.length: dataSize.}: pointer
  DescriptorPoolInlineUniformBlockCreateInfoEXT* = object
    sType* {.constant: (StructureType.descriptorPoolInlineUniformBlockCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    maxInlineUniformBlockBindings*: uint32
  # EXT sample locations
  # ====================
  SampleLocationEXT* = object
    x*: float32
    y*: float32
  SampleLocationsInfoEXT* = object
    sType* {.constant: (StructureType.sampleLocationsInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    sampleLocationsPerPixel*: SampleCountFlagBits
    sampleLocationGridSize*: Extent2D
    sampleLocationsCount* {.optional.}: uint32
    pSampleLocations* {.length: sampleLocationsCount.}: arrPtr[SampleLocationEXT]
  AttachmentSampleLocationsEXT* = object
    attachmentIndex*: uint32
    sampleLocationsInfo*: SampleLocationsInfoEXT
  SubpassSampleLocationsEXT* = object
    subpassIndex*: uint32
    sampleLocationsInfo*: SampleLocationsInfoEXT
  RenderPassSampleLocationsBeginInfoEXT* = object
    sType* {.constant: (StructureType.renderPassSampleLocationsBeginInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    attachmentInitialSampleLocationsCount* {.optional.}: uint32
    pAttachmentInitialSampleLocations* {.length: attachmentInitialSampleLocationsCount.}: arrPtr[AttachmentSampleLocationsEXT]
    postSubpassSampleLocationsCount* {.optional.}: uint32
    pPostSubpassSampleLocations* {.length: postSubpassSampleLocationsCount.}: arrPtr[SubpassSampleLocationsEXT]
  PipelineSampleLocationsStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineSampleLocationsStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    sampleLocationsEnable*: Bool32
    sampleLocationsInfo*: SampleLocationsInfoEXT
  PhysicalDeviceSampleLocationsPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceSampleLocationsPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    sampleLocationSampleCounts*: SampleCountFlags
    maxSampleLocationGridSize*: Extent2D
    sampleLocationCoordinateRange*: array[2, float32]
    sampleLocationSubPixelBits*: uint32
    variableSampleLocations*: Bool32
  MultisamplePropertiesEXT* = object
    sType* {.constant: (StructureType.multisamplePropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxSampleLocationGridSize*: Extent2D
  # KHR get memory requirements2
  # ============================
  BufferMemoryRequirementsInfo2KHR* = object
  ImageMemoryRequirementsInfo2KHR* = object
  ImageSparseMemoryRequirementsInfo2KHR* = object
  MemoryRequirements2KHR* = object
  SparseImageMemoryRequirements2KHR* = object
  # KHR image format list
  # =====================
  ImageFormatListCreateInfoKHR* = object
  # EXT blend operation advanced
  # ============================
  PhysicalDeviceBlendOperationAdvancedFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceBlendOperationAdvancedFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    advancedBlendCoherentOperations*: Bool32
  PhysicalDeviceBlendOperationAdvancedPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceBlendOperationAdvancedPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    advancedBlendMaxColorAttachments*: uint32
    advancedBlendIndependentBlend*: Bool32
    advancedBlendNonPremultipliedSrcColor*: Bool32
    advancedBlendNonPremultipliedDstColor*: Bool32
    advancedBlendCorrelatedOverlap*: Bool32
    advancedBlendAllOperations*: Bool32
  PipelineColorBlendAdvancedStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineColorBlendAdvancedStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    srcPremultiplied*: Bool32
    dstPremultiplied*: Bool32
    blendOverlap*: BlendOverlapEXT
  # NV fragment coverage to color
  # =============================
  PipelineCoverageToColorStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineCoverageToColorStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCoverageToColorStateCreateFlagsNV
    coverageToColorEnable*: Bool32
    coverageToColorLocation* {.optional.}: uint32
  # KHR acceleration structure
  # ==========================
  DeviceOrHostAddressKHR* {.union.} = object
    deviceAddress*: DeviceAddress
    hostAddress*: pointer
  DeviceOrHostAddressConstKHR* {.union.} = object
    deviceAddress*: DeviceAddress
    hostAddress*: pointer
  AccelerationStructureBuildRangeInfoKHR* = object
    primitiveCount*: uint32
    primitiveOffset*: uint32
    firstVertex*: uint32
    transformOffset*: uint32
  AabbPositionsKHR* = object
    minX*: float32
    minY*: float32
    minZ*: float32
    maxX*: float32
    maxY*: float32
    maxZ*: float32
  AccelerationStructureGeometryTrianglesDataKHR* = object
    sType* {.constant: (StructureType.accelerationStructureGeometryTrianglesDataKhr).}: StructureType
    pNext* {.optional.}: pointer
    vertexFormat*: Format
    vertexData*: DeviceOrHostAddressConstKHR
    vertexStride*: DeviceSize
    maxVertex*: uint32
    indexType*: IndexType
    indexData*: DeviceOrHostAddressConstKHR
    transformData*: DeviceOrHostAddressConstKHR
  TransformMatrixKHR* = object
    matrix*: array[3, array[4, float32]]
  AccelerationStructureBuildGeometryInfoKHR* = object
    sType* {.constant: (StructureType.accelerationStructureBuildGeometryInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    theType*: AccelerationStructureTypeKHR
    flags* {.optional.}: BuildAccelerationStructureFlagsKHR
    mode*: BuildAccelerationStructureModeKHR
    srcAccelerationStructure* {.optional.}: AccelerationStructureKHR
    dstAccelerationStructure* {.optional.}: AccelerationStructureKHR
    geometryCount* {.optional.}: uint32
    pGeometries* {.optional, length: geometryCount.}: arrPtr[AccelerationStructureGeometryKHR]
    ppGeometries* {.length: geometryCount.}: arrPtr[arrPtr[AccelerationStructureGeometryKHR]]
    scratchData*: DeviceOrHostAddressKHR
  AccelerationStructureGeometryAabbsDataKHR* = object
    sType* {.constant: (StructureType.accelerationStructureGeometryAabbsDataKhr).}: StructureType
    pNext* {.optional.}: pointer
    data*: DeviceOrHostAddressConstKHR
    stride*: DeviceSize
  # The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
  AccelerationStructureInstanceKHR* = object
    transform*: TransformMatrixKHR
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags* {.optional.}: GeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64
  AccelerationStructureGeometryInstancesDataKHR* = object
    sType* {.constant: (StructureType.accelerationStructureGeometryInstancesDataKhr).}: StructureType
    pNext* {.optional.}: pointer
    arrayOfPointers*: Bool32
    data*: DeviceOrHostAddressConstKHR
  AccelerationStructureGeometryDataKHR* {.union.} = object
    triangles*: AccelerationStructureGeometryTrianglesDataKHR
    aabbs*: AccelerationStructureGeometryAabbsDataKHR
    instances*: AccelerationStructureGeometryInstancesDataKHR
  AccelerationStructureGeometryKHR* = object
    sType* {.constant: (StructureType.accelerationStructureGeometryKhr).}: StructureType
    pNext* {.optional.}: pointer
    geometryType*: GeometryTypeKHR
    geometry*: AccelerationStructureGeometryDataKHR
    flags* {.optional.}: GeometryFlagsKHR
  AccelerationStructureCreateInfoKHR* = object
    sType* {.constant: (StructureType.accelerationStructureCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    createFlags* {.optional.}: AccelerationStructureCreateFlagsKHR
    buffer*: Buffer
    offset*: DeviceSize # Specified in bytes
    size*: DeviceSize
    theType*: AccelerationStructureTypeKHR
    deviceAddress* {.optional.}: DeviceAddress
  WriteDescriptorSetAccelerationStructureKHR* = object
    sType* {.constant: (StructureType.writeDescriptorSetAccelerationStructureKhr).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructureCount*: uint32
    pAccelerationStructures* {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureKHR]
  PhysicalDeviceAccelerationStructureFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceAccelerationStructureFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructure*: Bool32
    accelerationStructureCaptureReplay*: Bool32
    accelerationStructureIndirectBuild*: Bool32
    accelerationStructureHostCommands*: Bool32
    descriptorBindingAccelerationStructureUpdateAfterBind*: Bool32
  PhysicalDeviceAccelerationStructurePropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceAccelerationStructurePropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    maxGeometryCount*: uint64
    maxInstanceCount*: uint64
    maxPrimitiveCount*: uint64
    maxPerStageDescriptorAccelerationStructures*: uint32
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures*: uint32
    maxDescriptorSetAccelerationStructures*: uint32
    maxDescriptorSetUpdateAfterBindAccelerationStructures*: uint32
    minAccelerationStructureScratchOffsetAlignment*: uint32
  AccelerationStructureDeviceAddressInfoKHR* = object
    sType* {.constant: (StructureType.accelerationStructureDeviceAddressInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructure*: AccelerationStructureKHR
  AccelerationStructureVersionInfoKHR* = object
    sType* {.constant: (StructureType.accelerationStructureVersionInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pVersionData* {.length: 2*VK_UUID_SIZE.}: arrPtr[arrPtr[uint8]]
  CopyAccelerationStructureToMemoryInfoKHR* = object
    sType* {.constant: (StructureType.copyAccelerationStructureToMemoryInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    src*: AccelerationStructureKHR
    dst*: DeviceOrHostAddressKHR
    mode*: CopyAccelerationStructureModeKHR
  CopyMemoryToAccelerationStructureInfoKHR* = object
    sType* {.constant: (StructureType.copyMemoryToAccelerationStructureInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    src*: DeviceOrHostAddressConstKHR
    dst*: AccelerationStructureKHR
    mode*: CopyAccelerationStructureModeKHR
  CopyAccelerationStructureInfoKHR* = object
    sType* {.constant: (StructureType.copyAccelerationStructureInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    src*: AccelerationStructureKHR
    dst*: AccelerationStructureKHR
    mode*: CopyAccelerationStructureModeKHR
  AccelerationStructureBuildSizesInfoKHR* = object
    sType* {.constant: (StructureType.accelerationStructureBuildSizesInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructureSize*: DeviceSize
    updateScratchSize*: DeviceSize
    buildScratchSize*: DeviceSize
  # KHR ray tracing pipeline
  # ========================
  RayTracingShaderGroupCreateInfoKHR* = object
    sType* {.constant: (StructureType.rayTracingShaderGroupCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    theType*: RayTracingShaderGroupTypeKHR
    generalShader*: uint32
    closestHitShader*: uint32
    anyHitShader*: uint32
    intersectionShader*: uint32
    pShaderGroupCaptureReplayHandle* {.optional.}: pointer
  RayTracingPipelineCreateInfoKHR* = object
    sType* {.constant: (StructureType.rayTracingPipelineCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCreateFlags # Pipeline creation flags
    stageCount* {.optional.}: uint32
    pStages* {.length: stageCount.}: arrPtr[PipelineShaderStageCreateInfo] # One entry for each active shader stage
    groupCount* {.optional.}: uint32
    pGroups* {.length: groupCount.}: arrPtr[RayTracingShaderGroupCreateInfoKHR]
    maxPipelineRayRecursionDepth*: uint32
    pLibraryInfo* {.optional.}: ptr PipelineLibraryCreateInfoKHR
    pLibraryInterface* {.optional.}: ptr RayTracingPipelineInterfaceCreateInfoKHR
    pDynamicState* {.optional.}: ptr PipelineDynamicStateCreateInfo
    layout*: PipelineLayout # Interface layout of the pipeline
    basePipelineHandle* {.optional.}: Pipeline # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex*: int32 # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  PhysicalDeviceRayTracingPipelineFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceRayTracingPipelineFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    rayTracingPipeline*: Bool32
    rayTracingPipelineShaderGroupHandleCaptureReplay*: Bool32
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed*: Bool32
    rayTracingPipelineTraceRaysIndirect*: Bool32
    rayTraversalPrimitiveCulling*: Bool32
  PhysicalDeviceRayTracingPipelinePropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceRayTracingPipelinePropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderGroupHandleSize*: uint32
    maxRayRecursionDepth*: uint32
    maxShaderGroupStride*: uint32
    shaderGroupBaseAlignment*: uint32
    shaderGroupHandleCaptureReplaySize*: uint32
    maxRayDispatchInvocationCount*: uint32
    shaderGroupHandleAlignment*: uint32
    maxRayHitAttributeSize*: uint32
  StridedDeviceAddressRegionKHR* = object
    deviceAddress* {.optional.}: DeviceAddress
    stride*: DeviceSize
    size*: DeviceSize
  TraceRaysIndirectCommandKHR* = object
    width*: uint32
    height*: uint32
    depth*: uint32
  RayTracingPipelineInterfaceCreateInfoKHR* = object
    sType* {.constant: (StructureType.rayTracingPipelineInterfaceCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    maxPipelineRayPayloadSize*: uint32
    maxPipelineRayHitAttributeSize*: uint32
  # KHR ray query
  # =============
  PhysicalDeviceRayQueryFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceRayQueryFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    rayQuery*: Bool32
  # NV framebuffer mixed samples
  # ============================
  PipelineCoverageModulationStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineCoverageModulationStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCoverageModulationStateCreateFlagsNV
    coverageModulationMode*: CoverageModulationModeNV
    coverageModulationTableEnable*: Bool32
    coverageModulationTableCount* {.optional.}: uint32
    pCoverageModulationTable* {.optional, length: coverageModulationTableCount.}: arrPtr[float32]
  # NV shader sm builtins
  # =====================
  PhysicalDeviceShaderSMBuiltinsPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceShaderSmBuiltinsPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    shaderSMCount*: uint32
    shaderWarpsPerSM*: uint32
  PhysicalDeviceShaderSMBuiltinsFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceShaderSmBuiltinsFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    shaderSMBuiltins*: Bool32
  # KHR sampler ycbcr conversion
  # ============================
  SamplerYcbcrConversionCreateInfoKHR* = object
  SamplerYcbcrConversionInfoKHR* = object
  BindImagePlaneMemoryInfoKHR* = object
  ImagePlaneMemoryRequirementsInfoKHR* = object
  PhysicalDeviceSamplerYcbcrConversionFeaturesKHR* = object
  SamplerYcbcrConversionImageFormatPropertiesKHR* = object
  # KHR bind memory2
  # ================
  BindBufferMemoryInfoKHR* = object
  BindImageMemoryInfoKHR* = object
  # EXT image drm format modifier
  # =============================
  DrmFormatModifierPropertiesListEXT* = object
    sType* {.constant: (StructureType.drmFormatModifierPropertiesListExt).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifierCount* {.optional.}: uint32
    pDrmFormatModifierProperties* {.length: drmFormatModifierCount.}: arrPtr[DrmFormatModifierPropertiesEXT]
  DrmFormatModifierPropertiesEXT* = object
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    drmFormatModifierTilingFeatures*: FormatFeatureFlags
  PhysicalDeviceImageDrmFormatModifierInfoEXT* = object
    sType* {.constant: (StructureType.physicalDeviceImageDrmFormatModifierInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifier*: uint64
    sharingMode*: SharingMode
    queueFamilyIndexCount* {.optional.}: uint32
    pQueueFamilyIndices* {.length: queueFamilyIndexCount.}: arrPtr[uint32]
  ImageDrmFormatModifierListCreateInfoEXT* = object
    sType* {.constant: (StructureType.imageDrmFormatModifierListCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifierCount*: uint32
    pDrmFormatModifiers* {.length: drmFormatModifierCount.}: arrPtr[uint64]
  ImageDrmFormatModifierExplicitCreateInfoEXT* = object
    sType* {.constant: (StructureType.imageDrmFormatModifierExplicitCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    pPlaneLayouts* {.length: drmFormatModifierPlaneCount.}: arrPtr[SubresourceLayout]
  ImageDrmFormatModifierPropertiesEXT* = object
    sType* {.constant: (StructureType.imageDrmFormatModifierPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifier*: uint64
  DrmFormatModifierPropertiesList2EXT* = object
    sType* {.constant: (StructureType.drmFormatModifierPropertiesList2Ext).}: StructureType
    pNext* {.optional.}: pointer
    drmFormatModifierCount* {.optional.}: uint32
    pDrmFormatModifierProperties* {.length: drmFormatModifierCount.}: arrPtr[DrmFormatModifierProperties2EXT]
  DrmFormatModifierProperties2EXT* = object
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    drmFormatModifierTilingFeatures*: FormatFeatureFlags2KHR
  # EXT validation cache
  # ====================
  ValidationCacheCreateInfoEXT* = object
    sType* {.constant: (StructureType.validationCacheCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ValidationCacheCreateFlagsEXT
    initialDataSize* {.optional.}: uint
    pInitialData* {.length: initialDataSize.}: pointer
  ShaderModuleValidationCacheCreateInfoEXT* = object
    sType* {.constant: (StructureType.shaderModuleValidationCacheCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    validationCache*: ValidationCacheEXT
  # EXT descriptor indexing
  # =======================
  DescriptorSetLayoutBindingFlagsCreateInfoEXT* = object
  PhysicalDeviceDescriptorIndexingFeaturesEXT* = object
  PhysicalDeviceDescriptorIndexingPropertiesEXT* = object
  DescriptorSetVariableDescriptorCountAllocateInfoEXT* = object
  DescriptorSetVariableDescriptorCountLayoutSupportEXT* = object
  # KHR portability subset
  # ======================
  PhysicalDevicePortabilitySubsetFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePortabilitySubsetFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    constantAlphaColorBlendFactors*: Bool32
    events*: Bool32
    imageViewFormatReinterpretation*: Bool32
    imageViewFormatSwizzle*: Bool32
    imageView2DOn3DImage*: Bool32
    multisampleArrayImage*: Bool32
    mutableComparisonSamplers*: Bool32
    pointPolygons*: Bool32
    samplerMipLodBias*: Bool32
    separateStencilMaskRef*: Bool32
    shaderSampleRateInterpolationFunctions*: Bool32
    tessellationIsolines*: Bool32
    tessellationPointMode*: Bool32
    triangleFans*: Bool32
    vertexAttributeAccessBeyondStride*: Bool32
  PhysicalDevicePortabilitySubsetPropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePortabilitySubsetPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    minVertexInputBindingStrideAlignment*: uint32
  # NV shading rate image
  # =====================
  ShadingRatePaletteNV* = object
    shadingRatePaletteEntryCount*: uint32
    pShadingRatePaletteEntries* {.length: shadingRatePaletteEntryCount.}: arrPtr[ShadingRatePaletteEntryNV]
  PipelineViewportShadingRateImageStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineViewportShadingRateImageStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    shadingRateImageEnable*: Bool32
    viewportCount* {.optional.}: uint32
    pShadingRatePalettes* {.length: viewportCount.}: arrPtr[ShadingRatePaletteNV]
  PhysicalDeviceShadingRateImageFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceShadingRateImageFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    shadingRateImage*: Bool32
    shadingRateCoarseSampleOrder*: Bool32
  PhysicalDeviceShadingRateImagePropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceShadingRateImagePropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    shadingRateTexelSize*: Extent2D
    shadingRatePaletteSize*: uint32
    shadingRateMaxCoarseSamples*: uint32
  CoarseSampleLocationNV* = object
    pixelX*: uint32
    pixelY*: uint32
    sample*: uint32
  CoarseSampleOrderCustomNV* = object
    shadingRate*: ShadingRatePaletteEntryNV
    sampleCount*: uint32
    sampleLocationCount*: uint32
    pSampleLocations* {.length: sampleLocationCount.}: arrPtr[CoarseSampleLocationNV]
  PipelineViewportCoarseSampleOrderStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineViewportCoarseSampleOrderStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    sampleOrderType*: CoarseSampleOrderTypeNV
    customSampleOrderCount* {.optional.}: uint32
    pCustomSampleOrders* {.length: customSampleOrderCount.}: arrPtr[CoarseSampleOrderCustomNV]
  # NV ray tracing
  # ==============
  RayTracingShaderGroupCreateInfoNV* = object
    sType* {.constant: (StructureType.rayTracingShaderGroupCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    theType*: RayTracingShaderGroupTypeKHR
    generalShader*: uint32
    closestHitShader*: uint32
    anyHitShader*: uint32
    intersectionShader*: uint32
  RayTracingPipelineCreateInfoNV* = object
    sType* {.constant: (StructureType.rayTracingPipelineCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCreateFlags # Pipeline creation flags
    stageCount*: uint32
    pStages* {.length: stageCount.}: arrPtr[PipelineShaderStageCreateInfo] # One entry for each active shader stage
    groupCount*: uint32
    pGroups* {.length: groupCount.}: arrPtr[RayTracingShaderGroupCreateInfoNV]
    maxRecursionDepth*: uint32
    layout*: PipelineLayout # Interface layout of the pipeline
    basePipelineHandle* {.optional.}: Pipeline # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex*: int32 # If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  GeometryTrianglesNV* = object
    sType* {.constant: (StructureType.geometryTrianglesNv).}: StructureType
    pNext* {.optional.}: pointer
    vertexData* {.optional.}: Buffer
    vertexOffset*: DeviceSize
    vertexCount*: uint32
    vertexStride*: DeviceSize
    vertexFormat*: Format
    indexData* {.optional.}: Buffer
    indexOffset*: DeviceSize
    indexCount*: uint32
    indexType*: IndexType
    transformData* {.optional.}: Buffer # Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
    transformOffset*: DeviceSize
  GeometryAABBNV* = object
    sType* {.constant: (StructureType.geometryAabbNv).}: StructureType
    pNext* {.optional.}: pointer
    aabbData* {.optional.}: Buffer
    numAABBs*: uint32
    stride*: uint32 # Stride in bytes between AABBs
    offset*: DeviceSize # Offset in bytes of the first AABB in aabbData
  GeometryDataNV* = object
    triangles*: GeometryTrianglesNV
    aabbs*: GeometryAABBNV
  GeometryNV* = object
    sType* {.constant: (StructureType.geometryNv).}: StructureType
    pNext* {.optional.}: pointer
    geometryType*: GeometryTypeKHR
    geometry*: GeometryDataNV
    flags* {.optional.}: GeometryFlagsKHR
  AccelerationStructureInfoNV* = object
    sType* {.constant: (StructureType.accelerationStructureInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    theType*: AccelerationStructureTypeNV
    flags* {.optional.}: BuildAccelerationStructureFlagsNV
    instanceCount* {.optional.}: uint32
    geometryCount* {.optional.}: uint32
    pGeometries* {.length: geometryCount.}: arrPtr[GeometryNV]
  AccelerationStructureCreateInfoNV* = object
    sType* {.constant: (StructureType.accelerationStructureCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    compactedSize*: DeviceSize
    info*: AccelerationStructureInfoNV
  BindAccelerationStructureMemoryInfoNV* = object
    sType* {.constant: (StructureType.bindAccelerationStructureMemoryInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructure*: AccelerationStructureNV
    memory*: DeviceMemory
    memoryOffset*: DeviceSize
    deviceIndexCount* {.optional.}: uint32
    pDeviceIndices* {.length: deviceIndexCount.}: arrPtr[uint32]
  WriteDescriptorSetAccelerationStructureNV* = object
    sType* {.constant: (StructureType.writeDescriptorSetAccelerationStructureNv).}: StructureType
    pNext* {.optional.}: pointer
    accelerationStructureCount*: uint32
    pAccelerationStructures* {.length: accelerationStructureCount.}: arrPtr[AccelerationStructureNV]
  AccelerationStructureMemoryRequirementsInfoNV* = object
    sType* {.constant: (StructureType.accelerationStructureMemoryRequirementsInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    theType*: AccelerationStructureMemoryRequirementsTypeNV
    accelerationStructure*: AccelerationStructureNV
  PhysicalDeviceRayTracingPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceRayTracingPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    shaderGroupHandleSize*: uint32
    maxRecursionDepth*: uint32
    maxShaderGroupStride*: uint32
    shaderGroupBaseAlignment*: uint32
    maxGeometryCount*: uint64
    maxInstanceCount*: uint64
    maxTriangleCount*: uint64
    maxDescriptorSetAccelerationStructures*: uint32
  TransformMatrixNV* = object
  AabbPositionsNV* = object
  AccelerationStructureInstanceNV* = object
  # NV representative fragment test
  # ===============================
  PhysicalDeviceRepresentativeFragmentTestFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceRepresentativeFragmentTestFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    representativeFragmentTest*: Bool32
  PipelineRepresentativeFragmentTestStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineRepresentativeFragmentTestStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    representativeFragmentTestEnable*: Bool32
  # KHR maintenance3
  # ================
  PhysicalDeviceMaintenance3PropertiesKHR* = object
  DescriptorSetLayoutSupportKHR* = object
  # EXT filter cubic
  # ================
  PhysicalDeviceImageViewImageFormatInfoEXT* = object
    sType* {.constant: (StructureType.physicalDeviceImageViewImageFormatInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    imageViewType*: ImageViewType
  FilterCubicImageViewImageFormatPropertiesEXT* = object
    sType* {.constant: (StructureType.filterCubicImageViewImageFormatPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    filterCubic*: Bool32 # The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
    filterCubicMinmax*: Bool32 # The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
  # EXT global priority
  # ===================
  DeviceQueueGlobalPriorityCreateInfoEXT* = object
    sType* {.constant: (StructureType.deviceQueueGlobalPriorityCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    globalPriority*: QueueGlobalPriorityEXT
  # KHR shader subgroup extended types
  # ==================================
  PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR* = object
  # KHR 8bit storage
  # ================
  PhysicalDevice8BitStorageFeaturesKHR* = object
  # EXT external memory host
  # ========================
  ImportMemoryHostPointerInfoEXT* = object
    sType* {.constant: (StructureType.importMemoryHostPointerInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    handleType*: ExternalMemoryHandleTypeFlagBits
    pHostPointer*: pointer
  MemoryHostPointerPropertiesEXT* = object
    sType* {.constant: (StructureType.memoryHostPointerPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    memoryTypeBits*: uint32
  PhysicalDeviceExternalMemoryHostPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceExternalMemoryHostPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    minImportedHostPointerAlignment*: DeviceSize
  # KHR shader atomic int64
  # =======================
  PhysicalDeviceShaderAtomicInt64FeaturesKHR* = object
  # KHR shader clock
  # ================
  PhysicalDeviceShaderClockFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceShaderClockFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderSubgroupClock*: Bool32
    shaderDeviceClock*: Bool32
  # AMD pipeline compiler control
  # =============================
  PipelineCompilerControlCreateInfoAMD* = object
    sType* {.constant: (StructureType.pipelineCompilerControlCreateInfoAmd).}: StructureType
    pNext* {.optional.}: pointer
    compilerControlFlags* {.optional.}: PipelineCompilerControlFlagsAMD
  # EXT calibrated timestamps
  # =========================
  CalibratedTimestampInfoEXT* = object
    sType* {.constant: (StructureType.calibratedTimestampInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    timeDomain*: TimeDomainEXT
  # AMD shader core properties
  # ==========================
  PhysicalDeviceShaderCorePropertiesAMD* = object
    sType* {.constant: (StructureType.physicalDeviceShaderCorePropertiesAmd).}: StructureType
    pNext* {.optional.}: pointer
    shaderEngineCount*: uint32 # number of shader engines
    shaderArraysPerEngineCount*: uint32 # number of shader arrays
    computeUnitsPerShaderArray*: uint32 # number of physical CUs per shader array
    simdPerComputeUnit*: uint32 # number of SIMDs per compute unit
    wavefrontsPerSimd*: uint32 # number of wavefront slots in each SIMD
    wavefrontSize*: uint32 # maximum number of threads per wavefront
    sgprsPerSimd*: uint32 # number of physical SGPRs per SIMD
    minSgprAllocation*: uint32 # minimum number of SGPRs that can be allocated by a wave
    maxSgprAllocation*: uint32 # number of available SGPRs
    sgprAllocationGranularity*: uint32 # SGPRs are allocated in groups of this size
    vgprsPerSimd*: uint32 # number of physical VGPRs per SIMD
    minVgprAllocation*: uint32 # minimum number of VGPRs that can be allocated by a wave
    maxVgprAllocation*: uint32 # number of available VGPRs
    vgprAllocationGranularity*: uint32 # VGPRs are allocated in groups of this size
  # EXT video decode h265
  # =====================
  VideoDecodeH265ProfileEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265ProfileExt).}: StructureType
    pNext* {.optional.}: pointer
    stdProfileIdc*: StdVideoH265ProfileIdc
  VideoDecodeH265CapabilitiesEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265CapabilitiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxLevel*: uint32
    stdExtensionVersion*: ExtensionProperties
  VideoDecodeH265SessionCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265SessionCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoDecodeH265CreateFlagsEXT
    pStdExtensionVersion*: ptr ExtensionProperties
  VideoDecodeH265SessionParametersCreateInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265SessionParametersCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    maxSpsStdCount*: uint32
    maxPpsStdCount*: uint32
    pParametersAddInfo* {.optional.}: ptr VideoDecodeH265SessionParametersAddInfoEXT
  VideoDecodeH265SessionParametersAddInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265SessionParametersAddInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    spsStdCount*: uint32
    pSpsStd* {.optional, length: spsStdCount.}: arrPtr[StdVideoH265SequenceParameterSet]
    ppsStdCount*: uint32
    pPpsStd* {.optional, length: ppsStdCount.}: arrPtr[StdVideoH265PictureParameterSet] # List of Picture Parameters associated with the spsStd, above
  VideoDecodeH265PictureInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265PictureInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pStdPictureInfo*: ptr StdVideoDecodeH265PictureInfo
    slicesCount*: uint32
    pSlicesDataOffsets* {.length: slicesCount.}: arrPtr[uint32]
  VideoDecodeH265DpbSlotInfoEXT* = object
    sType* {.constant: (StructureType.videoDecodeH265DpbSlotInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pStdReferenceInfo*: ptr StdVideoDecodeH265ReferenceInfo
  # AMD memory overallocation behavior
  # ==================================
  DeviceMemoryOverallocationCreateInfoAMD* = object
    sType* {.constant: (StructureType.deviceMemoryOverallocationCreateInfoAmd).}: StructureType
    pNext* {.optional.}: pointer
    overallocationBehavior*: MemoryOverallocationBehaviorAMD
  # EXT vertex attribute divisor
  # ============================
  PhysicalDeviceVertexAttributeDivisorPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceVertexAttributeDivisorPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxVertexAttribDivisor*: uint32 # max value of vertex attribute divisor
  VertexInputBindingDivisorDescriptionEXT* = object
    binding*: uint32
    divisor*: uint32
  PipelineVertexInputDivisorStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineVertexInputDivisorStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    vertexBindingDivisorCount*: uint32
    pVertexBindingDivisors* {.length: vertexBindingDivisorCount.}: arrPtr[VertexInputBindingDivisorDescriptionEXT]
  PhysicalDeviceVertexAttributeDivisorFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceVertexAttributeDivisorFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    vertexAttributeInstanceRateDivisor*: Bool32
    vertexAttributeInstanceRateZeroDivisor*: Bool32
  # GGP frame token
  # ===============
  PresentFrameTokenGGP* = object
    sType* {.constant: (StructureType.presentFrameTokenGgp).}: StructureType
    pNext* {.optional.}: pointer
    frameToken*: GgpFrameToken
  # EXT pipeline creation feedback
  # ==============================
  PipelineCreationFeedbackCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineCreationFeedbackCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    pPipelineCreationFeedback*: ptr PipelineCreationFeedbackEXT # Output pipeline creation feedback.
    pipelineStageCreationFeedbackCount*: uint32
    pPipelineStageCreationFeedbacks* {.length: pipelineStageCreationFeedbackCount.}: arrPtr[arrPtr[PipelineCreationFeedbackEXT]] # One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
  PipelineCreationFeedbackEXT* = object
    flags*: PipelineCreationFeedbackFlagsEXT
    duration*: uint64
  # KHR driver properties
  # =====================
  ConformanceVersionKHR* = object
  PhysicalDeviceDriverPropertiesKHR* = object
  # KHR shader float controls
  # =========================
  PhysicalDeviceFloatControlsPropertiesKHR* = object
  # KHR depth stencil resolve
  # =========================
  SubpassDescriptionDepthStencilResolveKHR* = object
  PhysicalDeviceDepthStencilResolvePropertiesKHR* = object
  # NV compute shader derivatives
  # =============================
  PhysicalDeviceComputeShaderDerivativesFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceComputeShaderDerivativesFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    computeDerivativeGroupQuads*: Bool32
    computeDerivativeGroupLinear*: Bool32
  # NV mesh shader
  # ==============
  PhysicalDeviceMeshShaderFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceMeshShaderFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    taskShader*: Bool32
    meshShader*: Bool32
  PhysicalDeviceMeshShaderPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceMeshShaderPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    maxDrawMeshTasksCount*: uint32
    maxTaskWorkGroupInvocations*: uint32
    maxTaskWorkGroupSize*: array[3, uint32]
    maxTaskTotalMemorySize*: uint32
    maxTaskOutputCount*: uint32
    maxMeshWorkGroupInvocations*: uint32
    maxMeshWorkGroupSize*: array[3, uint32]
    maxMeshTotalMemorySize*: uint32
    maxMeshOutputVertices*: uint32
    maxMeshOutputPrimitives*: uint32
    maxMeshMultiviewViewCount*: uint32
    meshOutputPerVertexGranularity*: uint32
    meshOutputPerPrimitiveGranularity*: uint32
  DrawMeshTasksIndirectCommandNV* = object
    taskCount*: uint32
    firstTask*: uint32
  # NV fragment shader barycentric
  # ==============================
  PhysicalDeviceFragmentShaderBarycentricFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShaderBarycentricFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    fragmentShaderBarycentric*: Bool32
  # NV shader image footprint
  # =========================
  PhysicalDeviceShaderImageFootprintFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceShaderImageFootprintFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    imageFootprint*: Bool32
  # NV scissor exclusive
  # ====================
  PipelineViewportExclusiveScissorStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineViewportExclusiveScissorStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    exclusiveScissorCount* {.optional.}: uint32
    pExclusiveScissors* {.length: exclusiveScissorCount.}: arrPtr[Rect2D]
  PhysicalDeviceExclusiveScissorFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceExclusiveScissorFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    exclusiveScissor*: Bool32
  # NV device diagnostic checkpoints
  # ================================
  QueueFamilyCheckpointPropertiesNV* = object
    sType* {.constant: (StructureType.queueFamilyCheckpointPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    checkpointExecutionStageMask*: PipelineStageFlags
  CheckpointDataNV* = object
    sType* {.constant: (StructureType.checkpointDataNv).}: StructureType
    pNext* {.optional.}: pointer
    stage*: PipelineStageFlagBits
    pCheckpointMarker*: pointer
  # KHR timeline semaphore
  # ======================
  PhysicalDeviceTimelineSemaphoreFeaturesKHR* = object
  PhysicalDeviceTimelineSemaphorePropertiesKHR* = object
  SemaphoreTypeCreateInfoKHR* = object
  TimelineSemaphoreSubmitInfoKHR* = object
  SemaphoreWaitInfoKHR* = object
  SemaphoreSignalInfoKHR* = object
  # INTEL shader integer functions2
  # ===============================
  PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* = object
    sType* {.constant: (StructureType.physicalDeviceShaderIntegerFunctions2FeaturesIntel).}: StructureType
    pNext* {.optional.}: pointer
    shaderIntegerFunctions2*: Bool32
  # INTEL performance query
  # =======================
  PerformanceValueDataINTEL* {.union.} = object
    value32*: uint32
    value64*: uint64
    valueFloat*: float32
    valueBool*: Bool32
    valueString*: cstring
  PerformanceValueINTEL* = object
    theType*: PerformanceValueTypeINTEL
    data*: PerformanceValueDataINTEL
  InitializePerformanceApiInfoINTEL* = object
    sType* {.constant: (StructureType.initializePerformanceApiInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    pUserData* {.optional.}: pointer
  QueryPoolCreateInfoINTEL* = object
  QueryPoolPerformanceQueryCreateInfoINTEL* = object
    sType* {.constant: (StructureType.queryPoolPerformanceQueryCreateInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    performanceCountersSampling*: QueryPoolSamplingModeINTEL
  PerformanceMarkerInfoINTEL* = object
    sType* {.constant: (StructureType.performanceMarkerInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    marker*: uint64
  PerformanceStreamMarkerInfoINTEL* = object
    sType* {.constant: (StructureType.performanceStreamMarkerInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    marker*: uint32
  PerformanceOverrideInfoINTEL* = object
    sType* {.constant: (StructureType.performanceOverrideInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    theType*: PerformanceOverrideTypeINTEL
    enable*: Bool32
    parameter*: uint64
  PerformanceConfigurationAcquireInfoINTEL* = object
    sType* {.constant: (StructureType.performanceConfigurationAcquireInfoIntel).}: StructureType
    pNext* {.optional.}: pointer
    theType*: PerformanceConfigurationTypeINTEL
  # KHR vulkan memory model
  # =======================
  PhysicalDeviceVulkanMemoryModelFeaturesKHR* = object
  # EXT pci bus info
  # ================
  PhysicalDevicePCIBusInfoPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDevicePciBusInfoPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    pciDomain*: uint32
    pciBus*: uint32
    pciDevice*: uint32
    pciFunction*: uint32
  # AMD display native hdr
  # ======================
  DisplayNativeHdrSurfaceCapabilitiesAMD* = object
    sType* {.constant: (StructureType.displayNativeHdrSurfaceCapabilitiesAmd).}: StructureType
    pNext* {.optional.}: pointer
    localDimmingSupport*: Bool32
  SwapchainDisplayNativeHdrCreateInfoAMD* = object
    sType* {.constant: (StructureType.swapchainDisplayNativeHdrCreateInfoAmd).}: StructureType
    pNext* {.optional.}: pointer
    localDimmingEnable*: Bool32
  # FUCHSIA imagepipe surface
  # =========================
  ImagePipeSurfaceCreateInfoFUCHSIA* = object
    sType* {.constant: (StructureType.imagepipeSurfaceCreateInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ImagePipeSurfaceCreateFlagsFUCHSIA
    imagePipeHandle*: zx_handle_t
  # KHR shader terminate invocation
  # ===============================
  PhysicalDeviceShaderTerminateInvocationFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceShaderTerminateInvocationFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderTerminateInvocation*: Bool32
  # EXT metal surface
  # =================
  MetalSurfaceCreateInfoEXT* = object
    sType* {.constant: (StructureType.metalSurfaceCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: MetalSurfaceCreateFlagsEXT
    pLayer*: ptr CAMetalLayer
  # EXT fragment density map
  # ========================
  PhysicalDeviceFragmentDensityMapFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMapFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityMap*: Bool32
    fragmentDensityMapDynamic*: Bool32
    fragmentDensityMapNonSubsampledImages*: Bool32
  PhysicalDeviceFragmentDensityMapPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMapPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    minFragmentDensityTexelSize*: Extent2D
    maxFragmentDensityTexelSize*: Extent2D
    fragmentDensityInvocations*: Bool32
  RenderPassFragmentDensityMapCreateInfoEXT* = object
    sType* {.constant: (StructureType.renderPassFragmentDensityMapCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityMapAttachment*: AttachmentReference
  # EXT scalar block layout
  # =======================
  PhysicalDeviceScalarBlockLayoutFeaturesEXT* = object
  # EXT subgroup size control
  # =========================
  PhysicalDeviceSubgroupSizeControlFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceSubgroupSizeControlFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    subgroupSizeControl*: Bool32
    computeFullSubgroups*: Bool32
  PhysicalDeviceSubgroupSizeControlPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceSubgroupSizeControlPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    minSubgroupSize*: uint32 # The minimum subgroup size supported by this device
    maxSubgroupSize*: uint32 # The maximum subgroup size supported by this device
    maxComputeWorkgroupSubgroups*: uint32 # The maximum number of subgroups supported in a workgroup
    requiredSubgroupSizeStages*: ShaderStageFlags # The shader stages that support specifying a subgroup size
  PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineShaderStageRequiredSubgroupSizeCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    requiredSubgroupSize*: uint32
  # KHR fragment shading rate
  # =========================
  FragmentShadingRateAttachmentInfoKHR* = object
    sType* {.constant: (StructureType.fragmentShadingRateAttachmentInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pFragmentShadingRateAttachment* {.optional.}: ptr AttachmentReference2
    shadingRateAttachmentTexelSize*: Extent2D
  PipelineFragmentShadingRateStateCreateInfoKHR* = object
    sType* {.constant: (StructureType.pipelineFragmentShadingRateStateCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    fragmentSize*: Extent2D
    combinerOps*: array[2, FragmentShadingRateCombinerOpKHR]
  PhysicalDeviceFragmentShadingRateFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShadingRateFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    pipelineFragmentShadingRate*: Bool32
    primitiveFragmentShadingRate*: Bool32
    attachmentFragmentShadingRate*: Bool32
  PhysicalDeviceFragmentShadingRatePropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShadingRatePropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    minFragmentShadingRateAttachmentTexelSize*: Extent2D
    maxFragmentShadingRateAttachmentTexelSize*: Extent2D
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio*: uint32
    primitiveFragmentShadingRateWithMultipleViewports*: Bool32
    layeredShadingRateAttachments*: Bool32
    fragmentShadingRateNonTrivialCombinerOps*: Bool32
    maxFragmentSize*: Extent2D
    maxFragmentSizeAspectRatio*: uint32
    maxFragmentShadingRateCoverageSamples*: uint32
    maxFragmentShadingRateRasterizationSamples*: SampleCountFlagBits
    fragmentShadingRateWithShaderDepthStencilWrites*: Bool32
    fragmentShadingRateWithSampleMask*: Bool32
    fragmentShadingRateWithShaderSampleMask*: Bool32
    fragmentShadingRateWithConservativeRasterization*: Bool32
    fragmentShadingRateWithFragmentShaderInterlock*: Bool32
    fragmentShadingRateWithCustomSampleLocations*: Bool32
    fragmentShadingRateStrictMultiplyCombiner*: Bool32
  PhysicalDeviceFragmentShadingRateKHR* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShadingRateKhr).}: StructureType
    pNext* {.optional.}: pointer
    sampleCounts*: SampleCountFlags
    fragmentSize*: Extent2D
  # AMD shader core properties2
  # ===========================
  PhysicalDeviceShaderCoreProperties2AMD* = object
    sType* {.constant: (StructureType.physicalDeviceShaderCoreProperties2Amd).}: StructureType
    pNext* {.optional.}: pointer # Pointer to next structure
    shaderCoreFeatures*: ShaderCorePropertiesFlagsAMD # features supported by the shader core
    activeComputeUnitCount*: uint32 # number of active compute units across all shader engines/arrays
  # AMD device coherent memory
  # ==========================
  PhysicalDeviceCoherentMemoryFeaturesAMD* = object
    sType* {.constant: (StructureType.physicalDeviceCoherentMemoryFeaturesAmd).}: StructureType
    pNext* {.optional.}: pointer
    deviceCoherentMemory*: Bool32
  # EXT shader image atomic int64
  # =============================
  PhysicalDeviceShaderImageAtomicInt64FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceShaderImageAtomicInt64FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    shaderImageInt64Atomics*: Bool32
    sparseImageInt64Atomics*: Bool32
  # EXT memory budget
  # =================
  PhysicalDeviceMemoryBudgetPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceMemoryBudgetPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    heapBudget*: array[MaxMemoryHeaps, DeviceSize]
    heapUsage*: array[MaxMemoryHeaps, DeviceSize]
  # EXT memory priority
  # ===================
  PhysicalDeviceMemoryPriorityFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceMemoryPriorityFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    memoryPriority*: Bool32
  MemoryPriorityAllocateInfoEXT* = object
    sType* {.constant: (StructureType.memoryPriorityAllocateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    priority*: float32
  # KHR surface protected capabilities
  # ==================================
  SurfaceProtectedCapabilitiesKHR* = object
    sType* {.constant: (StructureType.surfaceProtectedCapabilitiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    supportsProtected*: Bool32 # Represents if surface can be protected
  # NV dedicated allocation image aliasing
  # ======================================
  PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceDedicatedAllocationImageAliasingFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    dedicatedAllocationImageAliasing*: Bool32
  # KHR separate depth stencil layouts
  # ==================================
  PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR* = object
  AttachmentReferenceStencilLayoutKHR* = object
  AttachmentDescriptionStencilLayoutKHR* = object
  # EXT buffer device address
  # =========================
  PhysicalDeviceBufferAddressFeaturesEXT* = object
  PhysicalDeviceBufferDeviceAddressFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceBufferDeviceAddressFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    bufferDeviceAddress*: Bool32
    bufferDeviceAddressCaptureReplay*: Bool32
    bufferDeviceAddressMultiDevice*: Bool32
  BufferDeviceAddressInfoEXT* = object
  BufferDeviceAddressCreateInfoEXT* = object
    sType* {.constant: (StructureType.bufferDeviceAddressCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    deviceAddress*: DeviceAddress
  # EXT tooling info
  # ================
  PhysicalDeviceToolPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceToolPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    name*: array[MaxExtensionNameSize, char]
    version*: array[MaxExtensionNameSize, char]
    purposes*: ToolPurposeFlagsEXT
    description*: array[MaxDescriptionSize, char]
    layer*: array[MaxExtensionNameSize, char]
  # EXT separate stencil usage
  # ==========================
  ImageStencilUsageCreateInfoEXT* = object
  # EXT validation features
  # =======================
  ValidationFeaturesEXT* = object
    sType* {.constant: (StructureType.validationFeaturesExt).}: StructureType # Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
    pNext* {.optional.}: pointer
    enabledValidationFeatureCount* {.optional.}: uint32 # Number of validation features to enable
    pEnabledValidationFeatures* {.length: enabledValidationFeatureCount.}: arrPtr[ValidationFeatureEnableEXT] # Validation features to enable
    disabledValidationFeatureCount* {.optional.}: uint32 # Number of validation features to disable
    pDisabledValidationFeatures* {.length: disabledValidationFeatureCount.}: arrPtr[ValidationFeatureDisableEXT] # Validation features to disable
  # KHR present wait
  # ================
  PhysicalDevicePresentWaitFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePresentWaitFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    presentWait*: Bool32 # vkWaitForPresentKHR is supported
  # NV cooperative matrix
  # =====================
  CooperativeMatrixPropertiesNV* = object
    sType* {.constant: (StructureType.cooperativeMatrixPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    MSize*: uint32
    NSize*: uint32
    KSize*: uint32
    AType*: ComponentTypeNV
    BType*: ComponentTypeNV
    CType*: ComponentTypeNV
    DType*: ComponentTypeNV
    scope*: ScopeNV
  PhysicalDeviceCooperativeMatrixFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceCooperativeMatrixFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    cooperativeMatrix*: Bool32
    cooperativeMatrixRobustBufferAccess*: Bool32
  PhysicalDeviceCooperativeMatrixPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceCooperativeMatrixPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    cooperativeMatrixSupportedStages*: ShaderStageFlags
  # NV coverage reduction mode
  # ==========================
  PhysicalDeviceCoverageReductionModeFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceCoverageReductionModeFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    coverageReductionMode*: Bool32
  PipelineCoverageReductionStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineCoverageReductionStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: PipelineCoverageReductionStateCreateFlagsNV
    coverageReductionMode*: CoverageReductionModeNV
  FramebufferMixedSamplesCombinationNV* = object
    sType* {.constant: (StructureType.framebufferMixedSamplesCombinationNv).}: StructureType
    pNext* {.optional.}: pointer
    coverageReductionMode*: CoverageReductionModeNV
    rasterizationSamples*: SampleCountFlagBits
    depthStencilSamples*: SampleCountFlags
    colorSamples*: SampleCountFlags
  # EXT fragment shader interlock
  # =============================
  PhysicalDeviceFragmentShaderInterlockFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShaderInterlockFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer # Pointer to next structure
    fragmentShaderSampleInterlock*: Bool32
    fragmentShaderPixelInterlock*: Bool32
    fragmentShaderShadingRateInterlock*: Bool32
  # EXT ycbcr image arrays
  # ======================
  PhysicalDeviceYcbcrImageArraysFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceYcbcrImageArraysFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    ycbcrImageArrays*: Bool32
  # KHR uniform buffer standard layout
  # ==================================
  PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR* = object
  # EXT provoking vertex
  # ====================
  PhysicalDeviceProvokingVertexFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceProvokingVertexFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    provokingVertexLast*: Bool32
    transformFeedbackPreservesProvokingVertex*: Bool32
  PhysicalDeviceProvokingVertexPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceProvokingVertexPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    provokingVertexModePerPipeline*: Bool32
    transformFeedbackPreservesTriangleFanProvokingVertex*: Bool32
  PipelineRasterizationProvokingVertexStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineRasterizationProvokingVertexStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    provokingVertexMode*: ProvokingVertexModeEXT
  # EXT full screen exclusive
  # =========================
  SurfaceFullScreenExclusiveInfoEXT* = object
    sType* {.constant: (StructureType.surfaceFullScreenExclusiveInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    fullScreenExclusive*: FullScreenExclusiveEXT
  SurfaceCapabilitiesFullScreenExclusiveEXT* = object
    sType* {.constant: (StructureType.surfaceCapabilitiesFullScreenExclusiveExt).}: StructureType
    pNext* {.optional.}: pointer
    fullScreenExclusiveSupported*: Bool32
  SurfaceFullScreenExclusiveWin32InfoEXT* = object
    sType* {.constant: (StructureType.surfaceFullScreenExclusiveWin32InfoExt).}: StructureType
    pNext* {.optional.}: pointer
    hmonitor*: HMONITOR
  # EXT headless surface
  # ====================
  HeadlessSurfaceCreateInfoEXT* = object
    sType* {.constant: (StructureType.headlessSurfaceCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: HeadlessSurfaceCreateFlagsEXT
  # KHR buffer device address
  # =========================
  PhysicalDeviceBufferDeviceAddressFeaturesKHR* = object
  BufferDeviceAddressInfoKHR* = object
  BufferOpaqueCaptureAddressCreateInfoKHR* = object
  MemoryOpaqueCaptureAddressAllocateInfoKHR* = object
  DeviceMemoryOpaqueCaptureAddressInfoKHR* = object
  # EXT line rasterization
  # ======================
  PhysicalDeviceLineRasterizationFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceLineRasterizationFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    rectangularLines*: Bool32
    bresenhamLines*: Bool32
    smoothLines*: Bool32
    stippledRectangularLines*: Bool32
    stippledBresenhamLines*: Bool32
    stippledSmoothLines*: Bool32
  PhysicalDeviceLineRasterizationPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceLineRasterizationPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    lineSubPixelPrecisionBits*: uint32
  PipelineRasterizationLineStateCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineRasterizationLineStateCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    lineRasterizationMode*: LineRasterizationModeEXT
    stippledLineEnable*: Bool32
    lineStippleFactor*: uint32
    lineStipplePattern*: uint16
  # EXT shader atomic float
  # =======================
  PhysicalDeviceShaderAtomicFloatFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceShaderAtomicFloatFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    shaderBufferFloat32Atomics*: Bool32
    shaderBufferFloat32AtomicAdd*: Bool32
    shaderBufferFloat64Atomics*: Bool32
    shaderBufferFloat64AtomicAdd*: Bool32
    shaderSharedFloat32Atomics*: Bool32
    shaderSharedFloat32AtomicAdd*: Bool32
    shaderSharedFloat64Atomics*: Bool32
    shaderSharedFloat64AtomicAdd*: Bool32
    shaderImageFloat32Atomics*: Bool32
    shaderImageFloat32AtomicAdd*: Bool32
    sparseImageFloat32Atomics*: Bool32
    sparseImageFloat32AtomicAdd*: Bool32
  # EXT host query reset
  # ====================
  PhysicalDeviceHostQueryResetFeaturesEXT* = object
  # EXT index type uint8
  # ====================
  PhysicalDeviceIndexTypeUint8FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceIndexTypeUint8FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    indexTypeUint8*: Bool32
  # EXT extended dynamic state
  # ==========================
  PhysicalDeviceExtendedDynamicStateFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceExtendedDynamicStateFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    extendedDynamicState*: Bool32
  # KHR pipeline executable properties
  # ==================================
  PhysicalDevicePipelineExecutablePropertiesFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePipelineExecutablePropertiesFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    pipelineExecutableInfo*: Bool32
  PipelineInfoKHR* = object
    sType* {.constant: (StructureType.pipelineInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pipeline*: Pipeline
  PipelineExecutablePropertiesKHR* = object
    sType* {.constant: (StructureType.pipelineExecutablePropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    stages*: ShaderStageFlags
    name*: array[MaxDescriptionSize, char]
    description*: array[MaxDescriptionSize, char]
    subgroupSize*: uint32
  PipelineExecutableInfoKHR* = object
    sType* {.constant: (StructureType.pipelineExecutableInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    pipeline*: Pipeline
    executableIndex*: uint32
  PipelineExecutableStatisticValueKHR* {.union.} = object
    b32*: Bool32
    i64*: int64
    u64*: uint64
    f64*: float64
  PipelineExecutableStatisticKHR* = object
    sType* {.constant: (StructureType.pipelineExecutableStatisticKhr).}: StructureType
    pNext* {.optional.}: pointer
    name*: array[MaxDescriptionSize, char]
    description*: array[MaxDescriptionSize, char]
    format*: PipelineExecutableStatisticFormatKHR
    value*: PipelineExecutableStatisticValueKHR
  PipelineExecutableInternalRepresentationKHR* = object
    sType* {.constant: (StructureType.pipelineExecutableInternalRepresentationKhr).}: StructureType
    pNext* {.optional.}: pointer
    name*: array[MaxDescriptionSize, char]
    description*: array[MaxDescriptionSize, char]
    isText*: Bool32
    dataSize*: uint
    pData* {.optional, length: dataSize.}: pointer
  # EXT shader atomic float2
  # ========================
  PhysicalDeviceShaderAtomicFloat2FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceShaderAtomicFloat2FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    shaderBufferFloat16Atomics*: Bool32
    shaderBufferFloat16AtomicAdd*: Bool32
    shaderBufferFloat16AtomicMinMax*: Bool32
    shaderBufferFloat32AtomicMinMax*: Bool32
    shaderBufferFloat64AtomicMinMax*: Bool32
    shaderSharedFloat16Atomics*: Bool32
    shaderSharedFloat16AtomicAdd*: Bool32
    shaderSharedFloat16AtomicMinMax*: Bool32
    shaderSharedFloat32AtomicMinMax*: Bool32
    shaderSharedFloat64AtomicMinMax*: Bool32
    shaderImageFloat32AtomicMinMax*: Bool32
    sparseImageFloat32AtomicMinMax*: Bool32
  # EXT shader demote to helper invocation
  # ======================================
  PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceShaderDemoteToHelperInvocationFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    shaderDemoteToHelperInvocation*: Bool32
  # NV device generated commands
  # ============================
  PhysicalDeviceDeviceGeneratedCommandsPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceDeviceGeneratedCommandsPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    maxGraphicsShaderGroupCount*: uint32
    maxIndirectSequenceCount*: uint32
    maxIndirectCommandsTokenCount*: uint32
    maxIndirectCommandsStreamCount*: uint32
    maxIndirectCommandsTokenOffset*: uint32
    maxIndirectCommandsStreamStride*: uint32
    minSequencesCountBufferOffsetAlignment*: uint32
    minSequencesIndexBufferOffsetAlignment*: uint32
    minIndirectCommandsBufferOffsetAlignment*: uint32
  PhysicalDeviceDeviceGeneratedCommandsFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceDeviceGeneratedCommandsFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    deviceGeneratedCommands*: Bool32
  GraphicsShaderGroupCreateInfoNV* = object
    sType* {.constant: (StructureType.graphicsShaderGroupCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    stageCount*: uint32
    pStages* {.length: stageCount.}: arrPtr[PipelineShaderStageCreateInfo]
    pVertexInputState* {.optional.}: ptr PipelineVertexInputStateCreateInfo
    pTessellationState* {.optional.}: ptr PipelineTessellationStateCreateInfo
  GraphicsPipelineShaderGroupsCreateInfoNV* = object
    sType* {.constant: (StructureType.graphicsPipelineShaderGroupsCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    groupCount*: uint32
    pGroups* {.length: groupCount.}: arrPtr[GraphicsShaderGroupCreateInfoNV]
    pipelineCount* {.optional.}: uint32
    pPipelines* {.length: pipelineCount.}: arrPtr[Pipeline]
  BindShaderGroupIndirectCommandNV* = object
    groupIndex*: uint32
  BindIndexBufferIndirectCommandNV* = object
    bufferAddress*: DeviceAddress
    size*: uint32
    indexType*: IndexType
  BindVertexBufferIndirectCommandNV* = object
    bufferAddress*: DeviceAddress
    size*: uint32
    stride*: uint32
  SetStateFlagsIndirectCommandNV* = object
    data*: uint32
  IndirectCommandsStreamNV* = object
    buffer*: Buffer
    offset*: DeviceSize
  IndirectCommandsLayoutTokenNV* = object
    sType* {.constant: (StructureType.indirectCommandsLayoutTokenNv).}: StructureType
    pNext* {.optional.}: pointer
    tokenType*: IndirectCommandsTokenTypeNV
    stream*: uint32
    offset*: uint32
    vertexBindingUnit*: uint32
    vertexDynamicStride*: Bool32
    pushconstantPipelineLayout* {.optional.}: PipelineLayout
    pushconstantShaderStageFlags* {.optional.}: ShaderStageFlags
    pushconstantOffset*: uint32
    pushconstantSize*: uint32
    indirectStateFlags* {.optional.}: IndirectStateFlagsNV
    indexTypeCount* {.optional.}: uint32
    pIndexTypes* {.length: indexTypeCount.}: arrPtr[IndexType]
    pIndexTypeValues* {.length: indexTypeCount.}: arrPtr[uint32]
  IndirectCommandsLayoutCreateInfoNV* = object
    sType* {.constant: (StructureType.indirectCommandsLayoutCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: IndirectCommandsLayoutUsageFlagsNV
    pipelineBindPoint*: PipelineBindPoint
    tokenCount*: uint32
    pTokens* {.length: tokenCount.}: arrPtr[IndirectCommandsLayoutTokenNV]
    streamCount*: uint32
    pStreamStrides* {.length: streamCount.}: arrPtr[uint32]
  GeneratedCommandsInfoNV* = object
    sType* {.constant: (StructureType.generatedCommandsInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    pipelineBindPoint*: PipelineBindPoint
    pipeline*: Pipeline
    indirectCommandsLayout*: IndirectCommandsLayoutNV
    streamCount*: uint32
    pStreams* {.length: streamCount.}: arrPtr[IndirectCommandsStreamNV]
    sequencesCount*: uint32
    preprocessBuffer*: Buffer
    preprocessOffset*: DeviceSize
    preprocessSize*: DeviceSize
    sequencesCountBuffer* {.optional.}: Buffer
    sequencesCountOffset*: DeviceSize
    sequencesIndexBuffer* {.optional.}: Buffer
    sequencesIndexOffset*: DeviceSize
  GeneratedCommandsMemoryRequirementsInfoNV* = object
    sType* {.constant: (StructureType.generatedCommandsMemoryRequirementsInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    pipelineBindPoint*: PipelineBindPoint
    pipeline*: Pipeline
    indirectCommandsLayout*: IndirectCommandsLayoutNV
    maxSequencesCount*: uint32
  # NV inherited viewport scissor
  # =============================
  PhysicalDeviceInheritedViewportScissorFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceInheritedViewportScissorFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    inheritedViewportScissor2D*: Bool32
  CommandBufferInheritanceViewportScissorInfoNV* = object
    sType* {.constant: (StructureType.commandBufferInheritanceViewportScissorInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    viewportScissor2D*: Bool32
    viewportDepthCount*: uint32
    pViewportDepths*: ptr Viewport
  # KHR shader integer dot product
  # ==============================
  PhysicalDeviceShaderIntegerDotProductFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceShaderIntegerDotProductFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderIntegerDotProduct*: Bool32
  PhysicalDeviceShaderIntegerDotProductPropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceShaderIntegerDotProductPropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    integerDotProduct8BitUnsignedAccelerated*: Bool32
    integerDotProduct8BitSignedAccelerated*: Bool32
    integerDotProduct8BitMixedSignednessAccelerated*: Bool32
    integerDotProduct4x8BitPackedUnsignedAccelerated*: Bool32
    integerDotProduct4x8BitPackedSignedAccelerated*: Bool32
    integerDotProduct4x8BitPackedMixedSignednessAccelerated*: Bool32
    integerDotProduct16BitUnsignedAccelerated*: Bool32
    integerDotProduct16BitSignedAccelerated*: Bool32
    integerDotProduct16BitMixedSignednessAccelerated*: Bool32
    integerDotProduct32BitUnsignedAccelerated*: Bool32
    integerDotProduct32BitSignedAccelerated*: Bool32
    integerDotProduct32BitMixedSignednessAccelerated*: Bool32
    integerDotProduct64BitUnsignedAccelerated*: Bool32
    integerDotProduct64BitSignedAccelerated*: Bool32
    integerDotProduct64BitMixedSignednessAccelerated*: Bool32
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating8BitSignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated*: Bool32
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated*: Bool32
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating16BitSignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated*: Bool32
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating32BitSignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated*: Bool32
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating64BitSignedAccelerated*: Bool32
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated*: Bool32
  # EXT texel buffer alignment
  # ==========================
  PhysicalDeviceTexelBufferAlignmentFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceTexelBufferAlignmentFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    texelBufferAlignment*: Bool32
  PhysicalDeviceTexelBufferAlignmentPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceTexelBufferAlignmentPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    storageTexelBufferOffsetAlignmentBytes*: DeviceSize
    storageTexelBufferOffsetSingleTexelAlignment*: Bool32
    uniformTexelBufferOffsetAlignmentBytes*: DeviceSize
    uniformTexelBufferOffsetSingleTexelAlignment*: Bool32
  # QCOM render pass transform
  # ==========================
  RenderPassTransformBeginInfoQCOM* = object
    sType* {.constant: (StructureType.renderPassTransformBeginInfoQcom).}: StructureType
    pNext* {.optional.}: pointer # Pointer to next structure
    transform*: SurfaceTransformFlagBitsKHR
  CommandBufferInheritanceRenderPassTransformInfoQCOM* = object
    sType* {.constant: (StructureType.commandBufferInheritanceRenderPassTransformInfoQcom).}: StructureType
    pNext* {.optional.}: pointer # Pointer to next structure
    transform*: SurfaceTransformFlagBitsKHR
    renderArea*: Rect2D
  # EXT device memory report
  # ========================
  PhysicalDeviceDeviceMemoryReportFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceDeviceMemoryReportFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    deviceMemoryReport*: Bool32
  DeviceDeviceMemoryReportCreateInfoEXT* = object
    sType* {.constant: (StructureType.deviceDeviceMemoryReportCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: DeviceMemoryReportFlagsEXT
    pfnUserCallback*: PFN_DeviceMemoryReportCallbackEXT
    pUserData*: pointer
  DeviceMemoryReportCallbackDataEXT* = object
    sType* {.constant: (StructureType.deviceMemoryReportCallbackDataExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: DeviceMemoryReportFlagsEXT
    theType*: DeviceMemoryReportEventTypeEXT
    memoryObjectId*: uint64
    size*: DeviceSize
    objectType*: ObjectType
    objectHandle*: uint64
    heapIndex*: uint32
  PFN_DeviceMemoryReportCallbackEXT* = proc(
      pCallbackData: ptr DeviceMemoryReportCallbackDataEXT;
      pUserData: pointer;
    ): void {.cdecl.}
  # EXT robustness2
  # ===============
  PhysicalDeviceRobustness2FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceRobustness2FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    robustBufferAccess2*: Bool32
    robustImageAccess2*: Bool32
    nullDescriptor*: Bool32
  PhysicalDeviceRobustness2PropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceRobustness2PropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    robustStorageBufferAccessSizeAlignment*: DeviceSize
    robustUniformBufferAccessSizeAlignment*: DeviceSize
  # EXT custom border color
  # =======================
  SamplerCustomBorderColorCreateInfoEXT* = object
    sType* {.constant: (StructureType.samplerCustomBorderColorCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    customBorderColor*: ClearColorValue
    format*: Format
  PhysicalDeviceCustomBorderColorPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceCustomBorderColorPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxCustomBorderColorSamplers*: uint32
  PhysicalDeviceCustomBorderColorFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceCustomBorderColorFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    customBorderColors*: Bool32
    customBorderColorWithoutFormat*: Bool32
  # KHR pipeline library
  # ====================
  PipelineLibraryCreateInfoKHR* = object
    sType* {.constant: (StructureType.pipelineLibraryCreateInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    libraryCount* {.optional.}: uint32
    pLibraries* {.length: libraryCount.}: arrPtr[Pipeline]
  # KHR present id
  # ==============
  PresentIdKHR* = object
    sType* {.constant: (StructureType.presentIdKhr).}: StructureType
    pNext* {.optional.}: pointer
    swapchainCount*: uint32 # Copy of VkPresentInfoKHR::swapchainCount
    pPresentIds* {.optional, length: swapchainCount.}: arrPtr[uint64] # Present ID values for each swapchain
  PhysicalDevicePresentIdFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDevicePresentIdFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    presentId*: Bool32 # Present ID in VkPresentInfoKHR
  # EXT private data
  # ================
  PhysicalDevicePrivateDataFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDevicePrivateDataFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    privateData*: Bool32
  DevicePrivateDataCreateInfoEXT* = object
    sType* {.constant: (StructureType.devicePrivateDataCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    privateDataSlotRequestCount*: uint32
  PrivateDataSlotCreateInfoEXT* = object
    sType* {.constant: (StructureType.privateDataSlotCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags*: PrivateDataSlotCreateFlagsEXT
  # EXT pipeline creation cache control
  # ===================================
  PhysicalDevicePipelineCreationCacheControlFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDevicePipelineCreationCacheControlFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    pipelineCreationCacheControl*: Bool32
  # KHR video encode queue
  # ======================
  VideoEncodeInfoKHR* = object
    sType* {.constant: (StructureType.videoEncodeInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: VideoEncodeFlagsKHR
    qualityLevel*: uint32
    codedExtent*: Extent2D
    dstBitstreamBuffer*: Buffer
    dstBitstreamBufferOffset*: DeviceSize
    dstBitstreamBufferMaxRange*: DeviceSize
    srcPictureResource*: VideoPictureResourceKHR
    pSetupReferenceSlot*: ptr VideoReferenceSlotKHR
    referenceSlotCount* {.optional.}: uint32
    pReferenceSlots* {.length: referenceSlotCount.}: arrPtr[VideoReferenceSlotKHR]
    precedingExternallyEncodedBytes*: uint32
  VideoEncodeRateControlInfoKHR* = object
    sType* {.constant: (StructureType.videoEncodeRateControlInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    flags*: VideoEncodeRateControlFlagsKHR
    rateControlMode*: VideoEncodeRateControlModeFlagBitsKHR
    layerCount*: uint8
    pLayerConfigs* {.length: layerCount.}: arrPtr[VideoEncodeRateControlLayerInfoKHR]
  VideoEncodeRateControlLayerInfoKHR* = object
    sType* {.constant: (StructureType.videoEncodeRateControlLayerInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    averageBitrate*: uint32
    maxBitrate*: uint32
    frameRateNumerator*: uint32
    frameRateDenominator*: uint32
    virtualBufferSizeInMs*: uint32
    initialVirtualBufferSizeInMs*: uint32
  # NV device diagnostics config
  # ============================
  PhysicalDeviceDiagnosticsConfigFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceDiagnosticsConfigFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    diagnosticsConfig*: Bool32
  DeviceDiagnosticsConfigCreateInfoNV* = object
    sType* {.constant: (StructureType.deviceDiagnosticsConfigCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DeviceDiagnosticsConfigFlagsNV
  # KHR synchronization2
  # ====================
  MemoryBarrier2KHR* = object
    sType* {.constant: (StructureType.memoryBarrier2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcStageMask* {.optional.}: PipelineStageFlags2KHR
    srcAccessMask* {.optional.}: AccessFlags2KHR
    dstStageMask* {.optional.}: PipelineStageFlags2KHR
    dstAccessMask* {.optional.}: AccessFlags2KHR
  BufferMemoryBarrier2KHR* = object
    sType* {.constant: (StructureType.bufferMemoryBarrier2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcStageMask* {.optional.}: PipelineStageFlags2KHR
    srcAccessMask* {.optional.}: AccessFlags2KHR
    dstStageMask* {.optional.}: PipelineStageFlags2KHR
    dstAccessMask* {.optional.}: AccessFlags2KHR
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    buffer*: Buffer
    offset*: DeviceSize
    size*: DeviceSize
  ImageMemoryBarrier2KHR* = object
    sType* {.constant: (StructureType.imageMemoryBarrier2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcStageMask* {.optional.}: PipelineStageFlags2KHR
    srcAccessMask* {.optional.}: AccessFlags2KHR
    dstStageMask* {.optional.}: PipelineStageFlags2KHR
    dstAccessMask* {.optional.}: AccessFlags2KHR
    oldLayout*: ImageLayout
    newLayout*: ImageLayout
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    image*: Image
    subresourceRange*: ImageSubresourceRange
  DependencyInfoKHR* = object
    sType* {.constant: (StructureType.dependencyInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    dependencyFlags* {.optional.}: DependencyFlags
    memoryBarrierCount* {.optional.}: uint32
    pMemoryBarriers* {.length: memoryBarrierCount.}: arrPtr[MemoryBarrier2KHR]
    bufferMemoryBarrierCount* {.optional.}: uint32
    pBufferMemoryBarriers* {.length: bufferMemoryBarrierCount.}: arrPtr[BufferMemoryBarrier2KHR]
    imageMemoryBarrierCount* {.optional.}: uint32
    pImageMemoryBarriers* {.length: imageMemoryBarrierCount.}: arrPtr[ImageMemoryBarrier2KHR]
  SubmitInfo2KHR* = object
    sType* {.constant: (StructureType.submitInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: SubmitFlagsKHR
    waitSemaphoreInfoCount* {.optional.}: uint32
    pWaitSemaphoreInfos* {.length: waitSemaphoreInfoCount.}: arrPtr[SemaphoreSubmitInfoKHR]
    commandBufferInfoCount* {.optional.}: uint32
    pCommandBufferInfos* {.length: commandBufferInfoCount.}: arrPtr[CommandBufferSubmitInfoKHR]
    signalSemaphoreInfoCount* {.optional.}: uint32
    pSignalSemaphoreInfos* {.length: signalSemaphoreInfoCount.}: arrPtr[SemaphoreSubmitInfoKHR]
  SemaphoreSubmitInfoKHR* = object
    sType* {.constant: (StructureType.semaphoreSubmitInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    value*: uint64
    stageMask* {.optional.}: PipelineStageFlags2KHR
    deviceIndex*: uint32
  CommandBufferSubmitInfoKHR* = object
    sType* {.constant: (StructureType.commandBufferSubmitInfoKhr).}: StructureType
    pNext* {.optional.}: pointer
    commandBuffer*: CommandBuffer
    deviceMask*: uint32
  PhysicalDeviceSynchronization2FeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceSynchronization2FeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    synchronization2*: Bool32
  QueueFamilyCheckpointProperties2NV* = object
    sType* {.constant: (StructureType.queueFamilyCheckpointProperties2Nv).}: StructureType
    pNext* {.optional.}: pointer
    checkpointExecutionStageMask*: PipelineStageFlags2KHR
  CheckpointData2NV* = object
    sType* {.constant: (StructureType.checkpointData2Nv).}: StructureType
    pNext* {.optional.}: pointer
    stage*: PipelineStageFlags2KHR
    pCheckpointMarker*: pointer
  # KHR shader subgroup uniform control flow
  # ========================================
  PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderSubgroupUniformControlFlow*: Bool32
  # KHR zero initialize workgroup memory
  # ====================================
  PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceZeroInitializeWorkgroupMemoryFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    shaderZeroInitializeWorkgroupMemory*: Bool32
  # NV fragment shading rate enums
  # ==============================
  PhysicalDeviceFragmentShadingRateEnumsFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShadingRateEnumsFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    fragmentShadingRateEnums*: Bool32
    supersampleFragmentShadingRates*: Bool32
    noInvocationFragmentShadingRates*: Bool32
  PhysicalDeviceFragmentShadingRateEnumsPropertiesNV* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentShadingRateEnumsPropertiesNv).}: StructureType
    pNext* {.optional.}: pointer
    maxFragmentShadingRateInvocationCount*: SampleCountFlagBits
  PipelineFragmentShadingRateEnumStateCreateInfoNV* = object
    sType* {.constant: (StructureType.pipelineFragmentShadingRateEnumStateCreateInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    shadingRateType*: FragmentShadingRateTypeNV
    shadingRate*: FragmentShadingRateNV
    combinerOps*: array[2, FragmentShadingRateCombinerOpKHR]
  # NV ray tracing motion blur
  # ==========================
  AccelerationStructureGeometryMotionTrianglesDataNV* = object
    sType* {.constant: (StructureType.accelerationStructureGeometryMotionTrianglesDataNv).}: StructureType
    pNext* {.optional.}: pointer
    vertexData*: DeviceOrHostAddressConstKHR
  AccelerationStructureMotionInfoNV* = object
    sType* {.constant: (StructureType.accelerationStructureMotionInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    maxInstances*: uint32
    flags* {.optional.}: AccelerationStructureMotionInfoFlagsNV
  AccelerationStructureMotionInstanceNV* = object
    theType*: AccelerationStructureMotionInstanceTypeNV
    flags* {.optional.}: AccelerationStructureMotionInstanceFlagsNV
    data*: AccelerationStructureMotionInstanceDataNV
  AccelerationStructureMotionInstanceDataNV* {.union.} = object
    staticInstance*: AccelerationStructureInstanceKHR
    matrixMotionInstance*: AccelerationStructureMatrixMotionInstanceNV
    srtMotionInstance*: AccelerationStructureSRTMotionInstanceNV
  # The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
  AccelerationStructureMatrixMotionInstanceNV* = object
    transformT0*: TransformMatrixKHR
    transformT1*: TransformMatrixKHR
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags* {.optional.}: GeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64
  # The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
  AccelerationStructureSRTMotionInstanceNV* = object
    transformT0*: SRTDataNV
    transformT1*: SRTDataNV
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags* {.optional.}: GeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64
  SRTDataNV* = object
    sx*: float32
    a*: float32
    b*: float32
    pvx*: float32
    sy*: float32
    c*: float32
    pvy*: float32
    sz*: float32
    pvz*: float32
    qx*: float32
    qy*: float32
    qz*: float32
    qw*: float32
    tx*: float32
    ty*: float32
    tz*: float32
  PhysicalDeviceRayTracingMotionBlurFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceRayTracingMotionBlurFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    rayTracingMotionBlur*: Bool32
    rayTracingMotionBlurPipelineTraceRaysIndirect*: Bool32
  # EXT ycbcr 2plane 444 formats
  # ============================
  PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceYcbcr2Plane444FormatsFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    ycbcr2plane444Formats*: Bool32
  # EXT fragment density map2
  # =========================
  PhysicalDeviceFragmentDensityMap2FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMap2FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityMapDeferred*: Bool32
  PhysicalDeviceFragmentDensityMap2PropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMap2PropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    subsampledLoads*: Bool32
    subsampledCoarseReconstructionEarlyAccess*: Bool32
    maxSubsampledArrayLayers*: uint32
    maxDescriptorSetSubsampledSamplers*: uint32
  # QCOM rotated copy commands
  # ==========================
  CopyCommandTransformInfoQCOM* = object
    sType* {.constant: (StructureType.copyCommandTransformInfoQcom).}: StructureType
    pNext* {.optional.}: pointer
    transform*: SurfaceTransformFlagBitsKHR
  # EXT image robustness
  # ====================
  PhysicalDeviceImageRobustnessFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceImageRobustnessFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    robustImageAccess*: Bool32
  # KHR workgroup memory explicit layout
  # ====================================
  PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    workgroupMemoryExplicitLayout*: Bool32
    workgroupMemoryExplicitLayoutScalarBlockLayout*: Bool32
    workgroupMemoryExplicitLayout8BitAccess*: Bool32
    workgroupMemoryExplicitLayout16BitAccess*: Bool32
  # KHR copy commands2
  # ==================
  CopyBufferInfo2KHR* = object
    sType* {.constant: (StructureType.copyBufferInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcBuffer*: Buffer
    dstBuffer*: Buffer
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[BufferCopy2KHR]
  CopyImageInfo2KHR* = object
    sType* {.constant: (StructureType.copyImageInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcImage*: Image
    srcImageLayout*: ImageLayout
    dstImage*: Image
    dstImageLayout*: ImageLayout
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[ImageCopy2KHR]
  CopyBufferToImageInfo2KHR* = object
    sType* {.constant: (StructureType.copyBufferToImageInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcBuffer*: Buffer
    dstImage*: Image
    dstImageLayout*: ImageLayout
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[BufferImageCopy2KHR]
  CopyImageToBufferInfo2KHR* = object
    sType* {.constant: (StructureType.copyImageToBufferInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcImage*: Image
    srcImageLayout*: ImageLayout
    dstBuffer*: Buffer
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[BufferImageCopy2KHR]
  BlitImageInfo2KHR* = object
    sType* {.constant: (StructureType.blitImageInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcImage*: Image
    srcImageLayout*: ImageLayout
    dstImage*: Image
    dstImageLayout*: ImageLayout
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[ImageBlit2KHR]
    filter*: Filter
  ResolveImageInfo2KHR* = object
    sType* {.constant: (StructureType.resolveImageInfo2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcImage*: Image
    srcImageLayout*: ImageLayout
    dstImage*: Image
    dstImageLayout*: ImageLayout
    regionCount*: uint32
    pRegions* {.length: regionCount.}: arrPtr[ImageResolve2KHR]
  BufferCopy2KHR* = object
    sType* {.constant: (StructureType.bufferCopy2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcOffset*: DeviceSize # Specified in bytes
    dstOffset*: DeviceSize # Specified in bytes
    size*: DeviceSize # Specified in bytes
  ImageCopy2KHR* = object
    sType* {.constant: (StructureType.imageCopy2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcSubresource*: ImageSubresourceLayers
    srcOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    dstSubresource*: ImageSubresourceLayers
    dstOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    extent*: Extent3D # Specified in pixels for both compressed and uncompressed images
  ImageBlit2KHR* = object
    sType* {.constant: (StructureType.imageBlit2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcSubresource*: ImageSubresourceLayers
    srcOffsets*: array[2, Offset3D] # Specified in pixels for both compressed and uncompressed images
    dstSubresource*: ImageSubresourceLayers
    dstOffsets*: array[2, Offset3D] # Specified in pixels for both compressed and uncompressed images
  BufferImageCopy2KHR* = object
    sType* {.constant: (StructureType.bufferImageCopy2Khr).}: StructureType
    pNext* {.optional.}: pointer
    bufferOffset*: DeviceSize # Specified in bytes
    bufferRowLength*: uint32 # Specified in texels
    bufferImageHeight*: uint32
    imageSubresource*: ImageSubresourceLayers
    imageOffset*: Offset3D # Specified in pixels for both compressed and uncompressed images
    imageExtent*: Extent3D # Specified in pixels for both compressed and uncompressed images
  ImageResolve2KHR* = object
    sType* {.constant: (StructureType.imageResolve2Khr).}: StructureType
    pNext* {.optional.}: pointer
    srcSubresource*: ImageSubresourceLayers
    srcOffset*: Offset3D
    dstSubresource*: ImageSubresourceLayers
    dstOffset*: Offset3D
    extent*: Extent3D
  # EXT 4444 formats
  # ================
  PhysicalDevice4444FormatsFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDevice4444FormatsFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    formatA4R4G4B4*: Bool32
    formatA4B4G4R4*: Bool32
  # ARM rasterization order attachment access
  # =========================================
  PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM* = object
    sType* {.constant: (StructureType.physicalDeviceRasterizationOrderAttachmentAccessFeaturesArm).}: StructureType
    pNext* {.optional.}: pointer
    rasterizationOrderColorAttachmentAccess*: Bool32
    rasterizationOrderDepthAttachmentAccess*: Bool32
    rasterizationOrderStencilAttachmentAccess*: Bool32
  # EXT rgba10x6 formats
  # ====================
  PhysicalDeviceRGBA10X6FormatsFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceRgba10x6FormatsFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    formatRgba10x6WithoutYCbCrSampler*: Bool32
  # EXT directfb surface
  # ====================
  DirectFBSurfaceCreateInfoEXT* = object
    sType* {.constant: (StructureType.directfbSurfaceCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: DirectFBSurfaceCreateFlagsEXT
    dfb*: ptr IDirectFB
    surface*: ptr IDirectFBSurface
  # VALVE mutable descriptor type
  # =============================
  PhysicalDeviceMutableDescriptorTypeFeaturesVALVE* = object
    sType* {.constant: (StructureType.physicalDeviceMutableDescriptorTypeFeaturesValve).}: StructureType
    pNext* {.optional.}: pointer
    mutableDescriptorType*: Bool32
  MutableDescriptorTypeListVALVE* = object
    descriptorTypeCount* {.optional.}: uint32
    pDescriptorTypes* {.length: descriptorTypeCount.}: arrPtr[DescriptorType]
  MutableDescriptorTypeCreateInfoVALVE* = object
    sType* {.constant: (StructureType.mutableDescriptorTypeCreateInfoValve).}: StructureType
    pNext* {.optional.}: pointer
    mutableDescriptorTypeListCount* {.optional.}: uint32
    pMutableDescriptorTypeLists* {.length: mutableDescriptorTypeListCount.}: arrPtr[MutableDescriptorTypeListVALVE]
  # EXT vertex input dynamic state
  # ==============================
  PhysicalDeviceVertexInputDynamicStateFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceVertexInputDynamicStateFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    vertexInputDynamicState*: Bool32
  VertexInputBindingDescription2EXT* = object
    sType* {.constant: (StructureType.vertexInputBindingDescription2Ext).}: StructureType
    pNext* {.optional.}: pointer
    binding*: uint32
    stride*: uint32
    inputRate*: VertexInputRate
    divisor*: uint32
  VertexInputAttributeDescription2EXT* = object
    sType* {.constant: (StructureType.vertexInputAttributeDescription2Ext).}: StructureType
    pNext* {.optional.}: pointer
    location*: uint32 # location of the shader vertex attrib
    binding*: uint32 # Vertex buffer binding id
    format*: Format # format of source data
    offset*: uint32 # Offset of first element in bytes from base of vertex
  # EXT physical device drm
  # =======================
  PhysicalDeviceDrmPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceDrmPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    hasPrimary*: Bool32
    hasRender*: Bool32
    primaryMajor*: int64
    primaryMinor*: int64
    renderMajor*: int64
    renderMinor*: int64
  # EXT depth clip control
  # ======================
  PhysicalDeviceDepthClipControlFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceDepthClipControlFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    depthClipControl*: Bool32
  PipelineViewportDepthClipControlCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineViewportDepthClipControlCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    negativeOneToOne*: Bool32
  # EXT primitive topology list restart
  # ===================================
  PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDevicePrimitiveTopologyListRestartFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    primitiveTopologyListRestart*: Bool32
    primitiveTopologyPatchListRestart*: Bool32
  # KHR format feature flags2
  # =========================
  FormatProperties3KHR* = object
    sType* {.constant: (StructureType.formatProperties3Khr).}: StructureType
    pNext* {.optional.}: pointer
    linearTilingFeatures* {.optional.}: FormatFeatureFlags2KHR
    optimalTilingFeatures* {.optional.}: FormatFeatureFlags2KHR
    bufferFeatures* {.optional.}: FormatFeatureFlags2KHR
  # FUCHSIA external memory
  # =======================
  ImportMemoryZirconHandleInfoFUCHSIA* = object
    sType* {.constant: (StructureType.importMemoryZirconHandleInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    handleType* {.optional.}: ExternalMemoryHandleTypeFlagBits
    handle* {.optional.}: zx_handle_t
  MemoryZirconHandlePropertiesFUCHSIA* = object
    sType* {.constant: (StructureType.memoryZirconHandlePropertiesFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    memoryTypeBits*: uint32
  MemoryGetZirconHandleInfoFUCHSIA* = object
    sType* {.constant: (StructureType.memoryGetZirconHandleInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
    handleType*: ExternalMemoryHandleTypeFlagBits
  # FUCHSIA external semaphore
  # ==========================
  ImportSemaphoreZirconHandleInfoFUCHSIA* = object
    sType* {.constant: (StructureType.importSemaphoreZirconHandleInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    flags* {.optional.}: SemaphoreImportFlags
    handleType*: ExternalSemaphoreHandleTypeFlagBits
    zirconHandle*: zx_handle_t
  SemaphoreGetZirconHandleInfoFUCHSIA* = object
    sType* {.constant: (StructureType.semaphoreGetZirconHandleInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    semaphore*: Semaphore
    handleType*: ExternalSemaphoreHandleTypeFlagBits
  # FUCHSIA buffer collection
  # =========================
  BufferCollectionCreateInfoFUCHSIA* = object
    sType* {.constant: (StructureType.bufferCollectionCreateInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    collectionToken*: zx_handle_t
  ImportMemoryBufferCollectionFUCHSIA* = object
    sType* {.constant: (StructureType.importMemoryBufferCollectionFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    collection*: BufferCollectionFUCHSIA
    index*: uint32
  BufferCollectionImageCreateInfoFUCHSIA* = object
    sType* {.constant: (StructureType.bufferCollectionImageCreateInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    collection*: BufferCollectionFUCHSIA
    index*: uint32
  BufferConstraintsInfoFUCHSIA* = object
    sType* {.constant: (StructureType.bufferConstraintsInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    createInfo*: BufferCreateInfo
    requiredFormatFeatures* {.optional.}: FormatFeatureFlags
    bufferCollectionConstraints*: BufferCollectionConstraintsInfoFUCHSIA
  BufferCollectionBufferCreateInfoFUCHSIA* = object
    sType* {.constant: (StructureType.bufferCollectionBufferCreateInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    collection*: BufferCollectionFUCHSIA
    index*: uint32
  BufferCollectionPropertiesFUCHSIA* = object
    sType* {.constant: (StructureType.bufferCollectionPropertiesFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    memoryTypeBits*: uint32
    bufferCount*: uint32
    createInfoIndex*: uint32
    sysmemPixelFormat*: uint64
    formatFeatures*: FormatFeatureFlags
    sysmemColorSpaceIndex*: SysmemColorSpaceFUCHSIA
    samplerYcbcrConversionComponents*: ComponentMapping
    suggestedYcbcrModel*: SamplerYcbcrModelConversion
    suggestedYcbcrRange*: SamplerYcbcrRange
    suggestedXChromaOffset*: ChromaLocation
    suggestedYChromaOffset*: ChromaLocation
  SysmemColorSpaceFUCHSIA* = object
    sType* {.constant: (StructureType.sysmemColorSpaceFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    colorSpace*: uint32
  ImageConstraintsInfoFUCHSIA* = object
    sType* {.constant: (StructureType.imageConstraintsInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    formatConstraintsCount*: uint32
    pFormatConstraints* {.length: formatConstraintsCount.}: arrPtr[ImageFormatConstraintsInfoFUCHSIA]
    bufferCollectionConstraints*: BufferCollectionConstraintsInfoFUCHSIA
    flags* {.optional.}: ImageConstraintsInfoFlagsFUCHSIA
  ImageFormatConstraintsInfoFUCHSIA* = object
    sType* {.constant: (StructureType.imageFormatConstraintsInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    imageCreateInfo*: ImageCreateInfo
    requiredFormatFeatures*: FormatFeatureFlags
    flags* {.optional.}: ImageFormatConstraintsFlagsFUCHSIA
    sysmemPixelFormat* {.optional.}: uint64
    colorSpaceCount*: uint32
    pColorSpaces*: ptr SysmemColorSpaceFUCHSIA
  BufferCollectionConstraintsInfoFUCHSIA* = object
    sType* {.constant: (StructureType.bufferCollectionConstraintsInfoFuchsia).}: StructureType
    pNext* {.optional.}: pointer
    minBufferCount*: uint32
    maxBufferCount*: uint32
    minBufferCountForCamping*: uint32
    minBufferCountForDedicatedSlack*: uint32
    minBufferCountForSharedSlack*: uint32
  # HUAWEI subpass shading
  # ======================
  SubpassShadingPipelineCreateInfoHUAWEI* = object
    sType* {.constant: (StructureType.subpassShadingPipelineCreateInfoHuawei).}: StructureType
    pNext* {.optional.}: pointer
    renderPass*: RenderPass
    subpass*: uint32
  PhysicalDeviceSubpassShadingFeaturesHUAWEI* = object
    sType* {.constant: (StructureType.physicalDeviceSubpassShadingFeaturesHuawei).}: StructureType
    pNext* {.optional.}: pointer
    subpassShading*: Bool32
  PhysicalDeviceSubpassShadingPropertiesHUAWEI* = object
    sType* {.constant: (StructureType.physicalDeviceSubpassShadingPropertiesHuawei).}: StructureType
    pNext* {.optional.}: pointer
    maxSubpassShadingWorkgroupSizeAspectRatio*: uint32
  # HUAWEI invocation mask
  # ======================
  PhysicalDeviceInvocationMaskFeaturesHUAWEI* = object
    sType* {.constant: (StructureType.physicalDeviceInvocationMaskFeaturesHuawei).}: StructureType
    pNext* {.optional.}: pointer
    invocationMask*: Bool32
  # NV external memory rdma
  # =======================
  MemoryGetRemoteAddressInfoNV* = object
    sType* {.constant: (StructureType.memoryGetRemoteAddressInfoNv).}: StructureType
    pNext* {.optional.}: pointer
    memory*: DeviceMemory
    handleType*: ExternalMemoryHandleTypeFlagBits
  PhysicalDeviceExternalMemoryRDMAFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceExternalMemoryRdmaFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    externalMemoryRDMA*: Bool32
  # EXT extended dynamic state2
  # ===========================
  PhysicalDeviceExtendedDynamicState2FeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceExtendedDynamicState2FeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    extendedDynamicState2*: Bool32
    extendedDynamicState2LogicOp*: Bool32
    extendedDynamicState2PatchControlPoints*: Bool32
  # QNX screen surface
  # ==================
  ScreenSurfaceCreateInfoQNX* = object
    sType* {.constant: (StructureType.screenSurfaceCreateInfoQnx).}: StructureType
    pNext* {.optional.}: pointer
    flags* {.optional.}: ScreenSurfaceCreateFlagsQNX
    context*: ptr screen_context
    window*: ptr screen_window
  # EXT color write enable
  # ======================
  PhysicalDeviceColorWriteEnableFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceColorWriteEnableFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    colorWriteEnable*: Bool32
  PipelineColorWriteCreateInfoEXT* = object
    sType* {.constant: (StructureType.pipelineColorWriteCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    attachmentCount* {.optional.}: uint32 # # of pAttachments
    pColorWriteEnables* {.length: attachmentCount.}: arrPtr[Bool32]
  # EXT global priority query
  # =========================
  PhysicalDeviceGlobalPriorityQueryFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceGlobalPriorityQueryFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    globalPriorityQuery*: Bool32
  QueueFamilyGlobalPriorityPropertiesEXT* = object
    sType* {.constant: (StructureType.queueFamilyGlobalPriorityPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    priorityCount*: uint32
    priorities*: array[MaxGlobalPrioritySizeExt, QueueGlobalPriorityEXT]
  # EXT image view min lod
  # ======================
  PhysicalDeviceImageViewMinLodFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceImageViewMinLodFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    minLod*: Bool32
  ImageViewMinLodCreateInfoEXT* = object
    sType* {.constant: (StructureType.imageViewMinLodCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    minLod*: float32
  # EXT multi draw
  # ==============
  PhysicalDeviceMultiDrawFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceMultiDrawFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    multiDraw*: Bool32
  PhysicalDeviceMultiDrawPropertiesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceMultiDrawPropertiesExt).}: StructureType
    pNext* {.optional.}: pointer
    maxMultiDrawCount*: uint32
  MultiDrawInfoEXT* = object
    firstVertex*: uint32
    vertexCount*: uint32
  MultiDrawIndexedInfoEXT* = object
    firstIndex*: uint32
    indexCount*: uint32
    vertexOffset*: int32
  # EXT border color swizzle
  # ========================
  PhysicalDeviceBorderColorSwizzleFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDeviceBorderColorSwizzleFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    borderColorSwizzle*: Bool32
    borderColorSwizzleFromImage*: Bool32
  SamplerBorderColorComponentMappingCreateInfoEXT* = object
    sType* {.constant: (StructureType.samplerBorderColorComponentMappingCreateInfoExt).}: StructureType
    pNext* {.optional.}: pointer
    components*: ComponentMapping
    srgb*: Bool32
  # EXT pageable device local memory
  # ================================
  PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* = object
    sType* {.constant: (StructureType.physicalDevicePageableDeviceLocalMemoryFeaturesExt).}: StructureType
    pNext* {.optional.}: pointer
    pageableDeviceLocalMemory*: Bool32
  # KHR maintenance4
  # ================
  PhysicalDeviceMaintenance4FeaturesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceMaintenance4FeaturesKhr).}: StructureType
    pNext* {.optional.}: pointer
    maintenance4*: Bool32
  PhysicalDeviceMaintenance4PropertiesKHR* = object
    sType* {.constant: (StructureType.physicalDeviceMaintenance4PropertiesKhr).}: StructureType
    pNext* {.optional.}: pointer
    maxBufferSize*: DeviceSize
  DeviceBufferMemoryRequirementsKHR* = object
    sType* {.constant: (StructureType.deviceBufferMemoryRequirementsKhr).}: StructureType
    pNext* {.optional.}: pointer
    pCreateInfo*: ptr BufferCreateInfo
  DeviceImageMemoryRequirementsKHR* = object
    sType* {.constant: (StructureType.deviceImageMemoryRequirementsKhr).}: StructureType
    pNext* {.optional.}: pointer
    pCreateInfo*: ptr ImageCreateInfo
    planeAspect*: ImageAspectFlagBits
  # QCOM fragment density map offset
  # ================================
  PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMapOffsetFeaturesQcom).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityMapOffset*: Bool32
  PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* = object
    sType* {.constant: (StructureType.physicalDeviceFragmentDensityMapOffsetPropertiesQcom).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityOffsetGranularity*: Extent2D
  SubpassFragmentDensityMapOffsetEndInfoQCOM* = object
    sType* {.constant: (StructureType.subpassFragmentDensityMapOffsetEndInfoQcom).}: StructureType
    pNext* {.optional.}: pointer
    fragmentDensityOffsetCount* {.optional.}: uint32
    pFragmentDensityOffsets* {.length: fragmentDensityOffsetCount.}: arrPtr[Offset2D]
  # NV linear color attachment
  # ==========================
  PhysicalDeviceLinearColorAttachmentFeaturesNV* = object
    sType* {.constant: (StructureType.physicalDeviceLinearColorAttachmentFeaturesNv).}: StructureType
    pNext* {.optional.}: pointer
    linearColorAttachment*: Bool32